> SQL 优化包括：查询 SQL 语句优化、索引优化、库表结构优化

# 导致慢查询的原因

- 扫描行数过多
    
- 返回的结果集行数过多
    
- 每行的列的大小过大
    

> 为了获取 id 为 1~10 的数据，程序员不会故意扫描 id 为 1~100 的再过滤掉 11~100。所以扫描行数过多通常是因为查询语句多表联查的 SQL 结构有问题

注意：扫描的行数不一定等于返回的结果集的行数。举几个例子

- where id=100。扫描了 n 行，返回的结果集只有 1 行
    
- where id<=10。扫描了 10 行，返回的结果集里有 10 行
    
- 多表查询时扫描的行数通常比返回的结果集行数多，哪怕扫描行数和返回的结果集的行数比值为 100:1 也正常
    

# 慢查询基础和 EXPLAIN 重要字段说明

慢查询最基本的问题是访问的数据太多，扫描数据，筛选和分析数据的数据量太大

解决这个问题的关键两步是

- 确认应用程序**是否访问了很多重复的数据**
    
- 确认 MySQL **是否分析了大量不要的数据**
    
    举个例子：用 count 统计 id>999 的数据行数量，用 `count(*) - count(id<=999)` 要比 `count(id>999)` 好的多
    

根据 `where` 导致的扫描行数和返回的结果集行数的情况，`where` 把执行计划的 `Extra` 分为

从好到坏依次为：

- 直接用索引中的数据匹配 `where_list` 条件，过滤不匹配的记录。这是在存储引擎层完成的
    
- 用索引覆盖扫描（`Extra: Using index`）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在 MySQL 服务器层完成的，无须再回表查询记录
    
- 把磁盘中的数据行读到内存里，再拿数据匹配 `where_list`，过滤不满足条件的记录（`Extra: Using Where`）。这在 MySQL 服务器层完成
    

EXPLAIN 语句的 type 反映了访问类型。访问类型包括：全表扫描 `ALL`，索引扫描 `index`，范围扫描 `range`，唯一索引查询 `unique index`，常数引用 `const`。速度从慢到快，扫描的行数从多到少

所以如果能用索引数据直接过滤掉数据，其访问磁盘数量会减少；如果 SQL 语句和索引设置得当 type 也会使得扫描的数据行变少

# 查询的宏观执行过程

如果把查询看作是一个任务，那么它由一系列子任务组成。如果要优化查询，实际上要优化其子任务

-   要么消除其中一些子任务
    
-   要么减少子任务的执行次数
    
-   要么让子任务运行得更快
    

[SELECT SQL 语句在 MySQL 中的执行过程](https://snailclimb.gitee.io/javaguide/#/docs/database/mysql/how-sql-executed-in-mysql)参考这里

# 重构查询的方式


## 是否需要把一个复杂查询划分为多个简单查询

- 一个复杂查询 A 耗时 a，多个简单查询 B，C，D 均可进行独立的缓存，其查询时间 a >= b + c + d
    
- 利于分库，减少了跨库查询的可能
    
- 复杂查询的锁竞争比多个简单查询的锁竞争激烈
    
- 多个简答查询如果能变成并行执行
    

## 是否需要把大范围的修改操作划分为多个小范围的修改操作

-   防止一条语句执行过程中锁住大量资源
    
-   防止一条语句执行结束后的 binlog 日志写的任务量过大
    
-   防止 binlog 日志内容突然激增，导致从机复制效率降低
    
-   一个复杂查询划分为多个简单查询可能还有利于分库分表，防止跨库 jion
    

## 特定查询类型的优化

### count 优化

-   如果是粗略统计，可以用 explain 统计。这个命令的效率高
    
-   count 会扫描很多行，MySQL 只能用索引覆盖优化
    

### limit 优化

-   覆盖索引 + 延迟关联
    
-   提前计算查询数据的列值范围，用 in 或 between 等范围查询对特定列进行查询
    
    比如已知数据 id 严格递增，分页查询每次 20 条数据。上次获取的是 id 1010~1030，下次获取 id 1030~1050
    

### union 查询

`union all` 和 `union` 的区别在于后者会给临时表加上 `distinct` 选项


## 关联查询优化

### MySQL 内部执行查询的优化流程

查询优化器在执行查询前会根据之前的统计信息生成多种查询方案，然后选择一个代价最小的方案

但这是预估的代价，并不代表一定是最优的

MySQL 的优化分为静态优化和动态优化。静态优化就是分析 AST

其优化方式还是比较常规的，优化算数运算，删除冗余条件，折叠、合并过滤条件...

查询优化器会分析 AST，为`where_list`中的字段重新排序，选择合适的索引，如果是关联查询还会尝试**选择驱动表和被驱动表**


# MySQL 执行关联查询的原理

MySQL 把所有查询都视为关联查询

MySQL 的查询结果都会被放在一张临时表中，临时表中的列定义来自查询语句的 `select_list`，数据来自物理表

-   如果是单表查询，最终会直接返回临时表
    
-   如果是关联查询，会先执行一张表的查询，将中间结果放在临时表中，然后再进行关联查询，生成最终结果的临时表
    

因为计算过程都需要中间表，所以 MySQL 把所有查询都视为关联查询

真正的多表关联查询的执行靠的是嵌套循环

多表联查时，MySQL 逻辑上会建立这些表的笛卡尔积

实际上时通过嵌套循环，实现两张表数据的笛卡尔积，在嵌套循环时就用条件语句筛掉不匹配的数据行

```c
while(outer_lines.hasNext()) {  
  outer_line = outer_lines.next();  
  while(inner_lines.hasNext()) {  
	  inner_line = match(condition_list, inner_lines.next());  
	  if(inner_line != null) merge(outer_line, inner_line);  
  }  
}
```

了解其执行过程能更有利于设计更好的索引和 sql 语句

注意：查询形成的临时表中没有任何索引，所以在中间表上的查询是能是遍历方式

## MySQL 的 SQL 语句解析和执行过程概述

MySQL Server 收到 sql 语句后，将其解析为 AST。sql 的执行直接根据 AST 执行，而不再生成 lower IR

这个 AST 已经能很好地表示 sql 中各个关键字的层级结构，尤其是多表查询的的层级结构

Q：执行多表查询时，先查询哪些表，生成临时表后再和下一张表进行联表查，生成下一个临时表...

A：MySQL 对 AST 进行先序深搜，进行联表查询

![image-20220425205008334](https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220425205008334.png)


## 小表驱动大表的查询优化

之前说过，关联查询的本质是嵌套循环

下面给一个小表作驱动表，和一个大表作被驱动表的例子

```c
// fun1: 小表作驱动表  
 for(20条)  
     for(20万条)  
         ...

 // fun2: 大表作驱动表  
 for(20万条)  
     for(20条)  
         ...
```

上述两种方式的时间复杂度**看似**都是 20 * 20W

但每次执行内循环前都需要执行一次连接，fun1 需要建立 20 次连接，fun2 需要执行 20W 次

此外由于中间表不能使用索引，所以

- 当用 fun1 时，会用到 20W 条数据所在表的索引，所以时间复杂度 = 20 * n（如果索引合适，n 将远小于 20W）
    
- 当用 fun2 时，会用到 20 条数据所在表的索引，所以时间复杂度 = 20 W * n（显然 n ≈ 20）
    

MySQL 的关联优化器会尽量调整多表查询时的连接顺序，让小表作为驱动表

但这不能保证每次都能选择最优的执行计划，所以还需要人为控制表的关联顺序


## 排序优化

如果没用到索引进行排序，那么不管排序在内存中进行还是在磁盘中进行，其执行计划的 `Extra` 都将其称为 `file sort`

- 所需排序数据量少时，直接在内存中进行快排
    
- 所需排序数据量多时，在内存和磁盘中进行外排
    

如果多表查询中**仅根据第一张表中字段排序**，那么**排序会在多表关联前进行**。如果直接用到索引最好，否则就是 filesort

如果多表查询中还**用到第一张表外的其他表中字段排序**，那么排序会**在关联完成后进行**。执行计划的 `Extra` 将会是 `Using temporary; Using filesort`