#还没有复习 

> 基于 MySQL 5.6



# 第 1 章：MySQL 体系结构和存储引擎



## MySQL 的一点常识

数据库：物理数据文件组成的集合

实例：由用于控制数据文件的多个线程和内存组成



配置文件：MySQL 默认读取一些文件作为启动实例时的配置文件。Linux 上可用`mysql --help | grep my.cnf` 查看。MySQL 启动实例时可以同时读取多个配置文件，后读的文件内容可以覆盖前面的配置。如果这些配置文件都不存在，MySQL 会使用编译时默认的参数设置启动实例



data 文件夹：配置文件中的`datadir`指定了数据库所在的目录。也可以在 MySQL 实例运行时用 show 命令查询 datadir 变量获取其值



MySQL 是单进程多线程的



## MySQL 体系结构和插件式存储引擎

插件式的存储引擎是 MySQL 不同于其他数据库的一大特点，而且 MySQL 的存储引擎控制的目标对象的最小单元是表，而不是数据库

<img src="https://img-blog.csdn.net/20180831173911997?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pfcnlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom: 45%;" /><img src="https://pic3.zhimg.com/v2-e22b20b8a3306531796ce0fa3cb31122_b.jpg" alt="img" style="zoom:60%;" />

左图为基于 MySQL 5.6 的架构图，右图为简化图



[MySQL 基础架构分析](https://snailclimb.gitee.io/javaguide/#/docs/database/mysql/how-sql-executed-in-mysql)

[常见存储引擎](http://c.biancheng.net/view/7160.html)



> 这些文件都在 datadir 目录下。`datadir`也是 MySQL 运行时的当前目录



# 第 2 章：InnoDB 存储引擎

> 体系架构，CheckPoint 技术，线程工作方式，关键特性，启动关闭和恢复



## 体系结构

体系结构：各种用途的后台线程 + 内存缓冲池（可以设置多个缓冲池实例） + 物理文件

<img src="https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/Snipaste_2022-03-28_11-43-36.png" alt="Snipaste_2022-03-28_11-43-36" style="zoom:33%;" />

<center>InnoDB 存储引擎 架构</center>

## 后台线程

- 主线程：把缓冲池中的数据异步刷回磁盘。包括脏页，redo log
- IO 线程：还可细分为 insert，log，read，write 四种 IO 线程
- Purge 线程：用于回收清理掉那些事务被提交后就不再被需要的 undo log
- Page Cleaner 线程：负责数据写回磁盘的任务

上述主线程的部分任务实质上是交给了其他线程，比如 Page Cleaner 线程才是把内存数据写回磁盘的执行者





## 内存缓冲池

包含了 redo log 缓冲区，额外内存缓冲区，缓存缓冲区，锁信息...

高版本的 MySQL 已经移除了缓存功能，所以不再讨论缓存缓冲区。但数据的更新，插入等还是会先写到缓冲池中

<img src="https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/Snipaste_2022-03-28_11-38-20.png" alt="Snipaste_2022-03-28_11-38-20" style="zoom:67%;" />





### redo log

redo log 用于记录结果还未被写回磁盘的事务的日志

redo log 日志用于恢复数据，保证 MySQL 宕机后，能用 redo log 恢复那些已经执行结束的但还未写回磁盘中的事务

当事务结果被写回磁盘后，redo log 中的部分日志就不再被需要，为充分利用磁盘空间 redo log 采用多个文件组成的环形链表方式记录可用空间和不可用空间



为保证数据能用 redo log 进行恢复，需要保证指令执行之前先记录 redo log。防止指令执行结束但还没来得及记录 log 就宕机了



redo log 缓冲区被写回磁盘的时机：

- 线程每隔 1s 都会执行一次写回
- 事务提交后立即执行写回
- 如果 redo log 所用缓冲区被占用区域超过 1/2 就执行写回



### checkpoint 技术

checkpoint 的目的是用来解决以下几个问题

- 缩短数据库执行恢复的时间（执行恢复时，仅执行 checkpoint 后的数据恢复）
- 缓冲池不够用时，将脏页刷盘
- 重做日志不可用时，新的日志会覆盖不可用的日志，防止重做日志的物理文件过大



checkpoint 技术用于

- 控制把脏页写回磁盘的时机
- 选择把哪些脏页写回磁盘



## Master Thread





## 物理文件

先简单描述下，详情稍后再聊

- 基于 InnoDB 的表的物理文件是`idb`文件，包含的索引记录和数据行记录，数据行记录根据主键顺序写入 idb 文件，如果创建表时没有显式声明主键，默认采用 rowid（6 字节）的隐藏字段作为主键
- 基于 MyISAM 的表的物理文件是`MYD`数据文件，`MYI`索引文件。索引记录和数据行记录分别放在不同的物理文件中



## ~~InnoDB 关键特性~~

insert buffer，change buffer。两次写，异步 IO

这些机制用于提升 MySQL 的读写性能





# 第 3 章：文件

> 日志文件，表结构文件，配置文件，套接字文件，pid 文件，存储引擎相关文件



## 参数文件

- 静态参数：实例启动后，不能再被修改的参数
- 动态参数：实例启动后，可修改的参数



参数被保存到数据库的一张表里。参数的作用域可分为全局性的和会话性的

- 全局参数：所有会话共用的参数
- 会话参数：同一个会话内用的参数。不同会话的同名参数的值可以定制



查询参数的方式：

- `show variables like '%xxx%'`。模糊搜索
- `select @@global/session.xxx`。精确查询



修改参数的方式

`set @@global/session.xxx=xxx`

但这种修改方式不会修改配置文件中的值，下次用同一个配置文件启动实例时，还是使用配置文件的旧值而不是执行过 set 以后的新值



## 日志文件

下述文件是 MySQL 架构持有的，不是某个存储引擎特有的 

- 错误日志：error.log
- 慢查询日志：输出的日志可以被放到表里，也可以被重定向输出到文件里
- 查询日志
- 二进制日志：bin.log 用于恢复，复制，审计
- ~~套接字文件~~（对我没用）
- pid 文件：mysql 的实例进程号会被写在 pid 文件里



二进制日志的记录格式有两种：statement，row

- statement 记录的是逻辑 sql 语句
- row 记录的是 sql 语句执行前数据的值和执行后数据的值



二进制日志先被写入缓冲区（内存），再被写回磁盘。二进制日志的写回时机和生效时机还会影响到复制时的主从一致性，MySQL 通过设置默认的隔离级别为 RR 来解决这个问题



二进制日志是二进制文件，不能直接用 cat，tail 等命令查看。需要用 mysqlbinlog



单个日志文件过大时会创建一个新的文件



如果仅采用 row 格式记录 binlog 可能会导致日志文件迅速膨胀



> 上述各种文件的文件名，文件位置，是否开启此功能，写入日志的时机，格式，日志写入缓冲区的时机，写入磁盘的时机等均能在参数里设置
> 这些文件多数默认被保存在`datadir`文件夹里



## 表结构文件

表结构由 MySQL 定义，表结构文件和表具体使用哪种存储引擎无关

表结构文件保存表和视图的定义，是`.frm`文件，是文本文件，能直接被人类阅读



## InnoDB 存储引擎文件



- 表空间文件
- 重做日志文件



### 表空间文件

sql 语句里的表是逻辑表，表空间 = 表空间文件 = 表空间物理文件



一个表空间物理文件能保存了若干个逻辑表中的数据



MySQL 的 InnoDB 默认的系统表空间为`datadir/ibdata1`，如果没有其他表空间，那么所有的表的所有数据都在这个文件里

可以修改表空间文件参数，设置多个表空间文件，如果它们属于同一台机器的不同的硬盘就能实现性能提升。因为两个硬盘可以并行工作

也可以设置表空间参数，令每张表都拥有一个独立的表空间，即每个逻辑表都有自己的`.ibd`文件。但就算开启了此功能，InnoDB 下的所有表的数据都保存在自己的表空间，系统表空间作为共享空间，仍会保存所有 InnoDB 下的表的一些元数据





### 重做日志文件

redo log 文件，记录那些已经被提交但提交结果还未被持久化的事务的数据

- 其作用是在磁盘损坏，MySQL 不正常宕机时恢复还未被持久化但事务已经被提交的数据
- 其内容先被写到 MySQL 进程缓存中，再被写到文件系统的缓存中（这两个缓存都是内存），再被持久化到硬盘里
- 其日志格式为物理日志，记录了磁盘的哪些位置应该被放哪些数据。所以只能用于本机恢复数据
- 其写日志是每次执行修改命令时都会写日志（写入内存），建议设置在提交事务时同步执行刷盘，保证事务的持久性



# 第 4 章：表和数据行的逻辑&物理结构

- 索引组织表
- InnoDB 逻辑存储结构
- InnoDB 行记录格式
- InnoDB 数据页结构



## 索引组织表

InnoDB 下的所有表一定有一个主键，主键的 key 至少有一个

- 如果显式声明了 a 是主键，a 就是主键
- 如果没有显式声明主键
  - 寻找创建表时第一个声明为非空唯一键的 key 为主键
  - 如果没有非空唯一的键，自动生成一个 `_rowid`隐藏字段（6 字节）作为主键



如果用显式声明的 a 作为主键或第一个非空唯一键做为主键，且主键的 key 只有一个，则`_rowid`的值和主键的值保持一致，否则没有`_rowid`字段



## 表的逻辑结构

表空间 > 段 > 区 > 页/块



- 段被分为：数据段，索引段，undo 段。数据段就是 B+Tree 的节点

- 区大小固定为 1M，由若干连续的页组成。如果页的大小改变，组成区的页的数量也会改变，但一个区的大小一定是 1 M 不会改变

- 页是 InnoDB 管理磁盘的最小单元，但它是 InnoDB 规定的页，而不是操作系统规定的页



## 约束&视图&触发器

- 约束：唯一值约束，非空约束，defalut 值约束，enum 约束（字段值只能从 enum 里选）
- 触发器：执行增删改的前后执行的一些行为
- 视图：逻辑表
- 物化视图（MySQL 里没有，Oracle 里有）



## 分区表

- 水平分区：同一表的不同行的记录放到不同的物理文件里
- 垂直分区：同一表的不同列的记录放到不同的物理文件里



# 第 5 章：索引和算法





B+Tree 的叶子节点逻辑上是顺序存储的，物理上不需要顺序存储，否则维护成本会很高







# 第 6 章：锁







# 第 7 章：事务





# 第 8 章：备份与恢复







# ~~第 9 章：性能调优~~

