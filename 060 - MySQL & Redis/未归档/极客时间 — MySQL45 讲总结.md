# 基础篇


## 基础架构：一条查询语句的执行过程

![[../../020 - 附件文件夹/Pasted image 20230402101647.png|500]]

MySQL架构：Server层（由上图几个部分组成），存储引擎层

- 连接器：判断能否连接mysql服务并管理成功连上服务的连接。

  判断是否开启远程连接，用户名密码是否正确等。`mysql -u<username> -p`这条命令就是连接器管的

  连接上mysql后使用`show processlist`能查询所有连接和连接状态

  短链接：执行几次操作就断掉重连的连接。长连接：不轻易断掉的连接。  最好用长连接，但是长连接会堆积数据到内存。需要定时清理连接内存或重连连接（会一并清理连接的内存）

- 查询缓存。缓存以kv对形式存在，key是查询语句，v是查询结果集

  每当数据更新时缓存就会失效，对于常有更新操作的表来说，缓存会影响效率，所以`mysql8.0`后直接将缓存这个功能全部移除

- 分析器：词法分析，语法分析。

  词法分析：例如将sql语句中的select识别出来，将sql语句视为查询语句，将`<tableName>`识别为表名等

  语法分析：例如select单词少写了一个字母，语法分析会将其分析出来

  其中，表是否存在的判断就是在分析器中做的，这种错误越早发现越好

- 优化器：当查询需要选择索引或查询涉及多张表时，优化器会为其选择索引，决定多表查询要先查询哪张表等。为查询选择一条“最优的路线”

- 执行器：判断权限，操作存储引擎查找数据

  如果权限不足，则不能执行。权限足够才能打开表（表的字段并不是数据，访问表本身和表中字段并不需要权限，所以分析器能查询表是否存在，表中是否含有指定字段等，同时分析器却不能查询表中数据）



## 日志系统：一条SQL更新语句是如何执行的

![[../../020 - 附件文件夹/Pasted image 20230402101658.png|500]]

核心在于`redo log`和`binlog`。前者是物理日志，后者是逻辑日志

`redo log` 由InnoDB提供，每次执行更新时，先将更新结果放进`redo log`，在空闲时再将数据写入存储引擎管理的磁盘。`redo log`有4部分，每份1G。写完后从第一部分开始覆盖（write pos指定正在写的位置，check point指定擦除到的位置，redo log只能写在被擦除过的位置。write pos到check point之间的空间是擦除过的空间）

![[../../020 - 附件文件夹/Pasted image 20230402101721.png|400]]

`binlog`由Server层提供，类似将操作语句写进文件，方便恢复数据。

两个日志系统结合使用能保证数据安全



## 事务隔离

-  MyISAM 引擎不支持事务，InnoDB支持事务

事务的隔离性和隔离级别见MySQL的笔记



- 长事务：从事务开启到事务提交过程中包含有很多次sql的事务就叫长事务。这样不好，所以通常需要取消自动提交事务，手动控制事务的开启和提交
- 根据估计，给事务设置最长执行时间，避免语句执行时间过长
- [pt-kill 杀会话的命令行工具](https://www.cnblogs.com/bjx2020/p/9076953.html)比show processlist方便





## 深入浅出索引（上）

索引的数据结构类型有

- 哈希表。缺点：区间查询速度慢
- 有序数组。缺点：插入数据速度慢
- 搜索树：MySQL用B+Tree做索引



使用普通索引查询到节点后，节点的值为主键。再使用主键值去主键索引树中查询数据并命中数据。这叫做回表

如果没有主键索引，InnoDB会自动建立一个Rowin作为主键索引（不知道是什么东西）



## 深入浅出索引（下）

- 覆盖索引：MySQL笔记中有提到

- 适当创建联合索引能减少维护的索引数量

- MySQL5.6后添加了索引下推优化。索引下推：通过使用索引本身的值减少回表次数。根据下图体会索引下推（一条虚线表示执行一次回表）

  ```sql
  select * from tuser where name like '张 %' and age=10 and ismale=1;
  ```

![[../../020 - 附件文件夹/Pasted image 20230402101747.png]]

上图没有使用索引下推，导致需要执行4次回表。但是二级索引中已经包含了age，可以直接过滤掉age!=10的数据，不再对这些数据进行回表查询

![[../../020 - 附件文件夹/Pasted image 20230402101756.png]]

上图用了索引下推。id为3和6的数据行的age!=10，直接过滤掉它们，只对其他数据回表，减少了回表次数


# 全局锁和表锁：给表加字段带来的麻烦

MySQL中的锁大致分为全局锁，表级锁，行锁（先说全局锁和表级锁。行锁下章再说）



全局锁（Flush tables with read lock—FTWRL），锁库。锁上后，DDL，DML和DCL语句均无法执行。让库进入只读状态

全局锁通常用在备份数据时使用

备份库时，有以下几种方案

- 使用FTWRL
- 使用mysqldump时加上--sigle-transaction开启事务获取到一致性视图保证数据一致性，但是不支持事务的存储引擎用不了这个功能
- 修改库的readonly属性。如果客户端设置只读后出现异常断开连接，没有将只读修改回可读可写问题就大了



表级锁有两种：表锁和元数据锁



表锁的语法是 lock tables … read/write

解锁是unlock tbales

会话A锁住t1，t2。那么会话A对t1,t2只读不可写。其他会话完全无法访问t1,t2直到解锁



元数据锁（metadata lock—MDL）MySQL5.5后开始支持，MDL有读写锁。**MDL不需要显式使用**

对表中数据做增删改查时需要获取读锁

对表字段做修改时需要获取写锁

读读可行，读写  写写不可行。和 JUC 的读写锁一样



## 参数配置

- ` query_cache_type`。默认查询会先使用缓存查询，此参数设置为`DEMAND`会关掉缓存查询。在关掉缓存查询时还要使用缓存查询，可以显式指定`SQL_CACHE`，例如`mysql> select SQL_CACHE * from T where ID=10；`
- `innodb_flush_log_at_trx_commit`。这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘
- `sync_binlog`。这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘