> 基于 MySQL 5.5

# MySQL 架构



## MySQL 逻辑架构

<img src="https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/70.jpeg" alt="img" style="zoom: 45%;" /><img src="https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/v2-e22b20b8a3306531796ce0fa3cb31122_b.jpg" alt="img" style="zoom:60%;" />



[MySQL 基础架构分析](https://snailclimb.gitee.io/javaguide/#/docs/database/mysql/how-sql-executed-in-mysql)



## 基于锁的并发控制

MySQL 的锁实现由存储引擎实现，在基于锁的并发控制中



**锁的类型有**：有读锁和写锁

- 读锁（read lock）= 共享锁（shared lock）
- 写锁（write lock）= 排他锁（exclusive lock）
- 写锁请求优先级 > 读锁请求优先级



**锁的范围有**：行锁和表锁

表锁的性能开销小，行锁的性能开销大

所以要平衡管理锁的开销影响数据库存取数据的性能的程度



**死锁**：InnoDB 能检查出多个事务内的死锁，并让持有排他锁最少的事务释放锁并执行回滚



## 事务

事务日志：数据库表中数据修改会先把修改记录以追加方式写到日志文件里，再根据日志里的内容把修改结果写回磁盘

**优点**：顺序写日志的速度比随机写快，且事务日志保证了持久性



- 事务支持：事务由存储引擎实现，在用了不支持事务的存储引擎的表中执行事务指令不会发出提醒，也不会报错
- 隐式锁和显式锁
  - 隐式锁：InnoDB 会根据隔离级别在需要的时候自动加锁
  - 显式锁：`select ... lock in share mode;`共享锁，`select ... for update`排他锁



默认情况下，在执行`commmit`，`rollback`和修改大量数据或表结构时会释放锁



## 多版本并发控制

关于多版本并发控制在 MySQL  中的执行过程，可以参考[这里](https://snailclimb.gitee.io/javaguide/#/docs/database/mysql/innodb-implementation-of-mvcc)

- MVCC：InnoDB 的 MVCC 只在读已提交和可重复读级别下工作
- 文件：每个表在文件系统里都有一个同名文件夹保存相关数据。表结构文件有一个 .frm，这个文件和存储引擎无关。而保存表中数据和索引的物理文件由存储引擎定义和控制



InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 RR，并且通过间隙锁（next-key locking）策略防止幻读的出现

间隙锁使得 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入



# Schema 与数据类型优化

> 本章内容是为接下来的两个章节做铺垫。在这三章中，我们将讨论逻辑设计、物理设计和查询执行，以及它们之间的相互作用。这既需要关注全局，也需要专注细节。还需要理解整个系统以便弄清楚各个部分如何相互影响



## 选择合适的数据类型

- 优先选择占用空间小且保证足以存放数据的数据类型
- 对于需要建立索引的列或需要进行值比较的列，应该设为`NOT NULL`

> 可以为 NULL 的列占用的空间会更多，但也就多 1 bit

MySQL 常用的数据类型有：数值，字符串，日期，位数据，选择标识符，特殊类型

[数据类型参考资料](https://www.runoob.com/mysql/mysql-data-types.html)



- 整数类型：有多种具体类型，其可表示的范围有大有小，可为无符号或有符号，但其性能相同
- 实数类型：可表示带小数的数字或大数字。float，double，decimal（对应 Java 的 BigDecimal）



> 在需要对小数的精确计算时，可用 decimal。在数据量比较大时可考虑用 bigint，然后把数字放大若干倍数使其变为整数再存到 bigint 里。这样可以避免 decimal 精确计算代价高的问题



- 字符串类型：常用的是 char，varchar，enum 枚举类型。其他的 blob 和 text 都不推荐用，因为不推荐用 MySQL 存超长字符串

> enum 都有哪些实例是在定义表结构时规定的，每次修改或新增 enum 的实例时都需要用`alter table`修改表结构

- 日期和时间类型：常用的有 datetime 和 timestamp。如无特殊情况，优先考虑采用 timestamp。两者区别参考[这里](https://www.jb51.net/article/223960.htm)
- 位数据类型：类似 bitset，不推荐用



## 范式和反范式

简单来说，范式希望所有数据只保存一份，反范式会在表中存冗余字段



范式能减少数据占据的磁盘空间，加快数据更新速度

反范式能减少多表关联查询，但执行更新操作时需要更新所有冗余字段所在的表

> 在更新反范式的冗余字段时，可用触发器一并更新掉其他表



三大范式的 demo 可以参考[这里](https://blog.csdn.net/weixin_43569428/article/details/123022871)



## alter table 导致的缩表问题

alter table 的本质是建立一个新表，把旧表的数据插入新表后删除旧表



如果旧表中数据很多就会导致 alter table 执行时间很长，而且会锁住表



为加快 alter table 速度可采取以下方案

- 在备机上 alter table 后替换掉主机
- 在主机上做 “影子拷贝”，通过重命名和删除旧表操作用新表替换旧表



上述方案都对源表结构和数据进行了操作，如果对列改变后，旧数据仍能保存到库里。即 alter table 对数据存储基本没有影响

此时可用`alter column`只修改 .frm 文件，不操作表中数据



# 创建性能好的 InnoDB 的 B+Tree 索引



## 索引基础

索引处理用于快速找到记录外，还能用于数据的排序

![img](https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTk0ODA3NQ==,size_16,color_FFFFFF,t_70.png)

<center>B+Tree</center>

用索引进行的查询中，能用到索引的方式

- 值匹配列前缀：`where_list` 中用到的列能匹配索引中左边的几列，且是查询条件是等值条件
- 匹配范围值：在`where_list` 匹配索引中列时，一旦查询条件用了范围查询，那么匹配索引列时，只能匹配到这个列。索引中这个列后面的列都不能在用上了

因为所引述的节点是有序的，所以除了按等值查询外，索引还能用于查询中的`order by`

`where_list` 中能用到哪些索引的哪些列，判断依据是最左匹配原则。即最左匹配原则用于决定条件语句中哪些列上的索引能在执行查询时生效



> 聚簇索引不是单独的索引类型，而是一种数据存储方式
>
> - 聚集索引：数据和索引值存储在一起。InnoDB 主键的 B+Tree 用的就是聚簇索引，如上图所示
> - 非聚集索引：也叫二级索引，叶节点只有主键值。查询定位到主键值后，在向聚簇索引发起回表查询查询数据行



## 最左匹配原则

最左匹配原则：最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配

多列/组合索引也需要遵守最左匹配规则



关于最左匹配原则的简单表述和 demo 可以参考[这里](https://blog.csdn.net/sinat_41917109/article/details/88944290)



索引的优点

- 减少查询时需要扫描的数据量
- 可以避免`file sort`和创建临时表
- 可以把随机 I/O 变为顺序 I/O



> 数据行在物理文件中的写入顺序是按照主键值升序写入的
>
> ![image-20220618125056245](https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220618125056245.png)
>
> 如果插入了无序的值，会先把旧数据向前/后移动，再把新数据放到空位
>
> ![image-20220618125159219](https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220618125159219.png)



数据的在物理文件中的排序顺序是按照主键排列的，所以顺序 IO 只能是在用到了主键索引，且查询结果是连续的时才能用到顺序 IO

如果用到的不是主键索引，或查询结果不是连续的，是过滤掉了部分数据的，那么数据读还是随机 IO



##  不要把索引列放到表达式或函数里

单值索引所用的列不应该在表达式或函数里，而应该作为独立的列用在`where_list`。否则就会像下面这样导致索引失效

```sql
select * from table1 where id+1=5; -- 索引失效，因为 mysql 不能推断出 id=4
```



## 前缀索引和索引选择性

**前缀索引**：指只对某列的前 n 个字符建立索引，这样就可以在很长的列建立索引

> 但前缀索引不能再用 group by，order by 和索引覆盖扫描，但如果单独为前缀索引创建一个列就令当别说了



```sql
create index idx_col1_7 on table1 (col1(7)); -- 创建长为 7 的 col 的索引
```



**索引选择性**：指一个索引值能找到几条数据行。唯一索引的索引选择性为 1，因为一个索引值只能出现在一条数据行里，索引选择性越接近 1 的列越适合做索引



在创建索引时，表 t1 中有些列是其他表的主键，但在 t1 中这列的值不是唯一的，且不能直接确定其在 t1 中的索引选择性。这是可用 `count(distinct col)`计算其索引选择性



如果想计算前缀索引的索引选择性，为前缀索引选择一个较好的长度时，可用`left`函数

```sql
select count(distinct left(col1, 7)) / count(*) from table1;
```



> 为了防止实际数据的某些值的索引选择性极高或极低，在计算完列的索引选择性后，还需要计算列的每个值出现的频率
>
> ```sql
> select count(*) as cnt, col1 from table1 group by col1 order by cnt desc;
> ```



## 为多列索引选择索引顺序的经验法则

正确的顺序依赖于使用该索引的查询条件，但也需要考虑分组和排序的需要



经验法则

- 把选择性最高的列放到索引最前列（在不考虑排序和分组时）
- [把选择性很低但查询时被频繁用于等值条件的列放到索引的前列](#支持多种过滤条件)
- 把常用于范围条件的列放到索引的后列
- 使用覆盖索引 + 延迟关联（稍后解释 ”延迟关联 “）



> Q：当遇到，表中数据很多，查询条件中的列的选择性都很差时，怎么建立索引
>
> A：索引基本没用了，只能考虑修改应用程序代码（修改功能，或修改表结构，或修改查询 SQL），禁止这种查询（禁止查询的方案并不实际），或用缓存（缓存针对这种聚合数据的查询很有帮助）



## 覆盖索引和延迟关联

**覆盖索引**指 `select_list` + `where_list` = 多列索引的列顺序



用到覆盖索引后，由于索引树里包含了 `select_list` 需要的所有列的值，所以不需要找到查询索引树叶子节点指定的数据页



> 很容易把 Extra 列的 “Using index” 和 type 列的 “index'” 搞混淆。其实这两者完全不同
>
> type 列和覆盖索引毫无关系。它只是表示这个查询访问数据的方式，或者说是 MySQL 查找行的方式。
>
> MySQL手册中称之为连接方式 ( join type )



> type 为 "range" 表示查询选择的执行计划是索引范围扫描，Extra 的值可能是 "Using where; Using index"



聊**延迟关联**前，看看没用延迟关联和用到延迟关联的区别



```sql
-- 没用延迟关联
SELECT * FROM products WHERE actor='sean carrey' AND title LIKE '%apollo%';
```



```sql
-- 用到延迟关联
SELECT * 
FROM products
	JOIN (
        SELECT prod_id
        FROM products
        WHERE actor='sean carrey' AND title LIKE '%apollo%'
    ) AS t1 ON(t1.prod_id=products.prod_id);
```



**覆盖索引 + 延迟关联主要用于解决大数据下的分页查询操作**



##  索引做排序

排序有两种：索引排序，文件排序（file sort）



**只有一列的主键索引**

数据行在物理文件里顺序存放，排序依据为主键值



**有多列的二级索引**

假设索引为 `idx_uid_age`，举个例子，如下图

![image-20220618231327495](https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220618231327495.png)



如果索引不能覆盖 `select_list` 的所有列，那就不得不扫描一条记录就都回表查询一次，这基本都是随机 I/O



只有当索引的列顺序和 `order by` 子句的顺序完全一致，且所有列的排序方向（倒序或正序）都一样时，MySQL 才能用索引对结果进行排序。且根据上图可知，`order by` 也需要遵守最左匹配原则



经验法则

- 如果查询需要关联多张表，则只有当 `order by`子句引用的字段全部都是第一个表时，才能用索引做排序

- 当 `where_list` 用到了对列的**常数等值条件**时，即使 `order by`子句看起来不满足索引的最左前缀要求，也能用于查询排序

  比如有一个索引：`idx_rentalData_inventoryId_customerId`

  ```sql
  -- 能用到索引排序，因为常数的等值查询t
  SELECT rental_id, staff_id FROM table1 WHERE rental_data='2000-01-01' ORDER BY inventory_id, customer_id;
  ```

  ```sql
  -- 但是如果用的是范围查询，就不能用上索引的其他列
  SELECT rental_id, staff_id FROM table1 WHERE rental_data>'2000-01-01' ORDER BY inventory_id, customer_id;
  ```
  
  
  
- 数据默认按主键的升序顺序排序，`order by`也默认是升序排列。如果需要进行快读的降序排列，可以存储该列的反转串或相反数

- `in` 也是范围查询，也会引起索引排序失效







## 索引和锁



InnoDB 只有在访问行的时候才会对其加锁，而索引能减少 InnoDB 访问的行数，从而减少锁的数量。但这只有当 InnoDB 在存储引擎曾能过来掉所有不需要的行时才有效

如果索引无法过来掉无效的行，那么 InnoDB 检索到数据并返回给服务器层后，MySQL 才能用 where 子句，这时已经无法避免锁定行了



```sql
select actor_id  from sakila.actor where actor_id < 5 and actor_id <> 1 for update;
```

```
+------------+
|  actor_id  |
+------------+
|          2 |
|          3 |
|          4 |
+------------+
```

虽然查询结果只有 2，3，4 但实际上锁的范围是 [1, 4]

因为 `EXPLAN` 的 `EXTRA` 表示用到了 `Using where`，这表示 MySQL 将**存储引擎返回行以后再应用 WHERE 过滤条件**



这个例子显示，即使使用了索引，InnoDB 也可能锁住一些不需要的数据。如果不能使用索引查找和锁定行的话问题可能会更糟糕，MySQL 会做全表扫描并锁住所有的行，而不管是不是需要



InnoDB 在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）锁。这消除了使用覆盖索引的可能性



## <a id="支持多种过滤条件">支持多种过滤条件</a>



为索引选择列的顺序时，可以考虑把经常被用于查询条件但列值非常有限的列放在索引左列

比如查询条件经常用到 `sex='m'` 或 `sex='f'`，所以可以建立索引 `idx_sex_aa_bb`



如果查询用不到 sex，可以用 in 条件把所有值都包含进来

```sql
SELECT * FROM table1 sex IN ('m', 'f') AND aa=xx AND bb=xx;
```

这样，即使没有用到 sex 列，也会因为填充上了 in 条件防止索引后面的列失效



又或者对 `age` 建立索引，并放在索引列的左列。因为 age 的值非常有限（1~100），所以可以这样做



**为选择性差的列建立索引后，用 in 解决索引失效的缺点**

如果有 3 个 in 条件，每个 in 中分别有 2，3，4 个值。那么最终会组合出 2\*3\*4=24 种组合

每次匹配数据行时都会进行 24 次对比，导致性能降低



## 范围条件，列表条件和连续 or 的区别

从执行计划的角度来看，范围条件和列表条件的 `tyep`值通常都是 `range`

但是从索引使用效率来看，使用列表条件后**还能用后面的其他索引列**，但范围条件**不能再用到后面的其他索引列**



in 列表条件和 连续的 or 子句是有区别的。起码在 MySQL 里是有区别的，MySQL 将 IN 列表的数据先排序，然后用二分查找确定列表的值是否满足条件，对于 IN 列表有大量取值的时候，IN 列表要比连续 or 子句速度快一些



# 修改 SELECT SQL，优化查询性能

> SQL 优化包括：查询 sql 语句优化、索引优化、库表结构优化



## 导致慢查询的原因

- 扫描行数过多
- 返回的结果集行数过多
- 每行的列的大小过大



> 为了获取 id 为 1~10 的数据，程序员不会故意扫描 id 为 1~100 的再过滤掉 11~100。所以扫描行数过多通常是因为查询语句多表联查的 SQL 结构有问题



注意：扫描的行数不一定等于返回的结果集的行数。举几个例子

- where id=100。扫描了 n 行，返回的结果集只有 1 行
- where id<=10。扫描了 10 行，返回的结果集里有 10 行
- 多表查询时扫描的行数通常比返回的结果集行数多，哪怕扫描行数和返回的结果集的行数比值为 100:1 也正常



## 慢查询基础和 EXPLAIN 重要字段说明



慢查询最基本的问题是访问的数据太多，扫描数据，筛选和分析数据的数据量太大

解决这个问题的关键两步是

- 确认应用程序是否访问了很多重复的数据

- 确认 MySQL 是否分析了大量不要的数据

  举个例子：用 count 统计 id>999 的数据行数量，用 `count(*) - count(id<=999)` 要比 `count(id>999)` 好的多





根据`where`导致的扫描行数和返回的结果集行数的情况，`where`把执行计划的`Extra`分为

从好到坏依次为：

- 直接用索引中的数据匹配 `where_list` 条件，过滤不匹配的记录。这是在存储引擎层完成的
- 用索引覆盖扫描（`Extra: Using index`）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在 MySQL 服务器层完成的，无须再回表查询记录
- 把磁盘中的数据行读到内存里，再拿数据匹配`where_list`，过滤不满足条件的记录（`Extra: Using Where`）。这在MySQL服务器层完成



EXPLAIN 语句的 type 反映了访问类型。访问类型包括：全表扫描 `ALL`，索引扫描 `index`，范围扫描 `range`，唯一索引查询 `unique index`，常数引用 `const`。速度从慢到快，扫描的行数从多到少



所以如果能用索引数据直接过滤掉数据，其访问磁盘数量会减少；如果 sql 语句和索引设置得当 type 也会使得扫描的数据行变少





## 查询的宏观执行过程

如果把查询看作是一个任务，那么它由一系列子任务组成。如果要优化查询，实际上要优化其子任务

- 要么消除其中一些子任务
- 要么减少子任务的执行次数
- 要么让子任务运行得更快



[SELECT SQL 语句在 MySQL 中的执行过程](https://snailclimb.gitee.io/javaguide/#/docs/database/mysql/how-sql-executed-in-mysql)参考这里



## 重构查询的方式

**是否需要把一个复杂查询划分为多个简单查询**

- 一个复杂查询 A 耗时 a，多个简单查询 B，C，D 均可进行独立的缓存，其查询时间 a >= b + c + d
- 利于分库，减少了跨库查询的可能
- 复杂查询的锁竞争比多个简单查询的锁竞争激烈

**是否需要把涉及大范围的修改操作划分为多个小范围的修改操作**

- 防止一条语句执行过程中锁住大量资源
- 防止一条语句执行结束后的 binlog 日志写的任务量过大
- 防止 binlog 日志内容突然激增，导致从机复制效率降低
- 一个复杂查询划分为多个简单查询可能还有利于分库分表，防止跨库 jion
- ...



## 特定查询类型的优化



### 最大最小值优化

如果用或不用  group by，调 `max`，`min` 计算列 A 的最大最小值，且没有为 `where_list` 建立索引，就用 limit 解决



### count 优化

- 如果是粗略统计，可以用 explain 统计。这个命令的效率高
- count 会扫描很多行，MySQL 只能用索引覆盖优化



### limit 优化

- 覆盖索引 + 延迟关联

- 提前计算查询数据的列值范围，用 in 或 between 等范围查询对特定列进行查询

  比如已知数据 id 严格递增，分页查询每次 20 条数据。上次获取的是 id 1010~1030，下次获取 id 1030~1050



### union 查询

`union all` 和 `union` 的区别在于后者会给临时表加上 `distinct` 选项



## 关联查询优化



### MySQL 内部执行查询的优化流程



查询优化器在执行查询前会根据之前的统计信息生成多种查询方案，然后选择一个代价最小的方案

但这是预估的代价，并不代表一定是最优的



MySQL 的优化分为静态优化和动态优化。静态优化就是分析 AST

其优化方式还是比较常规的，优化算数运算，删除冗余条件，折叠、合并过滤条件...

查询优化器会分析 AST，为`where_list`中的字段重新排序，选择合适的索引，如果是关联查询还会尝试选择驱动表和被驱动表



### MySQL 执行关联查询的原理

MySQL 把所有查询都视为关联查询

MySQL 的查询结果都会被放在一张临时表中，临时表中的列定义来自查询语句的 `select_list`，数据来自物理表

- 如果是单表查询，最终会直接返回临时表
- 如果是关联查询，会先执行一张表的查询，将中间结果放在临时表中，然后再进行关联查询，生成最终结果的临时表

因为计算过程都需要中间表，所以 MySQL 把所有查询都视为关联查询



真正的多表关联查询的执行靠的是嵌套循环


多表联查时，MySQL 逻辑上会建立这些表的笛卡尔积

实际上时通过嵌套循环，实现两张表数据的笛卡尔积，在嵌套循环时就用条件语句筛掉不匹配的数据行

```java
 while(outer_lines.hasNext()) {
     outer_line = outer_lines.next();
     while(inner_lines.hasNext()) {
         inner_line = match(condition_list, inner_lines.next());
         if(inner_line != null) merge(outer_line, inner_line);
     }
 }
```



了解其执行过程能更有利于设计更好的索引和 sql 语句



注意：查询形成的临时表中没有任何索引，所以在中间表上的查询是能是遍历方式



### MySQL 的 sql 语句解析和执行过程概述

MySQL Server 收到 sql 语句后，将其解析为 AST。sql 的执行直接根据 AST 执行，而不再生成 lower IR

这个 AST 已经能很好地表示 sql 中各个关键字的层级结构，尤其是多表查询的的层级结构



Q：执行多表查询时，先查询哪些表，生成临时表后再和下一张表进行联表查，生成下一个临时表...

A：MySQL 对 AST 进行先序深搜，进行联表查询

![image-20220425205008334](https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220425205008334.png)



### 小表驱动大表的查询优化

之前说过，关联查询的本质是嵌套循环

下面给一个小表作驱动表，和一个大表作被驱动表的例子

```
// fun1: 小表作驱动表
for(20条)
	for(20万条)
		...
```

```
// fun2: 大表作驱动表
for(20万条)
	for(20条)
		...
```

上述两种方式的时间复杂度**看似**都是 20 * 20W

但每次执行内循环前都需要执行一次连接，fun1 需要建立 20 次连接，fun2 需要执行 20W 次



此外由于中间表不能使用索引，所以

- 当用 fun1 时，会用到 20W 条数据所在表的索引，所以时间复杂度 = 20 * n（如果索引合适，n 将远小于 20W）
- 当用 fun2 时，会用到 20 条数据所在表的索引，所以时间复杂度 = 20 W* n（显然 n ≈ 20）



MySQL 的关联优化器会尽量调整多表查询时的连接顺序，让小表作为驱动表

但这不能保证每次都能选择最优的执行计划，所以还需要人为控制表的关联顺序



## 排序优化

如果没用到索引进行排序，那么不管排序在内存中进行还是在磁盘中进行，其执行计划的 `Extra` 都将其称为 file sort

- 所需排序数据量少时，直接在内存中进行快排
- 所需排序数据量多时，在内存和磁盘中进行外排



还需要注意，limit 会在排序后进行

如果多表查询中仅根据第一张表中字段排序，那么排序会在多表关联前进行。如果直接用到索引最好，否则就是 filesort

如果多表查询中还用到第一张表外的其他表中字段排序，那么排序会在关联完成后进行。执行计划的 `Extra`  将会是 `Using temporary; Using filesort`





# 服务器配置



MySQL 有大量可以修改的参数，但通常只需要把基本的配置正确即可。应该把更多的时间放在表设计，SQL 查询语句设计和索引设计上



数据库运行初期，表设计、SQL 查询语句优化和索引设计的优化带来的收益要比修改配置带来的收益高。配置项的修改应该在项目运行一段时间后，根据项目需求再修改配置项



## 配置项的工作原理



MySQL 运行时的配置项会被加载到变量里，MySQL 读取变量获取配置项的值



MySQL 的配置项可以在多个地方进行定义和修改，优先级高的配置方式会覆盖掉优先级低的配置方式配置的值



1. MySQL 系统内置的默认值
2. MySQL 配置文件配置
3. MySQL 运行时，用命令行命令配置参数

命令行对参数的修改效果仅限于 MySQL server 的运行时，即用命令行配置的参数不会被持久化。server 重启后，会丢失命令行配置的参数



> MySQL 的配置文件采用分段格式，格式如下
>
> ```
> [分段1]
> xx.xx.xx=xx
> xx.xx.xx=xx
> [分段2]
> xx.xx=xxx
> ```



- 配置项的作用域有两种：全局作用域，会话作用域（仅对当前会话有效）
- 尽量不要用命令行修改和内存分配有关的变量，因为这可能会导致 DB 做大量的工作



系统运行时，可用

-  `show variables like 'xxx'` 查询系统变量
- `set global key=value` 或 `set @@key=value` 修改系统全局变量



## 配置入门建议



- 不要死板的根据网上推荐的百分比去设置某些参数的值，还是应该具体问题具体分析
- MySQL 的很多默认配置已经很靠谱了，默认配置被设计为不要使用大量的资源，且默认配置没有假设 MySQL 时服务器上唯一的应用
- 日志文件，数据库文件等文件输出地址应该由用户配置



## 内存分配配置

MySQL 的内存消耗分为：可控制的内存和不可控制的内存

MySQL 运行，解析查询和内存管理所消耗的内存，但能控制实现为某些目的时执行的行为所使用的内存



比如：MySQL 能用的内存上限，每个连接能用的内存上限



MySQL 保持一条连接（一条连接对应一个线程）只需要少量的内存，但如果连接收到大量的查询，需要返回大量的数据集，需要对大数据集结果进行内存排序，收到大量的建立连接的请求等就需要大量的内存。所以需要为应对高峰期预留好足够的内存



除上述地方外，缓存（不是查询缓存）也是占用大量内存的地方：InnoDB 缓冲池，日志文件，MyISAM 键缓存



缓存的大小需要谨慎配置，大容量缓存能提高执行速度，但这也意味着需要占用大量缓存，开机时需要花更多的时间加载数据到内存李，关机时需要进行大量脏数据写回工作



## IO 行为配置

这里主要涉及的配置是：有些数据会先被写入内存，再被写入磁盘。MySQL 在何时才会执行  IO 写行为保证数据一致性



比如，事务日志文件，二进制日志文件等都会先被写入内存，在内存快慢，到达规定时间或应用行为执行完毕后再被写入磁盘



## 并发配置

并发有无锁和锁方式应对

MySQL 采用 MVCC 实现乐观锁，采用锁、并发限制实现限流和保证数据一致性



限制并发方式通常有：限制并发线程数，事务的并发提交数量限制并发。MySQL 曾采用类似令牌桶算法的方式实现限流



# 复制

MySQL 内置的复制功能用于搭建主从架构，实现读写分离。是所谓的 “水平扩展”



## 复制的原理

执行流程：从机监听主机的**二进制日志**变化，主机执行写行为后，向从机发送复制语句，从机的 IO 线程把收到的数据记录在中继日志里，等待 SQL 线程读取并执行

<img src="https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220612115020046.png" alt="image-20220612115020046" style="zoom:80%;" />

MySQL 支持两种复制方式：基于行的复制和基于语句的复制（逻辑复制）



复制解决的问题：提高并发读效率，实现了备份，实现了故障切换



## 实现复制的方式

假设主机和从机都是全新安装的，且版本兼容，有相同的数据



1. 在主机和从机创建复制账号，从机运行 IO 线程时会建立一个到主机的 TCP/IP 连接，主库将用这个复制账号读写二进制日志

   ```sql
   GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO repl@'192.168.0.%' IDENTIFIED BY 'password';
   ```

2. 修改主机，从机的配置。指定 server_id 和二进制日志

   ```properties
   [mysqld]  # 主机配置
   # 二进制文件名可任意配置
   log_bin     = mysql-bin 
   # 必须配置，且不能和本机的其他 MySQL SERVER ID 重复
   server_id   = 10
   # 提交事务前，把二进制日志同步到磁盘
   sync_binlog = 1
   ```

   ```sql
   # 重启 MySQL 后查询配置是否生效
   mysql> show master status;
   ```

   ```properties
   [mysqld]		  # 从机配置
   # 二进制文件名可任意配置，可和主机配置的名字不同
   log_bin           = mysql-bin 
   # 必须配置
   server_id         = 2 
   # 必须配置
   relay_log         = /var/lib/musql/mysql-relay-bin 
   # 1 表示允许从机把中继日志记录到自己的二进制日志里 
   log_slave_updates = 1 
   # 1 表示从机是只读的，不接收客户端的写请求
   read_only         = 1 
   ```

3. 启动复制。告诉从机如何连接到主机并开始复制日志

   ```sql
   -- MASTER_LOG_FILE MASTER_LOG_POS 表示要复制主机的那个二进制文件，以及开始复制的位置
   mysql> CHANGE MASTER TO MASTER_HOST='ip_or_hostname', MASTER_PORT=port, MASTER_USER='slave', MASTER_PASSWORD='slave', MASTER_LOG_FILE='mysql-bin.000003', MASTER_LOG_POS=0;
   ```

   ```sql
   mysql> show slave status;
   ```

4. 在主机和从机上的线程列表上看复制线程

   ```sql
   -- 在主机和从机上分别执行。在主机上能看见 IO 线程，在从机上能看见 IO 线程和 SQL 线程
   mysq> show processlist;
   ```

   

## 新从机同步旧主机

通常进行复制时，主机上已经有很多数据，从机上可能没有数据也可能有一些和主机无关的数据



通常的做法是：清空从机数据后进行全量备份，或把主机上的数据从其他服务器上克隆到从机上后再向主机进行复制



## 复制拓扑

搭建主从结构只有一个限制：每个从机只能有一个主机。基于这个简单的限制能发展出多种主从结构

可用的主从结构有：一主多从，主动 - 被动的主主结构，分发主库，树形结构

![image-20220612134955543](https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220612134955543.png)

<center>一主多从</center>

![image-20220612135017724](https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220612135017724.png)

<center>主动 - 被动模式的主 - 主结构</center>

这种结构相当于热备份

<img src="https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220612135334849.png" alt="image-20220612135334849" style="zoom:80%;" />

<center>分发主库结构</center>

如果主机有多个从机，那么主机不仅需要为维护来自从机的多个连接，还需要把每条新数据的插入和更新行为都分发到所有从机，这增加了主机的压力



分发主库结构下，主机不和从机直接相连，主机仅和分发主库相连，这样主机仅需要维护一条连接，且新数据的插入和更新指令也只需要发给一个机器即可

分发数据的任务交给了分发主库，分发主库的职责仅限于分发指令，减少主机分发指令的压力，所以分发主库本身仅持有数据库表结构，不保存任何数据。所以分发主库可以用 blackhole 存储引擎

<img src="https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220612162657682.png" alt="image-20220612162657682" style="zoom:80%;" />

<center>树形结构</center>



# 可扩展的 MySQL



“复制” 只能提升读性能，不能做到读写的线性扩展



- 水平扩展：复制，拆分（分表），数据分片（分库）
- 垂直扩展：换更好的硬件



有两种数据分片方式：静态分片，动态分片



首先选定哪列是分区键，然后对分区键进行计算，得到数据应该别写入哪个分片



对数据分片能实现向多个分片并发写数据。为了查询数据时能提前知道数据可能会在哪个分片里，需要能根据查询条件计算出数据所在分区，方式跨分片查询



分区键可以由若干个列组成，以此应对复杂的应用场景



- 查询某篇文章下的所有评论
- 查询某个用户发布的所有评论



不能仅用评论数据中的 article_id 或 u_id，应该综合考虑



##  分片部署方式

- 每个数据库有一个分片
- 每个数据库有多个分片



分片命名方式：分片号添加在数据库名后或表名后，或混合使用



## 分片策略

分片策略分为：静态分片，动态分片，混合分配



- 静态分片：curd 时，根据分区键计算数据行应该在哪个分片中

常用的静态分片方式有：取模，hash

这种方式实现简单，但不利于分片扩容



- 动态分片：curd 时，根据动态策略，统计运行时数据决定数据存放的分片，并用分片表保存数据的 id 和 所在的分片号 share_id

比如：

插入数据时，根据运行时数据决定把数据 A 放到分片 3 中，并向分片表保存 A_id -> share_3 的映射关系



查询数据 A 时，先用 A_id 向分片表查询 A 所在分片，得到的查询结果是 share_3，然后再向分片 3 发起真正的查询请求



- 混合分配：静态 + 动态分片



## 分片数据迁移

在扩容分片，增加分片数量，或整理数据，进行活跃数据和非活跃数据的分离时会需要迁移分片中的数据

数据 A 从分片 3 迁移到分片 1 时，数据会被要求其内容不能被修改。所以采用静态分片策略，用分区键计算出的分片号在数据迁移前后都不会被改变，这不利于分片数据迁移



采用动态分片策略就会很 nice，不仅运行数据被迁移后仍能通过分片表得知数据所属的新分片号，还能通过标记位手段暂时锁住某些分片，令其在进行数据迁移时不再接收程序的数据修改语句请求



## 全局唯一 ID

推荐用分布式 ID 算法搭建一个分布式 ID 生成器。比如：雪花算法，叶子算法...



## 应用层的分片实现方式

分片行为常用中间件实现，中间件提供分片服务的方式有两种

- 分片中间件伪装成 MySQL，独立运行。应用服务器直接连接中间件，由中间件接收应用程序的普通 curd 请求，分片行为由分片中间件执行
- 分片中间件直接作为客户端整合在应用服务器中，采用装饰器模式或代理模式等手段，在发送 curd 前进行分片行为，修改 sql 或目标 MySQL 服务器

