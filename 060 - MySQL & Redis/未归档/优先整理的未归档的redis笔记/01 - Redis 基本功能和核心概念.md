#还没有复习 

## Redis 简介

- 用途：Redis 可用作主存储和二级存储（缓存，或计算和保存系统运行时数据）
- 存储单元：提供存储键（key）和 5 种不同类型的值（value）之间的映射（mapping）
- 复制：主从复制，读写分离，扩展读性能
- 客户端分片：扩展写性能，可获得线性级别的性能提升（分片策略如： ID 分段，散列值，组合 key）
- 支持聚合函数：比如 incr


## Redis 五大数据结构

五大数据结构包括：`String`, `List`, `Hash`, `Set`, `ZSet`（有序集合）


五大数据结构有些通用的命令，比如：`del`, `type`, `rename`


- **对 value 为空的 key 进行操作**：对一个不存在的 key 自增或覆盖其值时会自动创建 key 并令其零值为默认值，再执行覆盖或自增
- **key 的 value 为空时**：如果一个 key 没有 value，这个 key 会被自动删除。比如 list 里的元素都被取出，list 这个 key 就会被自动删除
- **尝试获取一个 value 为空的 key**：如果获取（包括但不仅限于 GET，LPOP）一个不存在的 key 会返回 null（如果 key 是 String）或空（什么都没有，但不是 null）
- **区间查询时的区间定义**：范围查询多为闭区间，且 0 是第一个元素的下标，-1 是最后一个元素的下标
- **不支持嵌套结构**：比如 hash 中有多个 kv，v 只能是 String，不能是 String 以外的数据类型
- **通用指令格式**：`instruct [opts] keys [values]`


如果有需要，比如需要保存复杂的对象，可以用 hash 或 json 字符串保存具有层级结构的对象


### 字符串 - String

> 值可以是字符串，整数，浮点数。实际类型由 redis 自行判断

![image-20220512155702675](https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220512155702675.png)


**基础命令**

| 命令 | 描述                                               | 返回值说明              |
| ---- | -------------------------------------------------- | ----------------------- |
| GET  | 获取存储在给定键中的值                             | 如果查不到返回 null     |
| SET  | 设置存储在给定键中的值                             | 返回 OK                 |
| DEL  | 删除存储在给定键中的值（这个命令可以用于所有类型） | 返回被删除的 key 的数量 |

**进阶命令 - 数字自增和自减命令**

| 命令        | 描述                       | 返回值说明       |
| ----------- | -------------------------- | ---------------- |
| INCR        | 将键存储的值加上 1         | 返回自增以后的值 |
| DECR        | 将键存储的值减去1          | 返回自减以后的值 |
| INCRBY      | 将键存储的值加上整数 arg   | 返回自增以后的值 |
| DECRBY      | 将键存储的值减去整数 arg   | 返回自减以后的值 |
| INCRBYFLOAT | 将键存储的值加上浮点数 arg | 返回自增以后的值 |

上述的 amount 可以是负数和 0

**进阶命令 - 处理字符串子串和二进制位命令**

| 命令     | 描述                                                         | 返回值说明                                                   |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| APPEND   | 将值 val 追加到给定键 key 当前存储的值的末尾                 | 返回追加的字符串后 val 的长度                                |
| GETRANGE | 获取由偏移量 start 至偏移量 end 范围内所有字符组成的子串，闭区间 | 如果没有这个 key 就返回空，而不是 null                       |
| SETRANGE | 将从offset 开始的子串覆盖设置为 val                          | 返回长度。如果超出已有范围，补空 0（二进制格式）或自动扩容   |
| GETBIT   | 返回位串中偏移量为 offset 的二进制位的值                     | 如果越界或 key 不存在就返回 0                                |
| SETBIT   | 将位串中偏移量为 offset 的二进制位的值设置为 val             | 返回如果越界或 key 不存在就自动补 0                          |
| BITCOUNT | 统计 [start, end] 内二进制位串里面值为 1 的位数量            |                                                              |
| BITOP    | BITOP operation dest-key key-name [key-name..]               | 对若干个二进制串进行 and, or, xor 并把结果保存在 dest-key 里 |



### 列表 - List

> 链表表上每个节点都包含一个 String 作为 value

![image-20220512160112567](https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220512160112567.png)

**基础命令**

| 命令          | 描述                                          | 返回值说明                             |
| ------------- | --------------------------------------------- | -------------------------------------- |
| RPUSH / LPUSH | 将给定值推入列表的右 / 左端                   | 返回列表当前长度                       |
| RPOP / LPOP   | 从列表的右 / 左端弹出一个值，并返回被弹出的值 | 如果 key 没有元素，返回 null           |
| LRANGE        | 获取列表在给定范围上的所有值                  | 返回所有值                             |
| LINDEX        | 获取列表在给定位置上的单个元素                | 如果 key 没有元素返回为空，而不是 null |
| LTRIM         | 只保留 [start, end] 范围内的元素              | 返回 OK                                |

**进阶命令 - 阻塞式弹出和在列表间移动元素命令**

| 命令          | 描述                                                         | 返回值说明   |
| ------------- | ------------------------------------------------------------ | ------------ |
| BLPOP / BRPOP | 从非空列表中弹最左 / 右端的元素，或在 timeout 秒之内阻塞并等待可弹出的元素出现 | 返回这个元素 |
| RPOPLPUSH     | 从 source-key 中弹出最右端的元素，然后将这个元素推入 dest-key 的最左端 | 返回这个元素 |
| BRPOPLPUSH    | 在 RPOPLPUSH 的基础上，在 timeout 秒之内阻塞并等待可弹出的元素出现 |              |

### 集合 - Set

> 集合支持交集，并集，差集计算

![image-20220512161420082 1](https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220512161420082%201.png)


**基础命令**

| 命令        | 描述                                                         | 返回值说明                                                   |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| SADD        | 将给定元素添加到集合                                         | 返回成功添加的元素个数                                       |
| SREM        | 如果给定的元素存在于集合中，那么移除这个元素                 | 1 表示元素之前在集合里，现已删除。0 表示元素不在集合里       |
| SMEMBERS    | 返回集合包含的所有元素                                       | 如果 key 没有元素返回为空，而不是 null                       |
| SISMEMBER   | 检查给定元素是否存在于集合中                                 | 1 表示在。0 表示不在                                         |
| SCARD       | 返回集合包含的元素的数量                                     | key 为空时返回 0                                             |
| SRANDMEMBER | 从集合里面随机地返回 count 个元素                            | count 为正数时，返回的元素不会重复。cout 为负数时，返回的元素可能重复 |
| SPOP        | 随机地移除集合中的一个元素                                   | 返回被移除的元素                                             |
| SMOVE       | 如果 source-key 包含元素 item，从 source-key 里移除元素 item 并添加到集合 dest-key 中 | 被成功移除，那么命令返回 1，否则返回 0                       |

**进阶命令 - 集合运算**

| 命令        | 描述                                               | 返回值说明                                       |
| ----------- | -------------------------------------------------- | ------------------------------------------------ |
| SDIFF       | 差集运算                                           | 返回存在于第一个集合、但不存在于其他集合中的元素 |
| SDIFFSTORE  | 在 SDIFF 的基础上，可以指定把差集结果存到 dest-key | 返回差集中的元素个数                             |
| SINTER      | 交集运算                                           | 返回同时存在于所有集合中的元素                   |
| SINTERSTORE | 在 SINTERSTORE 的基础上，可以指定 dest-key         | 返回交集中的元素个数                             |
| SUNION      | 并集运算                                           | 返回至少存在于一个集合中的元素                   |
| SUNIONSTORE | 在 SUNION 的基础上，可以指定 dest-key              | 返回并集中的元素个数                             |

### 散列 - Hash

![image-20220512162212002](https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220512162212002.png)


**基础命令**

| 命令    | 描述                                     | 返回值说明                                                 |
| ------- | ---------------------------------------- | ---------------------------------------------------------- |
| HSET    | 在散列里面关联起给定的键值对             | 返回新增的 field 的个数（而不是被保存起来的 value 的个数） |
| HGET    | 获取指定散列键的值                       | 返回 null 或 value                                         |
| HGETALL | 获取散列包含的所有键值对                 | 如果 key 没有元素返回为空，而不是 null                     |
| HDEL    | 如果给定键存在于散列里面，那么移除这个键 | 返回被删除的 field 的个数                                  |
| HLEN    |                                          | 返回 key 中的键值对数量                                    |

**进阶命令**

| 命令         | 描述                            | 返回值说明                         |
| ------------ | ------------------------------- | ---------------------------------- |
| HEXISTS      | 检查键是否存在于散列中          | 存在返回 1，不存在返回 0           |
| HKEYS        |                                 | 返回散列包含的所有 field，不返回值 |
| HVALS        |                                 | 返回散列包含的所有值，不返回 field |
| HINCRBY      | 将键 key 存储的值加上整数 val   | 返回加上 inc 后的值                |
| HINCRBYFLOAT | 将键 key 存储的值加上浮点数 val | 返回加上 inc 后的值                |

### 有序集合 - ZSet

![image-20220512163241778](https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220512163241778.png)

**基础命令**

| 命令          | 描述                                                         | 返回值说明                             |
| ------------- | ------------------------------------------------------------ | -------------------------------------- |
| ZADD          | 将一个带有给定分值的成员添加到有序集合里面                   | 返回新增 value 的数量                  |
| ZREM          | 如果给定成员存在于有序集合，那么移除这个成员                 | 返回被删除的 value 的数量              |
| ZCARD         |                                                              | 返回有序集合包含的成员数量             |
| ZRANGE        | 根据元素在有序排列中所处的位置下标，从有序集合里面获取多个元素<br>如果给定了可选的 WITHSCORES 选项，那么命令会将成员的分值也一并返回 | 如果 key 没有元素返回为空，而不是 null |
| ZRANGEBYSCORE | 获取有序集合在给定分值范围内的所有元素                       | 如果 key 没有元素返回为空，而不是 null |
| ZINCRBY       | 将 member 成员的分值加上 val                                 |                                        |
| ZCOUNT        |                                                              | 返回分值介于min和max之间的成员数量     |
| ZRANK         |                                                              | 返回成员 member 在有序集合中的排名     |
| ZSCORE        |                                                              | 返回成员 member 的分值                 |

 **进阶命令 - 范围获取和范围删除命令，集合运算命令**

| 命令             | 描述                                   | 返回值说明                                                   |
| ---------------- | -------------------------------------- | ------------------------------------------------------------ |
| ZREVRANK         |                                        | 返回 member 的分值排名，成员按照分值从大到小排列             |
| ZREVRANGE        |                                        | 返回给定排名范围内的成员，成员按照分值从大到小排列           |
| ZRANGEBYSCORE    |                                        | 返回分值介于 min 和 max 之间的所有成员                       |
| ZREVRANGEBYSCORE |                                        | 返回分值介于 min 和 max 之间的所有成员，成员按照分值从大到小排列 |
| ZREMRANGEBYRANK  | 移除排名在 [start, end] 的所有成员     |                                                              |
| ZREMRANGEBYSCORE | 移除分值介于 min 和 max 之间的所有成员 |                                                              |
| ZINTERSTORE      | 交集运算                               | 返回交集中的元素个数                                         |
| ZUNIONSTORE      | 并集运算                               |                                                              |

- ZREV* 命令中，元素都是基于从大到小排列后再进行计算的
- 有序集合的集合计算命令中有两个可选参数
  - AGGREGATE SUM | MIN | MAX。表示计算时遇到多个相同元素时，进入集合的元素的分值取值。可选项均是聚合函数
  - WEIGHTS weight [weight..]。当命令中有集合（普通集合 set）时，可用 weight 指定每个集合中所有元素的分值。如果不指定，默认集合中的所有元素的分值均为 1



## 排序

sort 命令可以对所有 keys 排序，命令需要指定参与排序的 key，比较大小用的 val，排序用什么字典序，升序还是降序



```bash
SORT source-key [By pattern] [LIMIT offset count] [Get pattern [Get pattern ...]] [ASC|DESC] [ALPHA] [STORE dest-key]
```



具体使用方式参考[这里](https://redis.io/commands/sort/)



## 事务

事务相关的指令

- `MULTI` 开始事务
- `WATCH` 监听  key（key 可以不存在）
- `UNWATCH` 取消监听 key
- `DISCARD` 放弃事务
- `EXEC` 执行事务


介绍：Redis 的事务并不支持 ACID，因为它不保证原子性。事务内的多个命令各自执行各自的，一条命令的失败或出现的异常也会继续执行下一条命令


- `MULTI` 的工作原理：当 Redis 从一个客户端那里接收到 `MULTI` 时，Redis 会将这个客户端之后发送的所有命令都放入到一个队列里面，直到这个客户端发送 `EXEC` 命令后 Redis 就会在不被打断的情况下，一个接一个地执行存储在队列里面的命令


**WATCH**

- `WATCH` 的生命周期：`WATCH` 命令只能用在发送 `MULTI` 命令前，在调用 `EXEC` 指令执行结束后失效（即取消监控所有的 key）
- 工作原理：先监听 key，再开启事务。如果当前会话监听的 key 被其他会话修改了，那么执行事务时就会放弃执行事务队列里的所有命令，结束所有监听，并返回 `nil`


watch 就是 redis 实现的乐观锁实现。如果事务执行失败就尝试重试，直到能被执行


> 因为事务中的指令会被 redis 服务端的单线程一次性地连续，所以不用担心在事务执行时 redis server 又插入执行了一条其他会话要求修改被监听 key 值的命令。即事务要么能被执行（虽然有些命令可能会出现异常），要么一条都不执行（因为监听的 key 的值被其他会话修改了）



## 简单的性能测试和性能提升



**批量传送指令**

用 redis 客户端批量发送命令，而不是需要执行一条就发送一条。这样能减少网络传输次数

很多 redis 客户端都为事务提供伪批量执行。在客户端调用 `exce` 后才把队列中的指令一次性发给 redis。这些客户端通常也会为非事务指令提供批量发送的 api



**简单的性能测试**

`redis-benchmark`命令的运行结果会展示一些常用的命令在 1s 内可以执行的次数



**使用多个 “数据库”**

一个 redis server 默认有 16 个数据库。把数据分摊到 16 个数据库里也能有效提高执行效率



## 键的过期时间和键的清理工作

键的过期时间的设置命令如下

| 命令      | 描述                                                 |
| --------- | ---------------------------------------------------- |
| EXPIRE    | 让给定键在指定的秒数之后过期                         |
| PERSIST   | 移除键的过期时间                                     |
| TTL       | 查看给定键距离过期还有多少秒                         |
| EXPIREAT  | 将给定键的过期时间设置为给定的 UNX 时间戳            |
| PTTL      | 查看给定键距离过期时间还有多少毫秒                   |
| PEXPIRE   | 让给定键在指定的毫秒数之后过期                       |
| PEXPIREAT | 将一个毫秒级精度的 UNIX 时间戳设置为给定键的过期时间 |

键过期后会被自动删除

但 `expire` 的缺点是，它只能作用于一整个 key，而不能作用于一个 key 中的部分数据。比如 `expire` 不能作用于一个 hash 的某些 field，只能作用于整个 hash key



redis 被动删除键的方式有 3 种

- 溢出删除：内存不够放进新键时，redis 会用键的淘汰策略，删除一部分 key 为新 key 腾空间
- 过期删除：键过期后进行即时删除或懒删除
- 手动删除：用户自行编写清理线程，手动清理



## 数据安全和性能保障



### 数据持久化

两种持久化方案：rdb 快照，aop 只读追加文件



持久化的目的：重用数据，数据备份，数据迁移和容灾恢复。保存那些程序长时间，并计算过大量数据后才统计出来的结果



#### RDB 快照

如果不知道快照是什么，可以看看这篇文章 [快照是什么？揭秘存储快照的实现](https://cloud.tencent.com/developer/article/1158686)



redis 通过 `SAVE` 和 `BGSAVE` 命令创建快照

- `SAVE`。执行此命令时，在创建快照完毕之前不在响应任何其他命令。不常用，通常在内存不够或能容忍持久化期间不执行其他指令时才会用
- `BGSAE`。执行此命令时，调用 fork 创建子进程，子进程负责把快照写入磁盘，父进程继续工作。fork 会创建进程的副本，副本和父进程共享内存，所以`BGSAVE`费内存，但不影响 redis 继续响应其他指令。但`BGSAVE`在创建子进程的过程中也会引起系统的卡顿

> 如果数据量过大，`BGSAVE`创建子进程 + 创建快照将会比较耗时，创建子进程也会引起系统卡顿，所以可以考虑关掉自动保存，用手动保存方式控制卡顿时机发生在 redis 压力不大的时候

执行创建快照命令的时机

- 客户端主动发送 `SAVE` 或 `BGSAE` 指令
- 调用 `SHUTDOWN` 命令关机或收到 OS 的标准 `TERM` 信号时调用 `SAVE` 创建快照
- 满足配置文件中的 save 选项时调用 `BGSAE` 命令创建快照（save 选项的推荐配置为默认配置）
- 从机请求复制主机数据时调用 `BGSAE`（从机向主机发送 `SYNC` 命令）



rdb 快照会把快照数据都放在 .rdb 文件里

如果宕机，用户将丢失最近一次生成快照后更改的数据



#### AOF 只读追加文件

追加可以发生在每次执行命令后，每秒追加一次或交给系统决定何时执行追加



- `appendonly yes` 表示开启 aof 功能
- `appendsync` 选项指定文件同步时机

![](https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220512155702675.png)
推荐每秒同步一次，其对性能几乎没有影响



为防止 .aof 文件膨胀，redis 会在合适的时机执行 `BGREWRITEAOF` 命令，对文件进行压缩

- 配置`auto-aof-rewrite-min-size`指定 .aof 文件大小必须超过阈值后才能考虑执行重写
- 配置`auto-aof-rewrite-percentage`指定 .aof 文件大小比上次重写后体积大多少比例时就执行重写

```
auto-aof-rewrite-min-size 64m // aof 文件超过 64M 后考虑重写
auto-aof-rewrite-percentage 100 // aof 文件比上次重写后的大小大一倍时重写，推荐值设置为 100 以上
```



文件压缩方式主要包括：合并冗余命令，去掉冗余命令



`BGREWRITEAOF` 命令的工作原理和 `BGSAVE` 类似，需要 fork 创建子进程，所以也存在性能问题和内存占用问题



#### 两种方式的优缺点

保存相同的数据量时。rdb 文件小，执行恢复时间短。aof 文件大，执行恢复时间长



### 复制

复制用于主从复制，读写分离。提高 redis 集群的读性能



尤其是进行费时的命令时，redis 采用单线程模型执行指令，耗时指令将阻塞其他还未被执行的指令

搭建主从架构后，整个集群的读行为相当于无锁的多线程读



复制的整体流程为：从机发送`SYNC`命令请求主机的快照文件，**从机自动清空自身数据**，并根据快照文件全量复制。复制完毕后，开始持续接收并执行主机发送的逻辑指令以实现复制目的



开启 redis 的主从复制不需要太多的配置，复制相关的配置在于 redis 服务器是如何变成主机和从机的

只需要`SLAVEOF `一个指令

- `SLAVEOF NO ONE`命令用于终止复制
- `SLAVEOF host port`命令让服务器作为从机，开始向目标主机复制

`SALVEOF`可以直接在客户端执行，也可以在配置文件里配置

> 较新版本的 redis 用的命令是`REPLICAOF`，`SLAVEOF`是旧版本 redis 用的命令，但两个命令的参数都一样（貌似是因为 slave 带有歧视含义，所以被弃用了）

<center>从机连接主机时的详细复制步骤</center>

<img src="https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220513215332821.png" alt="image-20220513215332821" style="zoom:67%;" />



和多数能搭建主从复制的数据库一样，redis 也**不支持主主复制**；如果从机过多，为减少主机分发增量复制用的逻辑指令，可以**搭建中间层**，即主机下有少量的一级从机，一级从机有各自的二级从机

<img src="https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220513221130629.png" alt="image-20220513221130629" style="zoom:80%;" />

生产环境下不一定非要这么做，但这种树形结构是可行，合理的



### 应用层检查数据落盘情况

aof 和 rdb 实现了数据持久化，新增数据会在合适时机被写入磁盘

如果程序要求必须立刻验证数据是否被写入磁盘，而不仅限于数据是否已经在 redis 的内存中，需要应用层实现

调用`INFO`命令查看`aof_pending_bio_fsync`属性是否为 0，如果是，表示所有已知的数据都保存到了磁盘里



> `INFO`命令提供了大量和 redis 服务器当前状态相关的信息，这对于了解 redis 服务器的综合状态很有帮助



### 故障处理

用 aof 和 rdb 持久化数据，文件可用于数据恢复。搭建主从架构时，从机的持久化文件也起到备份作用



redis 遇到数据损坏，需要恢复数据时，需验证 rdb 和 aof 文件的完整性。更换出现故障的主机或重启从机



- `redis-check-aof`和`redis-check-rdb`用于检查和修复 aof 文件和 rdb 文件
  - 修复 aof 文件时，直接删除第一个不完整或错误的命令及其后面的所有命令（简单粗暴）
  - rdb 文件不能被修复，因为快照文件本省经过压缩，所以不能对压缩后的文件进行修复。文件的完整性校验通过校验和和散列值完成
- 主机出现故障时
  - 让一台新的 redis 主机用从机的快照文件恢复数据，再让从机开始复制这台主机
  - 或让数据完整性最好的从机作为主机，再让新的 redis 机器作为从机跟上主机（哨兵模式下能实现自动的故障转移）

