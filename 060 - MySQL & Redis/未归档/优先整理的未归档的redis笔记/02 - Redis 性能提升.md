#还没有复习 

通过使用短结构，位图保存数据减少占用的内存

通过使用单机分片，多机分片提高写性能；读写分离提高查效率



降低内存占用会带来很多好处：减少`.rdb`，`.aop`的写入时间，缩短主从同步时间，腾出更多的空间保存其他数据



## 短结构 - 压缩列表，整数集合和位图

短结构：存储长度较短的结构



在 list、hash、zset 的长度较短或体积较小时，使用压缩列表（ziplist）的紧凑型结构保存数据

当上述类型的 key 的长度或体积较大时就会使用经典的数据结构保存数据

- list 用双向链表
- hash 用散列表
- zset 用散列表和跳表

> redis3.2 添加了新的短结构：quicklist



### 压缩列表



压缩列表：内存连续，由多个表项组成，每个表项 = cur_len + value  + pre_len 

cur_len 表示本节点的 value 长度，用于从前到后的遍历

pre_len 表示上一个节点的长度，用于从后向前遍历

这种方式保存数据能节省空间。当 key 的长度或体积较小时会用紧凑结构，这个阈值可以在配置文件里配

<img src="https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/image-20220527201237884.png" alt="image-20220527201237884" style="zoom: 80%;" />

上述选项表示 key 中存多少个 entity 且 entity 的大小不超过多少（单位是字节）时就用紧凑结构

如果不符合任意一项就会转紧凑型结构为经典结构，且转换不可逆



> 可以用`DEBUG OBJECT KEY`命令查看 key 对象的相关信息，这些会包含 key 的底层数据结构



### 整数集合

set 的紧凑型结构。当 set 的成员都能用十进制整数表示时，且整数处于本软硬件平台的有符号范围之内，set 的成员数量又比较少时就用整数集合



set 使用整数集合结构的阈值选项如下

```
set-max-intset-entities 512
```



当整数数量少时，set 的底层数据结构是`intset`，当数量变多后就用`hashtable`



### 紧凑型结构的缺点

当紧凑结构的体积变的太大后，操作这些结构的速度会变的越来越慢。以上两种紧凑结构的缺点都集中在

- 紧凑结构的内存分布是连续的，添加或删除数据后存在数据移动问题
- 紧凑结构没有索引，只能顺序遍历查询 key



### 单机分片

先单机分片的目的是

- 让一个 “大 key” 的多个 “分片 key” 都保存较少的数据，这样就能用到短结构，减少内存占用
- 提高查询速度和写入速度



注意事项：

- hash，set，zset 的单机分片好实现，list 的单机分片需要依靠 lua 脚本
- 实际场景下，用 zset 通常都会用到 score。如果用 hash 策略进行分片，那么分片的意义就不大，因为 hash 分片会把所有的 score 分散到各个分片里，hash 分片后所有依赖 score 的命令需要遍历所有的分片
- 单机的分片行为需要在代码上自行实现，跨机分片可以用中间件自动实现
- 如果要对键 X 进行单机分片，需要让操作 X 的所有指令都支持单机分片行为
- 分片策略有很多种（段号，哈希）


> 对键 X 的分片的命名常用：`X:<shardid>` 或 `Y:<shardid>`
> 或直接用 redis 提供的 16 个 db 实现分片（存在切换库的开销？）



hash 分片策略的缺点：hash 不一致性会导致如果分片的数量发生变化后需要进行数据迁移


> [!NOTE] 分片的局限性
> - 不管是单机分片还是跨机分片，一旦数据量达到一定程度就不再存在短结构省内存的优点
> - 很多用于聚合统计的数据不适合保存在分片中。比如计数器，常用计数器判断某些执行次数是否达到上限，如果把聚合统计数据分散到多个分片里，将很


### 其他建议

- 尽量让键名保持简短。键名包含 key，member，field 等需要用户起的名字
- 将字符串存到 hash 里。如果存在大量的 String 类型的 key，且 key 名多为 namespace:id，value 为短字符或数字。用 hash 能省内存（因为 value 很短，所以按百分比来算，key 名中的 namespace 占了很多空间）
- 当需要进行大量数据的唯一性判断时（比如判断某个标识符是否被标记过），用位图或布隆过滤器要比用集合好得多
  - 位图适用于连续的序列号的唯一性判断
  - 布隆过滤器适用于分散的字符串，且容许少数失败的唯一性判断
- 如果要根据数据量预先为 key 分配空间或分片数量，就进行数据统计。把统计结果给下一次分配空间或分片数量时做参考（如果有必要，还可以对这个统计结果进行上下取整，如 Java 的 HashMap 的容量总是 2 的 n 次幂）



### 位图

位图常用于以紧凑的格式保存计数器，定长字符串，布尔值等数据



比如，常用位图保存用户的在线状态，每一位的位置信息表示 uid，值信息表示用户是否在线（这里的 0、1 起布尔值的作用）



每个信息占用的内存越多，保存的信息就越详细



保存用户在线信息时，每个用户的信息仅占用了一位。如果每个数据占用 2 个字节，那么获取信息时，只需要注意正确地计算出数据偏移量的起始地址即可



> redis 用动态字符串实现 String ，按需为其分配内存，如果不够再扩容。redis 的位图完全由 String 实现
>
> 一个 字符串 key 最大为 512 MB。如果突然对对一个长度很短的字符串，进行 setbit，且 set 的偏移量很大，字符串就需要先完成扩容，这个行为可能很耗时



位图也可以进行分片设计，且因为字符串的访问无需任何编解码，能实现随机访问，所以位图的分片数量可以非常多

位图的 api 就是 String 提供的能操作位的命令



## 扩展读写性能



### 主从复制

因为主从复制会提高系统复杂性，且需要应对复制的开销

所以在开始搭建 Redis 主从架构前，应该保证已经做过以下行为

- 用过短结构
- 用过单机分片
- 对读多写少的大对象进行压缩后再保存
- redis 客户端使用流水线和连接池



主从复制会遇到的问题及其解决方案

Q：主机宕机

A：哨兵模式实现重新选举主机



Q：从机过多导致主机需要大量分发复制命令

A：搭建多层次的主从结构，主机的直接从机作为中间层，主机只发送少量复制命令给有限的中间层从机，中间层分发给大量的底层从机

缺点：提高了系统的复杂度，增加了处理故障的难度



Q：复制速度慢

A：使用带压缩的 SSH 隧道进行链接。压缩的开销不会非服务器造成很大的负担



### 哨兵模式

哨兵会监视主机和从机，识别其他哨兵

当主机失效后，哨兵集群选举出一个哨兵作为决策哨兵，决策哨兵选择一台从机作为新主机，提醒其他从机跟随新主机并开始复制



### 分片

再提高写性能前，先尝试一切办法降低内存占用，减少需要写入的数据量

- 从应用层设计角度，减少需要写入的数据
- 用短结构，用数据统计取代占用内存多的经典数据结构



如果单机优化到达瓶颈，就用跨机分片

一开始系统数据量少时，可先考虑在单机上运行多个 redis-server 实例进行分片行为。当数据量够大时再用多机搭建



在客户端用装饰器实现分片，根据参数获取分片连接。对于不能进行分片行为的 key 应用非分片方式获取非分片连接
