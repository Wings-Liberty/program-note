#还没有复习 

# JVM

JVM的内存模型和分区，以及每个区的作用是什么。还有，JVM常用的中类有三种，这三种JVM的一样吗

Java虚拟机的种类

java虚拟机的堆调优和dump文件，jprofilter（查看运行过程中堆的的使用情况的可视化工具，需要再idea上安装插件，在本地安装软件，并再idea中指定软件的可执行文件的路径）

命令行传递参数，如设置堆的总内存大小，可用内存大小，是否输出dump文件，是否打印GC的日志


## JVM在计算机中的位置

是运行在操作系统上的一个虚拟机，或者说是计算机上运行的一个程序（就像是电脑上的QQ，浏览器，音乐播放器一样）


## JVM的内存模型和分区

常用的JVM有三种，默认使用`HotSpot`

JVM体系结构概览

`类文件（Class File）`，`类加载器（Class loader）`，`运行时数据区（RunTime Data Area）`，`执行引擎（Execution Engine）`，`本地方法接口（Native Interface）`，`本地方法库`

![[../../020 - 附件文件夹/Pasted image 20230402130322.png|500]]

`RunTime Data Area`就是JVM的核心，其核心分区为：

`类加载器`默认有三种，其功能都是将`.class`文件编译为Class对象（类对象）类对象存放于`方法区`。加载类的方式是`双亲委派机制`

`方法区`又称元空间。存放常量，静态变量，Class对象（类的字节码对象），普通方法，构造方法的字节码内容（其所在类的实例化对象在`堆`内存中，而非方法区）

`栈`线程级别（每一个线程都有一个栈），其功能是存放基本类型变量，存放对象的引用，记录实例方法的执行（执行方法时将方法压入栈，方法执行完毕后弹出栈）

​	`栈`里放的元素是`栈帧`。`栈帧`里记录着方法的索引，执行方法的参数，本地变量，类，`子帧`，`父帧`

`堆`应用级别（每个java应用都公用一个堆）存放类的实例化对象。JVM的垃圾回收机制就是用来清理`堆`中不需要的对象，释放内存的。

​	所以对JVM的优化也主要是对`堆`的优化。



### 堆

`堆`有这些区域

`新生区`分两部分，`伊甸园`，`幸存区`新创建的实例化对象多出于此。`伊甸园`里能扛过一次轻GC的对象会被放到`幸存区`

`幸存区`分两部分，`from区`和`to区`。`伊甸园区`中没有死亡的对象会来到`from区`，然后对象在`from`和`to`之间来回传递/复制的过程中不断回收掉不用的对象

`养老区`

`元空间`（Java8之前叫“永久区”）在`养老区`中经历过15次反复传递且还没有死掉的对象会来到这里



**GC（JVM的垃圾回收机制/算法）**

先使用`轻GC`清理`新生区`

`新生区`清理过后内存还是满的话，就用`轻GC`清理`养老区`

`养老区`清理过后内存还是满的话，就用`重GC`（全局GC回收）

`元空间/方法区`清理过后内存还是满的话，就抛堆内存溢出的异常

**`永久区`已被移除**



**ps**：方法区是JVM的规范，相当于接口。永久区/永久代 和 元空间 是方法区的具体实现，相当于实现了接口的类



### 堆参数调优

java程序的`main`方法有一个可变参数，它是用来接收使用命令运行程序时指定的参数的

这个可变参数在这里的所用是接收关于堆的参数的

在运行程序前，可指定`堆`的最大可用内存，堆中各区和子区所用内存的比例（对于垃圾回收有重要的作用）

还可以设置输出堆内存使用情况的日志，日志在控制台中可见

设置将对内存的使用情况输出为一个文件（dump），可使用可视化工具（JProFile）打开此文件，方便查看堆中的所有对象，“大对象”，各区内存的使用情况等



# 垃圾收集器

| 垃圾收集器                                      | 含义说明                                                     |
| ----------------------------------------------- | ------------------------------------------------------------ |
| 串行收集器<br/>(Serial Collector)               | 采用单线程执行所有的垃圾回收工作，适用于单核cpU服务器，无法利用多核硬件的优势 |
| 并行收集器<br/>(Parallel Collector)             | 又称为吞吐量收集器，以并行的方式执行年轻代的垃圾回收<br/>该方式可以显著降低垃圾回收的开销(指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态)。<br/>适用于多处理器或多线程硬件上运行的数据量较大的应用 |
| 并发收集器<br/>(Concurrent Collector)           | 以并发的方式执行大部分垃圾回收工作，以缩短垃圾回收的暂停时间。<br/>适用于那些响应时间优先于吞吐量的应用，<br/>因为该收集器虽然最小化了暂停时间(指用户线程与垃圾收集线程同时执行，但不一定是并行的，可能会交替进行)，<br/>但是会降低应用程序的性能 |
| CMS收集器<br/>(Concurrent Mark Sweep Collector) | 并发标记清除收集器，适用于那些更愿意缩短垃圾回收暂停时间并且负担的起与垃圾回收共享处理器资源的应用 |
| G1收集器<br/>(Garbage-First Garbage Collector)  | 适用于大容量内存的多核服务器，可以在满足垃圾回收暂停时间目标的同时，以最大可能性实现高吞吐量(JDκ1.7之后) |



在测试的时候，将参数调整之后，将Gc的信息打印出来，便于为我们进行参数调整提供依据，具体参数如下：

| 选项                                   | 描述                                                   |
| -------------------------------------- | ------------------------------------------------------ |
| -XX:+PrintGC                           | 打印每次GC的信息                                       |
| -XX: +PrintGCApplicationConcurrentTime | 打印最后一次暂停之后所经过的时间，即响应并发执行的时间 |
| -XX: +PrintGCApplicationStoppedTime    | 打印GC时应用暂停时间                                   |
| -XX:+PrintGCDateStamps                 | 打印每次GC的日期戳                                     |
| -XX:+PrintGCDetails                    | 打印每次GC的详细信息                                   |
| -XX: +PrintGcTaskTime Stamps           | 打印每个GC工作线程任务的时间戳                         |
| -XX: +PrintGCTimeStamps                | 打印每次GC的时间戳                                     |
