#还没有复习 

#  大纲

> - 第一部分：Linux 的规则与安装（第 0 ~ 4 章）
>   - 计算机概论和 Linux 的学习方式
>   - 主机规划与磁盘分区
> - 第二部分：Linux 文件，目录与磁盘格式（第 5 ~ 8 章）
>   - Linux 的文件与目录的权限管理
>   - Linux 的磁盘与文件系统管理
> - 第三部分：学习 shell 和 shell script（第 9 ~ 12 章）**略学，因为学完了也不用，所以也记不住**
>   - vim，bash 和 shell script 脚本
>   - 正则表达式
> - 第四部分：Linux 使用者管理（第 13 ~ 16 章）
>   - Linux 账号管理和 ACL 权限设定
>   - 磁盘配额（Quota）与进阶文件系统管理
>   - 进程管理
> - 第五部分：Linux 系统管理员（第 17 ~ 24 章）
>   - 系统服务
>   - 开机流程，模块管理和 Loader
>   - 基础系统设定和备份策略
>   - 软件安装
>   - Linux 核心编译与原理


在命令行里换行的方法：输入 '\\' 后再按回车 [ Enter ]


# 第 0 章：计算机概论

> 此章不对关于计组里简单的知识记笔记。只记一些易忘的和之后可能会用到的知识点
>
> - 零碎的计组硬件知识
> - 硬件和操作系统的交互（硬件，内核，驱动程序，系统调用，应用程序开发）



## 一些零碎的知识

- 传输速度。通常传输速度的字面值的单位是 bit/s，如：20M/5M，其实是 2.5MB/s 和 625KB/s
- 硬盘容量。通常硬盘容量的字面值是千进制的，如：硬盘容量字面值是 500G，500G 字面值是由 500 * 1000 MB 算来的，而实际容量是用 1024 为进制计算的，所以 500G 的硬盘实际并没有 500G
- 硬盘最小的物理量为 512B（现在都是 4K ），最小的组成单位为扇区（sector）


### 主板

主板是连接各组件的设备。根据组件的运行速度，主板把组件分为两部分连接——**南北桥**

速度快的组件连到北桥上：如 CPU，内存，显卡等

速度慢的组件连到南桥上：如 USB 设备，网卡，硬盘等

PS：为加快 CPU 和内存传输数据的速度，通常会把北桥整合到 CPU 内部，所以主板上通常只能看到南桥而看不到北桥


### 超线程（Hyper-Threading，HT）

CPU 把寄存器分为两组，让两个程序同时竞争一个 CPU 的运算单元，而不是通过操作系统的多任务切换，这让一个 CPU 有两个内核一样。所以使用 HT 技术的 CPU 会把一个 CPU 从逻辑上分为 2 个 CPU。4 核 CPU 被操作系统检测后却显示是 8 核的


### 内存双通道

内存双通道设计提高运行速度，见 408 


### BIOS

BIOS 全称 Basic Input Output System。是保存系统硬件详细信息和控制启动设备的选择（比如电脑是从硬盘启动还是从 U 盘启动）的小程序，它被保存在只读存储器上

BIOS 是开机时首先加载到内存并运行的小程序


## 软件程序运行和操作系统


### 软件程序

软件程序最终会被编译成机器语言去执行。机器语言由硬件执行，不同的硬件使用的指令集可能不同，所以很早之前理论上一套程序不能跨不同型号的设备运行（这个和跨平台好像还不是一个意思）



### 操作系统

为解决上述问题就有了操作系统。**操作系统**是一组程序，用来管理电脑的所有活动以及驱动系统中的所有硬件

操作系统对外提供一些接口，声称调用接口可驱动硬件执行某些行为。操作系统封装若干指令作为接口的实现。这些接口供**系统调用**（不是供应用程序调用）

操作系统的功能就是调用 CPU 进行逻辑判断和运算数据，调用内存读写数据和程序代码，调用硬盘存取数据，让网卡开始传输数据或发送数据，让外设看都可以开始运转等，这就是操作系统的功能，这些都是**操作系统的内核（Kernel）**完成的

只有内核提供的功能，电脑系统才能帮你完成，如果那你内核不支持某些功能，即使硬件设备提供这些功能电脑系统也不会去使用。比如：内核不支持 TCP 协议，所以无论使用哪种网卡，内核都无法提供此功能



### 系统调用

内核直接驱动硬件执行任务，所以让用户接触到内核是十分危险的事，如果用户操作内核程序不当会导致计算机崩溃，所以内核程序在运行时会被放到内存的受保护区域中，阻止用户直接接触内核

为了开发软件，必须调用内核提供的功能，但又不能直接接触内核，所以操作系统会提供**程序编程接口**（Application Programing Interface）供软件开发调用，软件工程师只需参考，调用此 API 即可

<center>硬件，操作系统和应用程序的关系</center>


内核程序驱动硬件执行任务，系统调用调用内核程序。应用程序调用系统调用

应用程序开发都是参考系统调用提供的 API ，所以该应用程序只能在该操作系统上运行，如果在其他操作系统上运行很有可能无法正常工作


### 内核的功能

内核的核心功能在于和 CPU，内存打交道。所以内核程序必须能做这些事

- 系统调用接口。能提供清晰明了的内核程序供系统调用使用
- 进程管理
- 内存管理。通常内核会提供虚拟内存的功能，当内存不足时会提供交换分区（swap）的功能
- 文件系统管理。例如数据的 I/O 工作
- 设备驱动。这是内核程序的主要工作之一。目前有所谓的可加载模块功能，可将驱动程序编译成模块，更新驱动程序时就不需要重新编译内核


### 操作系统和驱动程序

通常驱动程序的 API 由操作系统提供，硬件生产商根据操作系统提供的 API 去实现驱动程序。这样有利于驱动程序的更新



# 第 1 章：Linux 是什么以及如何学习

- Linux 可以在哪些种类的计算机上运行？

操作系统内核定义了一些驱动程序 API ，驱动程序交给硬件厂商去实现。所以一般来说一个操作系统仅能在有提供符合 API 规定的驱动程序的硬件架构上运行

如果某硬件架构没有提供 Windows 要求的驱动程序，那此硬件架构上就无法运行 Windows。除非硬件提供相应的驱动程序或修改操作系统的程序代码去适配硬件，后者称为“软件移植”

Linux 由于是开源的操作系统，所以它的程序代码背修改为适合在各种硬件架构上运行，这叫具有“可移植性”



要把 Linux Kernel 安装到电脑并变成可执行的二进制文件对于普通用户来说是很困难的，所以有人就把内核和常用软件合并并提供完整的安装程序，这称为 Linux 发行版（Linux distribution）

```
Linux Kernel + Software（含有自由软件和专属软件） + Tools + Documentation => 可完整安装的程序 = Linux distribution
```

众多发行版的主要区别在于管理工具和套件管理的模式不同，以安装软件的方式可将这些发行版分为 

- RPM 方式安装软件的系统
- DPKG 方式安装软件的系统


# 第 2 章：主机规划与磁盘分区

> - Linux 如何提供对驱动程序和硬件设备的支持
> - Linux 的几种磁盘分区方式，文件系统等
> - Linux 中的文件系统和目录树的关系（挂载）


## Linux 与硬件的搭配

Linux 对于计算机各组件或设备的识别的表现为：**各个组件和设备在 Linux 下面都是一个文件**


**驱动程序对硬件的支持**

在 Linux 下更换硬件时需要更新驱动程序，使用能驱动新硬件的驱动程序才能让新硬件工作。驱动程序往往来自于硬件提供商的官网，需要自行下载并编译。如果找不到驱动程序，那硬件就无法正常运行


要想了解主机能否支持某个版本的 Linux ，可以在 https://linux-laptop.net/ 这里查询


## 各硬件装置在 Linux 中的文件名

Linux 系统中，每个装置都被当成一个文件来对待，几乎所有的硬件设备都在`/dev`目录下有各自对应的文件



磁盘设备文件名通常分两种，SATA 与 USB 设备文件名为`/dev/sd[a-p]`，虚拟机的设备可能为`dev/vd[a-p]`


## 磁盘分区

> [EFI、UEFI、MBR、GPT的区别](https://blog.csdn.net/mao0514/article/details/51162915)

Linux 操作系统会被安装到磁盘上。一个磁盘会被分成多个分区槽。以 Windows 为例，Windows 操作系统会把磁盘分区为 C 盘，D 盘等，C 盘，D 盘就是分区槽


### 磁盘的连接方式与硬件文件名的关系

每个硬件都在`/dev`下对应一个文件。这个文件的文件名时如何命名的已经在上面的表中规定好了


问题1：当电脑上连接多个硬盘或 U 盘时，它们谁是`/dev/dsa`谁是`dev/dsb`


PS：SATA 插槽是硬盘常用的接口类型


问题2：如果一磁盘被分成了两个分区槽，那每个分区槽的装置文件名又是什么？

答：这和磁盘的物理组成有关系。下节讲


### MSDOS（MBR）和 GPT 磁盘分区表

对于磁盘这个硬件设备来说，通常会有这种需求：希望把一个磁盘逻辑划分出多个区来使用（为什么会有这个需求下面会讲）

比如 Windows ，Windows 下的分区表现为把一个磁盘分成若干个盘符，C盘，D 盘...


早期磁盘的第一个扇区内含有的重要信息被称为 MBR（Master Boot Record）格式，后因为磁盘容量不断增大，于是出现了一个新的磁盘分区格式，称为 GPT（GUID partition table）。两种分区分格式和限制有所不同。下面讲解这两种分区方式


**分区槽的概念**

通常一个磁盘有多个磁盘盘，所有磁盘盘的同一个磁道称为磁柱，通常那是文件系统的最小单位，也就是分区槽的最小单位。现使用 GPT 可以不使用磁柱做分区槽的最小单位，而直接使用扇区号码作为分区单位


**分区的必要性/为什么要分区**

1. 数据的安全性：每个分区槽的数据是分开的，所以当对某个分区槽重整时就不会影响其他区槽。例如：Windows 中对 C 盘重装系统时，不会影响 D 盘中的数据
2. 系统的性能考虑：查询文件时，磁盘会在指定的分区中查询文件，这有助于提高数据读取的速度

下面讲解 MSDOS（MBR）和 GPT 磁盘分区表（partition tbale）这两种分区方式


#### MSDOS（MBR）方式分区格式与限制

早期 Linux 为兼容 Windows 的磁盘而使用 Windows 使用的 MBR 方式处理开机管理程序和分区表，这段信息通常被放在磁盘的第一个扇区

这个扇区会保存两个数据

- 主要启动记录区：可以安装开机管理程序的地方
- 分区表：记录整颗磁盘分区的状态

分区表会记录第几个磁柱到第几个属于哪个分区

分区表中的每条记录被分为**主要分区槽**和**延伸分区槽**两种

假设在 Linux 下硬盘被分成 4 个区，那么 /dev/sda 的这 4 个分区槽在 Linux 系统中的设备文件名为 /dev/sda1，/dev/sda2，/dev/sda3，/dev/sda4。当使用的操作系统是 Windows 时，上述 4 个分区槽的代号就是 C，D，E，F


对于分区表，我们可知一下几个重点信息

- 所谓分区就是针对分区表进行设定分区范围而已
- 分区信息分为主要分区槽和延伸分区槽
- 当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分区槽进行数据的处理
- 当分区表所在的扇区废掉后，整个硬盘基本就废了，因为系统启动时找不到分区信息


**主要分区和延伸分区**

场景：假设分区表只能记录 4 条记录，但需要把磁盘分为 4 个以上的分区

解决方案：使用另一个扇区再保存一个分区表。主要分区记录指定的磁柱范围就是分区使用的范围；延伸分区记录指定的磁柱范围就是下一个分区表中可使用的磁柱范围，下一个分区表就能在指定范围内再进行分区。这样就实现了使用多个分区表进行分区

PS：这些建立在延伸分区上的分区称为**逻辑分区**

补充：

- 两个属于同一延伸分区的逻辑分区能够直接整合/合并，但是主要分区的分区槽和延伸分区的逻辑分区槽不能直接合并，除非重新定义整个逻辑分区
- 逻辑分区不能被格式化
- 扩展分区记录只能有一个


#### GPT 磁盘分区表

GPT 和 MBR 相比，GPT 具有以下优点

- 使用更多的扇区保存分区表，这意味着能保存更多的分区记录（GPT 中以 LBA 为单位保存分区表和主要启动记录区）
- 每条分区记录能使用更多的空间，这意味着每个分区的空间能够设置的更大
- 分区不再区分主要分区，延伸分区和逻辑分区。可以理解为所有的分区都是主要分区，这意味着所有的分区槽都能被格式化
- 使用另一片扇区保存一份分区表的备份，以便容灾
- 如果磁盘超过 2G 的化可以使用 GPT


## 开机流程中的 BIOS  和 UEFI 开机测试程序

硬件由操作系统驱动，所以操作系统也能驱动硬盘

操作系统能识别硬盘中的文件系统，读取其中的软件并执行软件。但是操作系统本身也是软件，所以有以下两个问题

1. 计算机刚刚开机时内存中没有任何软件，计算机是如何加载操作系统的？
2. 操作系统也是软件，计算机如何从硬盘的软件中识别出哪个是操作系统？


目前的主机系统再加载硬件驱动方面的程序，主要有 BIOS 和 UEFI 两种机制


### BIOS 搭配 MBR/GPT 的开机流程

在计算机概论里有 BIOS 与 CMOS 两个东西

- CMOS 是记录各项硬件参数且嵌入在主板上面的储存器
- BIOS 则是一个写入到主板上的一个固件（固件就是写入到硬件上的一个软件程序）。BIOS 是在开机的时候，计算机系统会主动执行的第一个程序

> 主板上面如果有内建的网络卡或者是显示适配器时，该功能是否要启动与该功能的各项参数,是被记录到主板上头的一个称为 CMOS 的芯片上，这个芯片需要借着额外的电源来发挥记录功能，这也是为什么你的主板上面会有一颗电池的缘故
>
> 那 CMOS 内的数据如何读取与更新呢？
>
> 还记得你的计算机在开机的时候可以按下 [Del] 按键来进入个名为 BIOS 的画面吧？BIOS（ Basic Input Output System）是一套程序，这套程序是写死到主板上面的个内存芯片中，这个内存芯片在没有通电时也能够将数据记录下来


简单的说，整个开机流程到操作系统之前的动作应该是这样的

1. BIOS：开机主动执行的固件，会认识第一个可开机的装置（MBR 中记录的主要启动记录区）
2. MBR：第一个可开机装置的第一个扇区内的主要启动记录区块，内含开机管理程序
3. 开机管理程序（boot loader）：是一个可读取核心文件来执行的软件
4. 核心文件：开始操作系统的功能


> 第二点要注意，如果你的分区表为 GPT 格式的话，那么 BIOS 也能够从 LBA0 的 MBR 兼容区块读取第一阶段的开杋管理程序代码
>
> 如果你的开杋管理程序能够认识 GPT 的话，那么使用 BIOS 同样可以读取到正确的操作系统核心。换句话说，如果开机管理程序不懂 GPT ，例如 Windows XP 的环境,那自然就无法读取核心文件，开机就失败了

**多重引导**

> BIOS 与 MBR 都是硬件本身会支持的功能，至于 boot loader 则是操作系统安装在 MBR 上面的一套软件
>
> 由于 MBR 仅有 446 bytes 而已,因此这个开机管理程序是非常小而美的。这个 boot loader 的主要任务有底下这些项目:
>
> - 提供选项：用户可以选择不同的开机项目,这也是多重引导的重要功能
> - 载入核心文件：直接指向可开机的程序区段来开始操作系统
> - 转交其他 loader：将开机管理功能转交给其他 loader负责
>
> 其中，提供选单和转交给其他 loader 是多重引导的重要功能

双系统就需要多重引导来选择启动的操作系统。这代表计算机里有两个以上的管理程序。硬盘里只有一个 MBR ，但是开机管理程序除了可以安装在 MBR 上，还能安装在每个分区槽的启动扇区（boot sector）上

以一个装有双系统的电脑的启动流程为例

1. 开机后 MBR 的开机管理程序提供两个选项，选项 1 可直接加载 Windows 的核心文件开机；选项 2 则是把开机管理工作交给第二个分区槽的启动扇区（boot sector）
2. 如果选择选项 2 ，那么整个开机管理工作就会交给第二分区槽的开机管理程序


- 每个分区槽都拥有自己的启动扇区（boot sector）
- 实际可开机的核心文件是放置到各分区槽内的
- loader 只会认识自己的系统槽内的可开机核心文件，以及其他 loader 而已
- loader 可直接指向或者是间接将管理权转交给另一个管理程序


PS：安装 Windows 后，它会覆盖掉 MRB 和自己所在分区的启动扇区。也就是说安装 Windows 后开机时直接选择启动 Windows。所以装双系统时，如果先装 Linux 再装 Windows ，启动时就不会提供开机管理选项，直接启动 Windows


- grub 命令 是多重引导程序 grub 的命令行 shell 工具


### UEFI BIOS 搭配 GPT 的开机流程

BIOS 需要使用兼容模式才能使用 GPT 方式处理启动引导程序，所以有了 UEFI，又称 UEFI BIOS。它用来代替 BIOS 固件


## Linux 安装模式下，磁盘分区的选择（极重要）


### 目录树结构

Linux 中所有数据都是以文件形式存在，所以整个 Linux 系统最重要的地方就是目录树结构

目录树结构就是以根目录为主，然后向下呈现分枝状的目录结构的一种文件架构，所有文件都是由根目录衍生来的

<center>目录树相关示意图</center>



Linux 系统使用目录树架构保存文件，但是我们的文件数据其实是放置再磁盘分区中

**问题：如何结合目录树的架构与磁盘内的数据？** 这需要了解**挂载**（mount）


### 文件系统与目录树的关系（挂载）

所谓的 “挂载” 就是利用一个目录作为 “进入点” ，将磁盘分区中的数据放置在该目录下；也就是说进入这个目录就可以读取这个分区的意思。这个操作称为 “挂载” ，”进入点“ 的目录称为挂载点

Linux 系统中最重要的是根目录，所以根目录一定要挂载到某个 分区，其他的目录可以挂载到不同的分区

<center>目录树与分区之间的相关性</center>



上图中假设我的硬盘分为两个分区，partition1 挂载到根目录，partition2 挂载到 home 目录

也就是说，当我的数据放置在 home 内的各次目录时，数据是放置到 partition2 的，如果不是放在 home 底下的目录，那么数据就会被放置到 partition1了


判断某个文件在哪个分区时，通过反向跟踪即可。如想知道`/home/vbird/test`在哪个分区，可由 test — vbird — home — / 的顺序看哪个“进入点”先被查到哪就是使用的进入点


初次分区时，只要划分 “根目录” 和 “交换分区” 使用的分区即可


- fdisk 指令可用于分区
- fsck 指令可修复部分文件系统的问题



# 第 3 章：CentOS 7

> - 安装 Linux 发行版的流程（从进入安装界面到磁盘分区到启动系统）
>
> - Linux 下的指令格式

<center>虚拟机中推荐的一种分区配置</center>


> 安装的步骤在各主要 Linux distributions都差不多,主要的内容大概是
>
> 1. 调整开机媒体（BIOS）：务必要使用 CD 或 DVD 光盘开机,通常需要调整 BIOS
> 2. 选择安装模式与开机：包括图形接口/文字接口等,也可加入特殊参数来开机进入安装画面
> 3. 选择语系数据：由于不同地区的键盘按键不同,此时需要调整语系/键盘/鼠标等配备
> 4. 软件选择：需要什么样的软件?全部安装还是预设安装即可？
> 5. 磁盘分区：最重要的项目之一
> 6. 开机管理程序、网络、时区设定与 root 密码：一些需要的系统基础设定
> 7. 安装后的首次设定:安装完毕后还有一些事项要处理,包括用户、 SELinux与防火墙等


CentOS 提供了 3 种分区类型

- 标准分区。也就是之前说的主要分区
- LVM。一种弹性增加或缩小文件系统容量的分区
- LVM 精简配置。是 LVM 的高级版


文件系统类型

- ext2/ext3/ext4。Linux 早期使用的文件系统类型，但是不适合在大容量的硬盘中使用。现在用的比较少了
- swap。磁盘模拟为内存的交换分区，交换分区不使用目录树的挂载功能，所以交换分区不需要指定挂载点
- BIOS Boot。GPT 分表区使用的东西
- xfs。CentOS 7 默认的文件系统，适用于大容量的磁盘
- vfat。同时被 Linux 和 Windows 支持的文件系统类型


**X Window 与命令行模式的切换**

Linux 默认提供 6 个终端

第一个终端是 X Window 图形化桌面（窗口管理器环境）

其他 5 个是 Terminal 终端

通过 Ctrl + Alt + [F1~F6] 进行切换


使用命令行方式启动图形界面。但是需要保证几个前提条件（这里不列举）

```sh
$ startx
```


## 命令行模式下命令的执行

命令行模式登录后运行的程序叫壳（Shell），Shell 是厉害的 Bash


```shell
$ command [-options] parameter1 parameter2 ...
# 命令     选项       参数1       参数2
```


热键

- Tab。补全
- Ctrl + c 。中断当前程序
- Ctrl + d。相当于 EOF


# 第 5 章：Linux 的文件权限与目录配置

> - 文件所属的用户和用户组的概念
> - 文件和目录的普通权限 rwx 的含义
> - 如何修改文件和目录的权限或所属用户和群组
> - Linux 中几个重要目录的用途，以及定义这些用途的标准


## 用户与用户组

Linux 把文件的可读可写的身份分为 3 个类别：拥有者（owner），所属群组（group），其他人（others）

每种身份对文件各有读（read），写（write），执行（execute）

PS：一个账号可以属于多个群组


**Linux 用户身份与用户组记录的文件**

默认情况下

- 所有的系统上的账号与一般身份用户和 root 用户的相关信息都在`/etc/passwd`文件中
- 每个人的密码记录在`/etc/shadow`文件中
- 所有的组名都记录在`/etc/group`文件中

这 3 个文件的格式稍后再说


## Linux 文件权限概念


### Linux 文件属性

```shell
$ ll
```

```
drwxr-xr-x    2     root    root      4096     Mar 23 23:29 wpa_supplicant/
drwxr-xr-x    4     root    root      4096     Dec 12 17:27 X11/
-rw-r--r--    1     root    root       642     Sep 24  2019 xattr.conf
drwxr-xr-x    4     root    root      4096     Dec 12 17:23 xdg/
-rw-r--r--    1     root    root       477     Oct  7  2019 zsh_command_not_found
 [  权限  ]  [链接]  [拥有者] [用户组]  [文件容量]   [修改日期]   [文件名]
```

权限前的第一个字符表示文件类型

- d：目录
- -：文件
- l：链接文件（linnk file）
- b：表示为设备文件里的可供存储的周边设别（可按块随机读写的设备）
- c：表示为设备文件里的串行端口设备，例如键盘，鼠标（一次性读取设备）

权限分为 3 组，每组 3 个字符

- 第一组是拥有者对文件的权限
- 第二组是同组的组内其他成员对文件的权限
- 第三组是其他人对文件的权限

PS：目录和文件的权限限制意义并不相同，在后面的章节再讲

链接数：每个文件都会把它的文件属性，权限记录在文件系统的 inode 中，我们使用的目录树使用文件名来记录。所以每个文件名都会链接到一个 inode 上，“链接数”就是用来记录有多少个不同的文件名链接到相同的一个 inode 上

文件容量：默认单位是 Bytes，字节

- 对于目录来说，只有拥有 rx 权限的用户才能进入目录
- root 用户基本不受系统权限限制，所以无论文件的权限是什么，默认 root 都能执行读写
- 文件的对组内成员的权限限制有利于团队协作


### 修改文件属性与权限

- chgrp：修改文件或目录的所属群组（change group 的缩写）
- chown：修改文件或目录的拥有者或所属群组（change owner 的缩写）
- chmod：修改文件或目录的权限（change mode 的缩写）

chgrp， chown 和 chmod 的 -R  选项用于递归修改目录下的所有子目录和子文件的所属用户或所属群组或权限

<center>chmod 符号形式修改文件或目录权限的命令格式</center>



```shell
$ chmod u=rwx, go+rx readme.md
```


### 目录与文件的权限意义

目标：理解几种文件权限在文件和目录中的不同含义

Linux 中的文件被分为一般文件和目录。每个文件都能有自己的权限，以 rwx 这 3 种权限举例


**权限对于文件的意义**

文件是实际存放数据的地方

- r（read）：读权限，可读取文件内容
- w（write）：写权限，可以编译，新增或修改文件内同（但不包含删除文件的权限）
- x（execute）：执行权限，该文件具有能被系统执行的权限（在 Linux 系统中文件能否被执行只和文件是否有 x 权限有关，和文件的后缀名无关）


**权限对于目录的意义**

目录是存放文件名的列表，文件名和目录有强烈的关联

-  r（read contents in directory）读权限，表示具有能读取目录列表中**文件名**的权限。比如能执行 ls 指令
-  w（write contents in directory）写权限，表示具有对目录列表中**文件名**进行变动的权限
   -  新建文件或目录
   -  删除文件或目录（和被删除的文件的权限无关）
   -  对已存在的文件或目录进行改名
   -  移动该目录内的文件或目录位置
-  x（access directory）访问权限，表示具有进入该目录的权限。比如能执行 cd 指令进入目录


PS：工作目录：当前所在的目录

PS：对目录有 r 权限但没有 x 权限，执行 ls 指令只能获取目录中的文件名，但获取不到文件的其他信息，比如文件的权限，大小，最近一次的修改时间等


**案例**

用当前用户创建：`/dir1/file1`和`/dir2`，下表是执行某些操作时所需的最小权限

<center>执行指定操作的最小权限</center>



由上图可见

- 想要操作`/dir1`中的文件，对`/dir1`的 r 权限是非必须的
- 通常要开放的目录，都会对外提供 rx 这两个权限


### 文件种类与扩展名


**文件种类**

---

- 常规文件（regular file）
  - [ - ]      大致可分为：纯文本文件，二进制文件，数据文件
- 目录（directory）
  - [ d ]
- 链接文件（link）
  - [ l ]     相当于 Windows 下的快捷方式
- 设备与设备文件（device）
  - [ b ]    区块（block）设备文件，就是一些存储数据，提供系统随机存取的接口设备，比如硬盘，软盘
  - [ c ]     字符（character）设备文件，就是一些串行端口的接口设备，比如鼠标，键盘。这些设备的特点是一次性读取，不能截断输出
- 数据接口文件（sockets）
  - [ s ]     比如用 socket 开启一个监听来进行网络上的数据交换。可在`/run`和`/tmp`上看见这种类型的文件
- 数据输送文件（FIFO，pipe）
  - [ p ]     一种特殊的文件类型，它的主要目的用于解决多个程序同时读写一个文件造成错误的问题


**Linux 文件扩展名**

---

- Linux 下，文件能给否被执行只和文件的 x 权限有关，和文件的文件扩展名无关
  - 但是文件能被执行并不意味着可以成功执行。因为就算给一个纯文本文件赋予 x 权限也不能成功执行
- 虽然文件扩展名无实际意义，但可以作为助记符。比如 .sh  .tar  .zip  .html
- 尽量避免在文件名中出现特殊字符，如`* ? < > ; & ! [ ] | \ ' " \ ( ) { } - +`


## Linux 目录配置的依据——FHS

Linux 的众多发行版中都遵守一套目录配置标准，这套标准规定了什么类型的文件应该放在哪些目录里

Filesystem Hiberarchy Standard（FHS）标准把目录定义为四种交互作用的形态


- 可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据，是能够分享给网络上其他主机挂载用的目录
- 不可分享的：自己机器上面运作的装置文件或者是与程序有关的 socket 文件等，由于仅与自身机器有关所以当然就不适合分享给其他主机了
- 不变的：有些数据是不会经常变动的，跟随着 distribution 而不变动。例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等
- 可变动的：经常改变的数据。例如登录文件、一般用户可自行收受的新闻组等


事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义

- /（根目录）：与开机系统有关
- /usr（unix software resource）：与软件安装/执行有关
- /var（variable）：与系统运作过程有关

有关其他目录的规定和目录树的结构见书中详述


# 第 6 章：Linux 文件与目录管理

> - 文件或目录的创建，删除，写，读的方式
> - 用户创建文件或目录时设置的默认全选 umask
> - 文件或目录的特殊权限
> - 查找命令或文件全文件名的方式

## 目录与路径

在根目录下 . 和 .. 都是根目录

- cd：变换目录
- pwd：显示当前目录
- mkdir：建立一个新的目录
- rmdir：删除一个空的目录


### 关于执行文件路径的变量：$PATH

PATH 是 Linux 中的环境变量，它的内容是由一堆目录组成，每个目录中间用冒号分割，每个目录有顺序之分

如果想在任何目录下都能直接通过可执行文件名执行文件，就把保存有这些可执行文件的目录的绝对路径添加到 PATH 这个环境变量中

如果 PATH 定义的目录中含有多个文件名相同的可执行文件，那么先查找到的同名命令先被执行


- 不同身份使用者预设的 PATH 不同，默认能够随意执行的指令也不同
- PATH 是可以修改的
- 使用绝对路径或相对路径直接指定某个指令的文件名来执行，会比搜寻PATH来的正确
- 指令应该要放置到正确的目录下，执行才会比较方便
- 本目录（.）最好不要放到PATH当中


补充：使用`apt install openjdk-8-jdk-headless`下载 jdk8 后就能在 bash 中使用 java 指令。用 type 指令观察后发现了 /usr/bin/java 这个文件，而 /usr/bin 在 PATH 中


## 文件与目录管理

- ls：文件与目录的查看
- cp，rm，mv：复制、删除与移动
- rename：用字符串替换的方式批量改变文件名
- basename：获取相对路径或绝对路径中文件的文件名
- dirname：获取相对路径或绝对路径中文件所在的目录的绝对路径名


## 文件内容查看

- cat（concatenate）：由第一行开始显示文件内容
- tac：从最后一行开始显示（tac是cat的倒着写）
- nl（Number of Lines）：显示的时候，顺道输出行号
- more：一页一页的显示文件内容，但不能先前翻页
- less：与more类似，但是比more更好的是，它可以往前翻页
- head：只看头几行
- tail：只看末尾几行
- od（Octal Dump）：以二进制的方式读取文件内容


管道符 | ：前面的命令所输出的信息，通过管道由后续的命令继续使用

比如：显示 /etc/man_db.conf 的第 11 行到第 20 行

```shell
$ head -n 20 /etc/man_db.conf | tail -n 10
```

tail 不需要接文件名，因为 tail 所需要的数据是来自于 head 处理后的输出结果


PS：如果想查看某个字符串的二进制、八进制、十进制、十六进制或 ASCⅡ形式，可用 echo + 管道符 + od 指令

如需要 "password" 的 ASCⅡ 形式

```shell
$ echo password | od -t oCc
```


## 修改文件时间或创建新文件：touch


Linux 下每个文件有以下 3 个和时间相关的主要属性

- 修改时间：modification time（mtime）
  当该文件的 “内容数据” 变更时，就会更新这个时间。内容数据指的是文件的内容，而不是文件的属性或权限

- 状态时间：status time（ctime）

  当该文件的 “状态”（status）改变时，就会更新这个时间。举例来说，像是权限与属性被更改了，都会更新这个时间

- 访问时间：access time（atime）
  当 “该文件的内容被取用” 时,就会更新这个读取时间（access time）。举例来说,用 cat 读取某个文件时，就会更新文件的 atime


touch  译：触 / 处理 / 影响 / 触动。touch 不光能用来创建文件，还能用来修改已存在文件的时间属性（如上述 3 个时间属性）


使用 `ls -l --time=[atime,ctime,mtime]`即可获取上述 3 个时间属性，默认是 mtime


## 文件与目录的默认权限与隐藏权限

文件除有基本的 r，w，x 权限外，在 Linux 传统的 ext2，ext3，ext4 文件系统下，还可以给文件设置其他的系统隐藏属性

- 使用`chattr`（change attribute）设置
- 使用`lsattr`（list attribute）查看


但在 CentOS 7.x 中使用的 xfs 文件系统就没有支持所有的 chattr 的参数，仅支持部分参数


### 文件默认权限：umask

umask 就是指定目前用户在建立文件或目录时的权限默认值


- 使用`umask`查看当前用户的文件默认权限

```
[root@study ~]# umask
0022           <==与一般权限有关的是后面三个数字，第一个数字和特殊权限有关
[root@study ~]# umask -S
u=rwx, g=rx, o=rx
```


umask 的数字指的是该默认值需要减掉的权限

- 目录的默认权限是 `rwx`，实际权限 = 默认权限 - umask
- 文件的默认权限是 `rw-`，实际权限 = 默认权限 - umask （也就是说默认文件是不能被执行的）


- 使用`umask`修改当前用户使用的文件默认权限

```shell
$ umask 002 # 修改 umask，给同组的用户 w 权限
```


### 文件隐藏属性

文件的隐藏属性由 chattr 控制（之前的服务器被运行的挖矿程序就是因为设置了隐藏属性导致 root 都删除不了挖矿程序的文件）

- chattr（change attribute 命令配置文件隐藏）

```
[root@study ~]# chattr [+-=] [ASacdistu] 文件或目录名称
选项与参数：
+	: 增加某一个特殊参数,其他原本存在参数则不动。
-	: 移除某一个特殊参数,其他原本存在参数则不动
=	: 直接设置参数,且仅有后面接的参数
A	: 当设定了A这个属性时,若你有存取此文件(或目录)时,他的访问时间 atime将不会被修改,可避免I/0较慢的机器过度的存取磁盘。(目前建议使用		文件系统挂载参数处理这个项目)
S	: 一般文件是异步写入磁盘的(原理请参考前一章snc的说明),如果加上S这个属性时当你进行任何文件的修改,该更动会「同步』写入磁盘中
a	: 当设定a之后,这个文件将只能增加数据,而不能删除也不能修改数据,只有root才能设定这属性
c	: 这个属性设定之后,将会自动的将此文件『压缩」,在读取的时候将会自动解压缩,但是在储存的时候,将会先进行压缩后再储存(看来对于大文件似乎蛮		有用的)
d	: 当dump程序被执行的时候,设定d属性将可使该文件(或目录)不会被dump备份
i	: 这个i可就很厉害了.它可以让一个文件“不能被删除、改名、设定连结也无法写入或新增数据”对于系统安全性有相当大的帮助.只有root能设定此属		  性
s	: 当文件设定了s属性时,如果这个文件被删除,他将会被完全的移除出这个硬盘空间所以如果误删了,完全无法救回来了
u	: 与s相反的,当使用u来配置文件案时,如果该文件被删除了,则数据内容其实还存在磁盘中,可以使用来恢复该文件

注意1 : 属性设定常见的是a与i的设定值,而且很多设定值必须要身为root才能设定
注意2 : xfs文件系统仅支持 Aadis 而己
```

PS：a 属性常用在 logfile 日志文件中


- lsattr（list attribute 显示文件隐藏属性）

```
[root@study ~]# lsattr [-adR] 文件或目录
选项与参数
a	: 将隐藏文件的属性也秀出来
d	: 如果接的是目录,仅列出目录本身的属性而非目录内的文件名
R	: 连同子目录的数据也一并列出来
```


### 文件特殊权限：SUID、SGID、SBIT

> SUID 权限：作用于可执行的二进制文件。作用是，让执行此文件的用户暂时拥有此文件的 owner 的所有权限
>
> SGID 权限：作用于文件或目录。作用在文件上时，让执行此文件的用户所属的 group 暂时变为此文件所属 group；作用在目录上时，用户在此目录下的有效用户组暂时变为此目录所属的 group
>
> SBIT 权限：作用于目录。作用是，用户只能操作在此目录下 owner 是自己的文件，不能操作其他人的文件


文件除了有基本的 rwx 权限外还有特殊权限。如`/tmp`的 other 有 t 权限，`/usr/bin/passwd`的 owner 有 s 权限 

```
[root@study ~]# ls -l /usr/bin/passwd ; ls -ld /tmp
-rwsr-xr-x 1 root root 68208 May 28  2020 /usr/bin/passwd
drwxrwxrwt 13 root root 4096 Mar 27 09:15 /tmp/
```


**SUID（Set UID）**

以`/usr/bin/passwd`为例

场景：所有用户的密码都在`/etx/shadow`文件中，此文件的权限如下（只有 root 能 w，shadow 组的成员也仅能 r 而已，other 什么权限都没有）

```
[root@study ~]# ls -l /etc/shadow
-rw-r----- 1 root shadow 1029 Mar 23 20:00 /etc/shadow
```

问题：每个用户都能用`passwd`指令自行修改自己的密码，但修改密码势必需要写`/etx/shadow`文件。对于对此文件没有 w 权限的用户来说为什么能成功修改密码


当 s 标志出现在文件 owner 的 x 权限上时，例如：/usr/bin/passwd 的权限状态为`-rwsr-xr-x`，此时就被称为 SUID

基本上 SUID 有这样的限制与功能

- SUID权限仅对二进制程序（binary program）有效
- 执行者对于该程序需要具有 x 的可执行权限
- 本权限仅在执行该程序的过程中有效（run-time）
- 执行者将在程序执行期间具有该程序拥有者（owner）的权限


现在对上述问题的解释就是：由于`/usr/bin/passwd`具有 s 权限，所以普通用户在执行`passwd`时会暂时变为 root 用户。root 用户对`/etc/shadow`具有 w 权限，所以能成功修改密码


**SGID（Set GID）**

s 标志出现在文件 owner 的 x 权限上时，称为 SUID；s 在 group 的 x 权限上时则称为 SGID

SGID 可作用在文件或目录上


如果 SGID 作用在文件上，它将具有以下功能和限制

- SGID 对二进制程序有用
- 程序执行者需有该文件的ⅹ权限
- 执行者在执行的过程中将会获得该文件 group 的支持

如果 SGID 作用在目录上，它将具有以下功能和限制

- 如果用户对此目录具有 r 和 x 的权限，则该用户能进入此目录
- 用户在此目录下的有效群组（effective group）将会变成该目录的群组
- 用途：若用户在此目录下具有 w 的权限，则使用者所建立的新文件，该新文件的群组与此目录的群组相同


**SBIT（Sticky Bit）**

仅能作用在目录上。当 t 标志出现在目录的 other 的 x 权限上时，称为 SBIT

基本上 SBIT 具有以下功能和限制

- 当用户对于此目录具有 wx 权限，即具有写入的权限
- 当用户在该目录下建立文件或目录时，仅有自己与 root 才有权力删除该文件


**SUID/SGID/SBIT 权限设置方式**

在执行`umask`时，出现的 4 位数字中，后 3 位为默认要去掉的 rwx 权限，第 1 位就是特殊权限

- SUID 为 4
- SGID 为 2
- SBIT 为 1

可使用`chmod`指令的数字法或符号法修改文件或目录的特殊权限（使用数字方式时，需要用 4 位数字表示，第 1 位数字就是特殊权限）


PS：s 和 t 权限会出现在某个 x 的位置上。如果文件在没有 x 权限的位置上设置 s 或 t 权限，x 位置就会出现 S 或 T。因为 s 或 t 权限的前提是需要 x 权限，所以 S 或 T 表示没有 x 权限，无法让 s 或 t 权限生效


### 观察文件类型：file

file 指令用于判断文件的类型

通常能识别出目前已知的各种文件类型，比如，纯文本，二进制文件，link 文件，可执行文件，sh 脚本文件，java 文件，tar 压缩文件，jar 包文件...


## 命令与文件的查找

目标：了解怎么查找 PATH 环境变量下的可执行命令所在位置和查找某任意一个文件的位置


### 脚本文件的查找

which：查找并显示给定命令的绝对路径

使用 which 可查找 PATH 环境变量下的可执行命令的所在位置。回显命令文件的绝对路径

有些命令可以双击 Tab 键补全，但其位置不在 PATH 环境变量下，比如 bash 的内置命令。命令的类型可用 type 指令查看


### 文件的查找

根据文件名（文件名可不完整，可用占位符或正则表达式表示）在文件系统中查找文件的绝对路径


- whereis

只从某些目录下进行查询，所以查询速度快。`whereis -l`可获取 whereis 执行查询时使用的目录

- locate/updatedb

使用保存有文件名和目录名的数据库进行查询。数据库的位置可用`locate -S`获取

数据库可能默认一天一更新，可使用 updatedb 指令进行主动更新。每次更新时会根据 /etc/updatedb.conf 配置文件中的配置执行更新

PS：Ubuntu 默认还没有  locate 指令

- find

根据文件名从磁盘中查询，耗时，耗性能。但查的范围全（范围可指定）


# 第 7 章：Linux 磁盘与文件系统管理

> - 文件系统是什么，管理文件系统的方式
> - 文件系统和磁盘的关系
> - 对文件系统和磁盘的分区，格式化与挂载


## 认识 Linux 的文件系统

> 第 0 章讲磁盘的物理组成，第 2 章讲对磁盘的分区
>
> 文件系统建立在磁盘上。此节讲**以 Linux 的正统文件系统 ext2 为例**讲文件系统中 inode，数据区块（block），超级区块（superblock）

- 格式化文件系统：不同的操作系统支持的文件系统格式并不相同，格式化就是把文件系统变为操作系统能使用的文件系统格式的过程
- 传统的磁盘和文件系统中，一个分区对应对应一个文件系统；现在，使用 LVM，软件磁盘阵列（software raid）可将一个分区可以被格式化为多个文件系统


### 文件系统特性

ext2 文件系统把文件的权限&属性和文件数据分开保存在不同的区块中

- 文件的权限（rxw）&属性（owner, group, other, mtime, ctime, atime 等属性）保存在 inode 区块中
- 文件的数据保存在 data 区块中
- 每个文件的权限&属性由一个 inode 区块保存，数据可在若干个 data 区块中保存。inode 中会记录这些 data 区块的编号
  - 通过查询 inode 中保存的 data 区块的编号来寻找数据，这种数据存取方式称为索引式文件系统


PS：没使用索引式的文件系统，如 FAT 没有 inode 区块，只有 data 区块。data 区块像链表一样指定下一个 data 区块的地址或编号，如果一个文件用来保存数据的区块过于分散会需要磁盘多转几圈才能读取到数据（这会降低读取速度）。所以定时进行磁盘碎片整理，把同一个文件所属的数据尽可能保存到临近的区块中来提升读取速度


- 超级区块：记录 filesystem 的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等
- inode：记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的 block 号码
- block：实际记录文件的内容，若文件太大时，会占用多个 block


### Linux 的 ext2 的文件系统

> 文件系统一开始就将 inode 和 block规划好了，除非重新格式化（或者利用 resize2fs 等指令变更文件系统大小），否则 inode 与 block 固定后就不再变动

- dumpe2fs ：查询 ext 系列文件系统的超级区块信息的命令


作为引导性的笔记，不记录书上其他的详细内容


### 再次了解目录树

- 目录

当我们在 Linux下的文件系统建立一个目录时，文件系统会分配一个 inode  与至少一块 block给该目录

其中，inode 记录该目录的相关权限与属性，并可记录分配到的那块 block号码;；而 block 则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据


- 目录树的读取

```
[root@study ~] 11 -li /etc/passwd

3595521 -rw-r--r-- 1 root root 2092 Jun 1700: 20 /etc/passwd
```

1. / 的 inode ：通过挂载点信息找到根目录的 inode 号码。判断用户是否有权限读取根目录的权限。判断结果：有权限读取（rx）
2. / 的 data ：找到 etc/ 的 inode 号码
3. etc/ 的 inode：根据上步中的号码找到 etc/ 的 inode，判断是否有权限读取 etc/。判断结果：有权限读取（rx）
4. etc/ 的 data ：找到 passwd 的 inode 号码
5. passwd 的 inode ：根据上步中的号码找到 passwd 的 inode，判断是否有权限读取 passwd。判断结果：有权限读取


### etc2/3/4 文件的存取与日志式文件系统的功能

在操作文件时系统突然中断会造成数据不一致的问题

使用 extfsck 可检查问题，但是很麻烦。所以文件系统实现了日志功能，每次操作文件系统时都会记录相应的日志，日志有助于解决数据不一致性问题

ext3/4 实现了日志功能


### 挂载点的意义（mount point）

每个 filesystem都有独立的 inode/ block/ superblock 等信息，这个文件系统要能够链接到目录树才能被我们使用。将文件系统与目录树结合的动作我们称为 “挂载”

挂载点一定是目录，该目录为进入该文件系统的入口。因此并不是你有任何文件系统都能使用，必须要 “挂载” 到目录树的某个目录后，才能够使用该文件系统的


### Linux 支持的其他文件系统和 VFS

Linux 中常见的支持文件系统有

- 传统文件系统：ext2、minix、FAT（用 vfat 模块）、iso9660（光盘）等
- 日志式文件系统：ext3、ext4、ReiserFS、Windows'NTFS、IBM's JFS、SGI's XFS、ZFS
- 网络文件系统：NFS、SMBFS


获取你当前 Linux 的主机支持哪些文件系统

```shell
$ ls -l /lib/modules/$(uname -r)/kernel/fs
```

获取系统已经加载到内存中支持的文件系统有哪些

```shell
$ less /proc/filesystems
```


**VFS**

Linux VFS（Virtual Filesystem Switch），是 Linux 内核提供的一个管理文件系统的功能

一台装有 Linux 的主机中，一个硬盘可以被分为若干个分区，每个分区可以使用不同类型的文件系统。但是在用 shell 读写文件时，用户对操作的文件所使用的文件系统是无感知的，因为对文件系统的管理交给了 VFS



### XFS 文件系统简介

ext 系列文件系统的缺点：因为要预先规划出所有的 inode 区块，data 区块，元数据等数据，所以格式化速度慢。尤其在为其大容量磁盘空间后，格式化耗时更是漫长


XFS 文件系统是日志式文件系统


**XFS 文件系统的结构**

- 数据区（data section）

  和 ext 类似，包括 inode，data 区块，超级区块。但 inode 和 data 区块都是动态创建的，而不是格式化时就创建好的。xfs 也有区块群组的概念

- 文件系统登录活动区（log section）

  提供日志功能。如果出现宕机，断点等问题导致数据不一致，系统会登录这个区，以日志记录为依据修复文件系统。甚至可以指定外部的磁盘作为 log section

- 实时运行区（realtime section）

  创建文件时，先把文件放到这个区中，之后再写入数据区

查看文件系统总体信息的方式

- ext 系列的文件系统可用 dumpe2fs 指令查看超级区块的信息
- xfs 文件系统可用 xfs_info 指令查看超级区块的信息


## 文件系统的简单操作

### 磁盘与目录的容量

- df：显示磁盘的相关信息
- du：显示每个文件和目录的磁盘使用空间

注意

- /proc 这个挂载点挂载在内存中，所以不占用磁盘空间
- /dev/shm 是利用内存虚拟出来的磁盘空间。在此目录下建立任何数据文件的访问速度都是非常快的，但重启后此目录下的文件就消失了


### 硬链接与符号链接：ln

**硬链接**：通过文件系统的 inode 链接来产生新文件名，而不是产生新文件

在文件系统中，每个文件占用一个 inode ，inode 中有文件数据所在的数据区块号码

文件的 inode 区块号码和文件名保存在文件所在目录的数据区块里

硬链接就是让多个文件名都指向同一个文件的 inode，这就是硬链接的由来。所以硬链接就是在某目录的数据区块下新增一条文件名链接到某 inode 号码的关联记录而已


为一个文件或目录创建一个硬链接后，链接数会 +1

```
drwxr-xr-x    2     root    root      4096     Mar 23 23:29 wpa_supplicant/
drwxr-xr-x    4     root    root      4096     Dec 12 17:27 X11/
-rw-r--r--    1     root    root       642     Sep 24  2019 xattr.conf
drwxr-xr-x    4     root    root      4096     Dec 12 17:23 xdg/
-rw-r--r--    1     root    root       477     Oct  7  2019 zsh_command_not_found
 [  权限  ]  [链接]  [拥有者] [用户组]  [文件容量]   [修改日期]   [文件名]
```

这个链接数的意义是：有多少个文件名链接到这个 inode 号码上

删除任意一个文件名，只要还有文件名链接到这个 inode ，这个文件就不会消失


硬链接的限制：

- 不能跨文件系统（因为硬链接通过指向 inode 号码建立关系的，而每个文件系统的 inode 号码都是独立的）
- 不能链接目录，只能链接文件

---

**符号连接**：和 Windows 的快捷方式可以划等号

符号连接会建立一个独立的文件，而这个文件会让数据的读取指向它连接的那个文件的文件名。所以符号连接的文件大小和源文件的文件名有关

符号链接在`ls -l`中会显示指向的源文件的绝对路径

```shell
$ ll
lrwxrwxrwx   1 root root          7 Dec 12 17:23 lib -> usr/lib/
lrwxrwxrwx   1 root root          9 Dec 12 17:23 lib32 -> usr/lib32/
lrwxrwxrwx   1 root root          9 Dec 12 17:23 lib64 -> usr/lib64/
lrwxrwxrwx   1 root root         10 Dec 12 17:23 libx32 -> usr/libx32/
```


缺点：源文件是 a，给 a 建立一个符号连接 b。删除 a 后，无法用 b 访问到文件。因为 b 无法找到文件 a


从安全性上来看，硬链接优于符号连接

但符号连接能跨文件系统，能连接目录


小结：硬链接的文件类型和源文件一样，符号连接的文件类型是 [ l ]

----

**关于目录的连接数量**

创建一个新目录时还会创建两个目录，它们是`./`和`../`，这两个是硬链接（因为 ll 指令显示它们不是 [ l ] 类型的文件）

所以指向当前目录的文件名有目录的绝对路径和`./`，所以新建目录的连接数为 2

`../`指向上级目录，所以创建一个目录后，上级目录的连接数也会 +1


## 磁盘的分区，格式化，检验与挂载

如果我们想要在系统里面新增一颗磁盘时，应该有哪些动作需要做的呢？

1. 对磁盘进行分区，以建立可用的分区
2. 对该分区进行格式化，以建立系统可用的文件系统
3. 若想要仔细一点，则可对刚刚建立好的文件系统进行检验
4. 在 Linux系统上，需要建立挂载点（亦即是目录），并将它挂载上来


MBR 格式的分区使用 fdisk 指令进行分区操作；GPT 格式的分区使用 gdisk 指令进行分区操作

parted 指令支持 MBR 和 GPT 两种格式的分区操作


### 观察磁盘分区状态

**lsblk**（list block device）：用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息。块设备有硬盘，闪存盘，cd-ROM等等

```
root@ecs-e80c-0010:~# lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
vda    252:0    0   80G  0 disk 
└─vda1 252:1    0   80G  0 part /
vdb    252:16   0  200G  0 disk
```

上述信息显示

- 有两个磁盘（因为 TYPE 的值为 disk），一个 80G，另一个 200G

- vda 有一个分区（因为其 TYPE 的值 part）vda1，此分区占用 80G，挂载到根目录下
- vdb 磁盘还未进行分区和挂载

紧接着执行带有选项的 lsblk 指令

```
root@ecs-e80c-0010:~# lsblk -ipf
NAME        FSTYPE LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINT
/dev/vda                                                                     
`-/dev/vda1 ext4         21c97956-3b0d-43a7-ac1b-08f80a3773f5   68.9G     8% /
/dev/vdb
```

使用选项后打印的信息显示。/dev/vda1 分区使用的文件系统类型是 ext4，它占有一个 Linux 为其分配的 UUID 作为系统内的唯一标识符

---

**blkid**：专门用来查看块设备的文件系统类型、LABEL、UUID等信息

```
root@ecs-e80c-0010:~# blkid
/dev/vda1: UUID="21c97956-3b0d-43a7-ac1b-08f80a3773f5" TYPE="ext4" PARTUUID="20d928c5-01"
```

---

**parted**：列出磁盘的分区表类型与分区信息

指令格式为 parted device name print

```
root@ecs-e80c-0010:~# parted /dev/vda print
Model: Virtio Block Device (virtblk)
Disk /dev/vda: 85.9GB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags: 

Number  Start   End     Size    Type     File system  Flags
 1      1049kB  85.9GB  85.9GB  primary  ext4         boot

--------------------------------------------------------------

root@ecs-e80c-0010:~# parted /dev/vda1 print
Model: Virtio Block Device (virtblk)
Disk /dev/vda1: 85.9GB
Sector size (logical/physical): 512B/512B
Partition Table: loop
Disk Flags: 

Number  Start  End     Size    File system  Flags
 1      0.00B  85.9GB  85.9GB  ext4
```

由上述信息可知，/dev/vda 使用 msdos 格式进行分区（也就是 MBR 格式）


### 磁盘分区：gdisk/fdisk

MBR 格式的分区使用 fdisk 指令进行分区操作；GPT 格式的分区使用 gdisk 指令进行分区操作

parted 指令支持 MBR 和 GPT 两种格式的分区操作


gdisk 和 fdisk 分区操作主要是

- 添加新分区，并为分区分配磁盘的容量（fdisk 以磁柱为单位，gdisk 以扇区为单位）
- 删除分区


执行完分区操作后，kernel 使用的分区表还是旧的分区表。可执行`partprobe`指令更新内核的分区表信息


### 磁盘格式化（建置文件系统）

磁盘格式化也叫创建文件系统

调用 mkfs（make filesystem）系列的指令执行创建文件系统。mkfs 系列的指令有以下几种

```
root@ecs-e80c-0010:~# mkfs [tab][tab]
mkfs         mkfs.btrfs   mkfs.ext2    mkfs.ext4    mkfs.minix   mkfs.ntfs    mkfs.xfs     
mkfs.bfs     mkfs.cramfs  mkfs.ext3    mkfs.fat     mkfs.msdos   mkfs.vfat
```

mkfs 是泛化指令，后跟 -t 指定要创建的文件系统的类型

mkfs.xxx 是创建具体的文件系统类型的指令


### 文件系统检验

如果出现宕机，停电等造成文件系统出现数据不一致问题，使用文件系统的检验指令对其进行检验和修复

- xfs 使用`xfs repair`指令检验和修复文件系统
- ext4 使用`fask.ext4`指令检验和修复文件系统


### 文件系统挂载与卸除

创建好文件系统后，需要把文件系统挂载到目录树下才能使用，否则只有 /dev/sdax 文件是没法使用磁盘空间存储文件的

关于挂载需要注意两点

- 挂载点和文件系统是映射关系（一个挂载点只能挂载一个文件系统，一个文件系统只能被挂载到一个挂载点上）
- 作为挂载点的目录，在挂载文件系统前应该是空的（否则之前的文件会被隐藏，直到文件系统被卸载）


**挂载与卸载指令**

- mount：挂载指令。挂载时需要指定块设备文件和作为挂载点的目录，块设备文件可以用文件名表示也可以用设备的 UUID 表示（用 blkid 获取设备的 UUID）
- umount：卸载指令


### 磁盘/文件系统参数修订

目的：系统运行时修改当前文件系统的一些参数

- mknod：通过修改 /dev/ 下的设备文件属性修改文件系统
- xfs_admin：通过修改 /dev/ 下 xfs 文件系统的分区文件，来修改文件系统的 UUID 和 lable name
- tune2fs：通过修改 /dev/ 下 ext4 文件系统的分区文件，来修改文件系统的 UUID 和 lable name


## 设定开机挂载

系统启动后会加载 /etc/fstab 文件，读取其配置后对 /dev/ 下的设备进行挂载。这个过程叫自动挂载

挂载要遵守以下限制

- 根目录是必须挂载的，而且一定要先于其它挂载点被挂载进来
- 其它挂载点必须为已建立的目录，可任意指定，但一定要遵守必须的系统目录架构原则（FHS）
- 所有挂载点在同一时间之内，只能挂载一次
- 所有硬盘分区在同一时间之内，只能挂载一次
- 如若进行卸除，必须先将工作目录移到挂载点目录及其子目录之外


### 开机挂载 /etc/fstab & /etc/mtab

这是一个 /etc/fstab 文件示例

```
UUID=21c97956-3b0d-43a7-ac1b-08f80a3773f5   /                 ext4    errors=remount-ro           0       1
/dev/fd0                                    /media/floppy0    auto    rw,user,noauto,exec,utf8 	  0       0
```

每行记录都对应一条挂载配置，每行配置有 6 个字段需要设置

```
[设备/UUID等]  [挂载点]  [文件系统]  [文件系统参数]  [dump]  [fsck]
```

​	
- 设备/UUID等
  有 3 中选择

  - 文件系统或磁盘的装置文件名，如 /dev/sda2 等
  - 文件系统的 UUID 名称，如UUID=xx
  - 文件系统的 LABEL 名称，例如 LABEL=XXX

- 文件系统：必须手写

- 文件系统参数：执行 mount 时用到的参数就是这些参数


  
- dump：是否可对其执行备份命令。通常不用默认的备份方案，所以填 0

- fsck：是否需要检验文件系统。填 0


修改完 /etc/fstab 文件后，执行重启或`mount -a`指令将 /etc/fstab 中定义的所有档案系统挂上

/etc/fstab 是开机时的配置文件，不过实际 filesystem 的挂载是记录到 /etc/mtab 与 /proc/mounts 这两个文件当中的。每次在更动 filesystem 的挂载时，也会同时更动这两个文件



### 特殊装置 loop 挂载

- CD/DVD 镜像文件不用刻录到光盘上就能挂载使用

使用`mount -o loop`指令把 iso 文件挂载到挂载点，通过挂载点即可访问镜像文件中的数据


- 此外还可以创建一个大文件，把这个大文件格式化后进行挂载

使用`dd -if=/dev/zero of=/xx/xx`创建一个大文件

对大文件使用某文件系统的格式化工具，再用`blkid`和`mount -o loop`指令将其挂载

看起来就好像是在没有执行分区的情况下进行了分区 或 在文件系统上搭建了一个文件系统（就和虚拟机一样）



## 内存交换分区（swap）之建置

内存交换分区是一个独立于目录树的分区

它的作用是：在内存不足时，可以将内存中部分数据暂时放到内存交换区（本质上是磁盘）。此外，如果 Linux 主机进入休眠状态时，也会把内存中的一些数据送到 swap 中


- 在个人计算机上个，通常不需要 swap ，因为目前的个人计算机的内存都够用
- 在服务器上，通常需要 swap ，因为服务器随时会收到大量请求


创建 swap 分区的方式有如下 2 种

- 使用物理分区创建内存交换区
- 使用文件创建一个 swap


### 使用实体分区槽建置 swap

1. 分区：先使用 gdisk 在你的磁盘中分区出一个分区槽给系统作为 swap 。由于 Linux 的 gdisk 预设会将分区槽的 ID 设定为 Linux的文件系统，所以可能还得要设定一下 system ID 就是了
2. 格式化：利用建立swap格式的`mkswap`指令格式化分区，使其成为 swap
3. 使用：最后使用`swapon`激活 Linux 系统中交换空间
4. 观察：最后使用`free`与`swapon -s`这个指令来观察一下内存的使用量


### 使用文件建置 swap

使用之前提到过的，把大文件格式化为文件系统后挂载起来作为 swap

1. `dd`指令创建大文件
2. `mkswap`把大文件格式化为内存交换文件的文件格式
3. 使用`swapon`启动 swap file；使用`swapoff`关闭 swap file；修改 /etc/fstab 设置开机自动挂载


## 文件系统的特殊观察与操作


### 磁盘空间之浪费问题

在 ext 系列的文件系统下，每个数据区块都只能保存一个文件的数据，如果数据区块还有剩余空间就会造成浪费

以 ext4 文件系统为例，当每个数据区块的大小为 4K 时

```
root@ecs-e80c-0010:~# ll -sh
total 56K
4.0K drwx------  5 root root 4.0K Mar 31 14:37 ./
4.0K drwxr-xr-x 21 root root 4.0K Mar 26 18:53 ../
8.0K -rw-r--r--  1 root root 8.0K Mar 31 13:49 .bash_history
4.0K -rw-r--r--  1 root root 3.1K Mar 30 11:02 .bashrc
4.0K drwx------  3 root root 4.0K Dec 12 17:48 .cache/
4.0K drwx------  3 root root 4.0K Mar 23 23:30 .config/
4.0K -rw-r--r--  1 root root  161 Dec  5  2019 .profile
4.0K -rw-r--r--  1 root root 3.2K Mar 23 23:23 sources.list
4.0K drwx------  2 root root 4.0K Mar 23 20:00 .ssh/
   0 -rw-r--r--  1 root root    0 Mar 25 09:49 tmp
 12K -rw-------  1 root root 8.8K Mar 30 16:58 .viminfo
4.0K -rw-------  1 root root  118 Mar 31 14:37 .Xauthority
```

上述的某些文件的实际大小不到 4K，但会占用一个 4K 的数据区块

所以 total 显示的大小是 （ 每个数据区块的大小 * 所有文件使用的数据区块的数量 ）


### 利用 GNU 的 parted 进行分区操作

- parted 指令支持处理各种格式的分区。是磁盘分区和分区大小调整工具


- `parted [设备文件名]`进入 parted 的交互界面；或
  - print 展示当前磁盘的分区情况
  - mklabel [ gpt,mbr,... ] 修改分区表格式为指定格式
  - mkpart创建分区
- 格式化完分区后调用`partprobe`刷新内核使用的分区表
- 修改`/etc/fstab`文件
- 调用`mount -a` 或调用`blkid`和`mount`进行手动挂载


### 小结

- 被挂载的是文件系统，而不是分区


# 第 8 章：文件与文件系统的压缩，打包与备份

RFC 1952 中有和文件压缩有关的文档

PS：略过 8.5 光盘写入工具


## Linux 系统常见的压缩指令

<center>常见的压缩文件扩展名</center>

```
.Z			compress 程序压缩的文件（已经不再流行）
.zip		zip 程序压缩的文件
.gz			gzip 程序压缩的文件
.bz2		bzip2 程序压缩的文件
.xz			xz 程序压缩的文件
.tar		tar 程序打包的数据,并没有压缩过
.tar.gz		tar 程序打包的文件,其中并且经过 gzip 的压缩
.tar.bz2	tar 程序打包的文件,其中并且经过 bzip2 的压缩
.tar.xz		tar 程序打包的文件,其中并且经过 xz 的压缩
```

zip，gzip，bz2 等压缩命令仅能对一个文件进行压缩与解压缩，所以每次压缩与解压缩都需要对一大堆文件挨个操作

为解决这个问题，推出了 tar 打包功能，tar 功能能把一堆文件打包为一个文件（也可以对目录打包）。但 tar 功能仅是提供打包功能，没有提供压缩与解压缩功能


**常见的压缩指令**

- gzip , zcat , zmore ,  zless , zgrep
  - `gzip` 压缩文件（压缩后源文件会消失）；`gzip -d` 解压缩文件（解压后源压缩文件会消失）
  - zcat , zmore ,  zless , zgrep 能读取被 gzip 压缩过的文本文件
- bzip2 , bzcat , bzless , bzgrep
  - `bzip` 压缩文件（压缩后源文件会消失）；`bzip -d` 解压缩文件（解压后源压缩文件会消失）
  - `bzip`的压缩比优于`gzip`。-k 选项会保留原始文件，不会使原始文件在压缩/解压缩后消失
- xz , xzcat , xzmore , xzless , xzgrep
  - `bzip` 压缩文件（压缩后源文件会消失）；`bzip -d` 解压缩文件（解压后源压缩文件会消失）
  - `zx`的压缩比优于`bzip`。-k 选项会保留原始文件，不会使原始文件在压缩/解压缩后消失

压缩性能上：xz > bzip2 > gzip

但压缩性能越好，通常意味着压缩或解压缩时耗时越长


## 打包指令 tar

gzip , bzip , xz 仅是对一个文件进行压缩/解压缩。虽然这些指令可以对目录进行压缩/解压缩，但实际工作原理是对目录内的所有子文件进行压缩/解压缩

tar 命令能把多个文件和目录打包成一个文件。使用上述的指令操作一个 .tar 类型的文件要比操作一个目录的效率高的多


通常对一个包含多个文件的目录（假设目录名为：directory）解压需要执行以下步骤

1. tar 命令对 directory 进行打包
2. 用压缩指令对 directory.tar 进行压缩（三种压缩指令任选一个）


而解压需要以下步骤

1. 使用解压缩指令把压缩文件解压为 directory.tar 文件
2. 执行 tar 对 directory.tar 进行解包


上述压缩和解压缩均需要两步，但使用 tar 的选项指定使用何种压缩指令就可以一步到位

```
[dmtsai@study ~]$ tar [-z|-j|-J] [cv] [-f 待新建的归档文件名] targetfilename				 <== 打包与压缩，两步并一步
[dmtsai@study ~]$ tar [-z|-j|-J] [tv] [-f 已存在的 filename.tar.xxx]	   				<== 查看文件名
[dmtsai@study ~]$ tar [-z|-j|-J] [xv] [-f 已存在的 filename.tar.xxx] [-C directory]  	<== 解压缩与解包，两步并一步

选项与参数
c : 打包并压缩
t : 查看 .tar 文件中包含了哪些文件
x : 解包并解压缩

z : 通过 gzip 进行压缩/解压缩，目标文件名后缀应为 .tar.gz
j : 通过 bzip2 进行压缩/解压缩，目标文件名后缀应为 .tar.bz2
J : 通过 xz 进行压缩/解压缩，目标文件名后缀应为 .tar.xz

v : 在压缩/解压缩的过程中,将正在处理的文件名显示出来
f : filename，-f 后接要被处理的文件名
C : 后跟目录名，指定文件被解压到的目标目录中

p(小写) : 保留备份数据的原本权限与属性,常用于备份(-c)重要的配置文件
P(大写) : 保留绝对路径,亦即允许备份数据中含有根目录存在之意
exclude=FILE : 在压缩的过程中,指定文件不进行打包（可使用占位符表示多个文件）
```

以 .tar.bz2 文件为例

```
压缩 :	tar -jcv -f filename.tar.bz2 sourcefilename
查询 : 	tar -jtv -f filename.tar.bz2
解压缩 :	tar -jxv -f filename.tar.bz2 -C directorypath
```


tar 在应用中的技巧

- 执行打包时 -p 选项会使压缩文件中的属性和权限和原文件一致（和 cp 的执行机制类似）
- 默认对文件做完压缩后，压缩包内的文件名是相对路径不是绝对路径。这是为了防止解压文件后，因为被解压的文件名是绝对路径导致文件直接放到不安全的位置，甚至是覆盖其他文件
  - 在压缩时添加 -P 选项能强制使压缩包内的文件名是绝对路径
- 仅解开单一文件的方法。例：`tar -zxv -f target.tar.gz innercontent.txt`仅提取出 innercontent.txt
- 基本名称：tarfile 是指只进行了 tar 打包，但没有压缩的 tar 文件；tarball 是指执行了 tar 打包和压缩的 tar.xxx 文件


## XFS 文件系统的备份与还原


**XFS 文件系统备份工具 xfsdump**

备份的目标只能是文件系统在目录树的挂载点所使用的目录

xfsdump 只能做 XFS 文件系统的备份。它有两种备份方式：全量备份，增量备份

- 全量备份：备份指定的文件系统中的所有内容
- 增量备份：以上一个备份（可能是全量备份，也可能是增量备份）为依据，只备份发生变化的地方


**XFS 文件系统的还原工具 xfsrestore**

通过执行 xfsdump 创建的 .dump 备份文件来恢复文件系统


## 其他常见的压缩与备份工具


**dd：复制文件并对原文件的内容进行转换和格式化处理**

```
[root@study ~]# dd if= "input file" of="output file" bs="block_ size" count="number"
```

把 input file 中的数据输出到 out file 中，可以用来做文件系统的备份，但是不推荐使用

```shell
$ dd if=/dev/vda2 of=/dev/sda1
```

上述命令会把 vda2 分区内的所有数据都备份到 sda1 中，包括 boot sector 区块，超级区块，元数据等分区内的所有数据


**cpio：用来建立、还原备份档的工具程序**

主要是用来建立或者还原备份档的工具程序，cpio 命令可以复制文件到归档包中，或者从归档包中复制文件



举个例子：把根目录下的所有数据备份到磁带中，之后通过磁带还原备份

```
备份 : find / | cpio -ocvB > /dev/st0
还原 : cpio -idvc < /dev/st0
```

cpio 需要配合 find 等命令进行工作，因为 cpio 需要输入，输入内容是需要备份的文件或目录


# 第 9 章：vim 程序编译器

## vim 功能介绍

- 文本的语法高亮提示。vim 会根据文件的后缀名，文件内开头内容去判断该文件内容而自动调用该程序的语法判断样式
- 正则表达式查找，替换文本
- 多文件编译
- 区块复制
- 恢复功能等


## vim 中的 3 种模式和快捷键

略。回头再看


## vim 的其他功能

- 缓存与恢复

场景：在 vim 中编辑文件时，vim 被不正常地关闭

结果：正在被编辑的文件没有保存，但是进入 vim 后会生成一个 .filename.swap 文件记录下你的操作

 .filename.swap 文件是在进入 vim 后被创建的，正常退出 vim 后会自动被删除；如果非正常退出，此文件会作为缓存被保存下来留作恢复上次未保存的操作的备份


- 可视区块

- 多文件编辑

- 多窗口功能（类似tmux）

- vim 的关键词补全功能


- vim 的环境设置与记录

  `~/.vimrc`保存 vim 的环境设置，`~/.viminfo`记录你曾使用 vim 做过的操作。vim 的全局设置在`/etc/vimrc`中，但不建议修改它



<center>vim 常用指令示意图</center>



## 编码问题

查看数据时出现乱码通常是因为文件编码格式和文件查看器（vim，cat 或可视化软件）的解码格式不一致

- Linux 系统默认支持的语系数据与 /etc/locale.conf 有关
- 终端的语系和 LANG，LC_ALL 这几个变量有关


终端的语系修改可尝试使用下述方式进行修改

```shell
$ LANG=en_US.UTF-8  # 或 $ LANG=zh_CN.gb18030
$ export LC_ALLL=zh_CN.gb18030
```


## 换行符

Dos/Windows 下的换行符为 CR + LF （回车 + 换行）

Unix/Linux 下的换行符为 LF

如果纯文本在不同的操作系统传递并打开或执行可能会造成错误

所以可使用`unix2dos`或`dos2unix`转换文件中的换行格式


## 转换文件的编码方式

场景：希望把一个 GBK 编码的文件修改为 UTF-8 编码的文件

解决方案：使用`iconv`指令


# 第 10 章：认识与学习 BASH


## 认识 BASH 这个 Shell

用户通过使用应用程序来控制内核，内核再控制硬件进而执行任务

Shell 将我们对应用程序下达的命令与内核沟通（先tm不要纠结 shell 和系统调用的关系和区别）

```
用 	➡	使用者界面 					➡ 	内核	➡	硬件
户	⬅	（Shell，KDE，应用程序等）	 ⬅ 	kernel ⬅  hardware
```


操作应用程序的软件都叫 shell

狭义上 shell 就是命令行方面的工具；广义上图形界面也是 shell ，因为用户能通过图形界面控制执行各种应用程序


命令行方面的 shell 有：sh，bash，nologin 等多种 shell。通常 bash 是普通用户的默认 shell


### bash 的功能

- 历史命令。bash 下可按上下键获取曾经执行过的命令，这些命令的 history 被记录在`~/.bash_history`文件中（）
- 命令与文件补全（Tab 键）
- 命令别名（alias）
- 任务管理、前台、后台控制（第 16 章 Linux 过程控制中会详细讲解）
- shell scripts（shell 脚本。shell 脚本不是 bash 的功能吧？）
- 通配符

PS：注意区别 bash 和第三方软件的命令交互界面使用的命令行工具，如：MySQL，Zookeeper，RocketMQ，Kafka 等的客户端


此外，bash 提供了很多的内置命令。可通过 type 指令查看命令是内置命令还是外置命令、 shell 脚本或可执行的二进制文件


### bash 下的快捷键

在 bash 下使用 \\ + Enter 可实现换行，因为 \\ 转义了 Enter

<center>其他常用快捷键</center>


[ ctrl ] + l 相当于 clear：清除当前终端的内容


## Shell 的变量功能


- bash 的环境变量可以用在 shell script 中
- 输出指定的环境变量可用`echo $VARNAME`或`echo ${VARNAME}`（推荐使用后者）
  - 双引号内的特殊字符如 $ 等，可以保有原本的特性
  - 单引号内的特殊字符仅为一般字符（纯文本）
- 想要永久保存自定义的环境变量，可在`~/.bashrc`中 export 变量


### 环境变量的功能

- env：打印所有环境变量
- set：打印所有环境变量和自定义变量
- export：将自定义变量转成环境变量
  - 自定义变量和环境变量的区别在于，该变量是否被子进程继续引用。因为子进程只能继承父进程的环境变量，不能继承父进程的自定义变量
  - 使用不带选项和参数的 export ：显示全部拥有导出属性的变量
- declare：将环境变量转成自定义变量


PS：环境变量 PS1 就是 bash 的命令提示符


### 读取键盘输入，数组与声明

- read：从键盘读取变量值
- declare/typeset：声明变量类型


### 控制 shell 程序的资源

- ulimit：限制用户的某些系统资源。包括可以开启的文件数量，可以使用的 CPU 时间，可以使用的内存总量等



## 命令别名与历史命令

- alias：为命令设置别名
- unalias：取消别名
- history：查看历史命令。此命令通过查询`~/.bash_history`文件获取历史命令


PS：使用 history 配合 ! 执行历史命令是很有效率的事情。比如：!vim 会执行最近的以 vim 开头的命令行


## Bash Shell 的操作环境



### 路径与命令查找顺序

执行命令时会先查找到命令后才能执行命令，下图是查找命令的顺序




### bash 的登录与欢迎信息

登录 bash 后会先看到一段欢迎提示语再出现命令提示符

欢迎提示语被保存在`/etc/issue`和`/etc/motd`文件中，通过修改这两个文件可以告知登录者一些提示信息，如服务器什么时候会被关闭


### bash 的登录流程和环境配置文件

登录 bash 后，bash 会为用户记载一些配置文件以让用户获得环境变量

bash 有两种 shell

- login shell：输入用户名和密码后进入的 bash 叫做 login shell
- non-login shell：不需要输入用户名和密码就进入的 bash 叫做 non-login shell

non-login shell 的应用很常见。比如在 bash 中执行 bash 命令，进入子进程的 bash ，这个 bash 是不需要认证就能进入，因为它是 non-login shell。再比如从桌面（如：KDE）打开的终端也不需要进行认证


**bash 的登录流程**

进入 login shell 后，bash 会先读取 bash 的全局配置文件`/etc/profile`再读取用户的 bash 配置文件

- /etc/profile 中会根据 UID 为当前 bash 动态设置环境变量，比如 USER，PATH，umask 等。还会执行 /etc/prifile.d/*.sh 文件
- 读取用户的 bash 配置文件时按以下顺序读取一个，如果能读取到就不再读取后面的文件
  - ~/.bash_profile
  - ~/.bash_login
  - ~/.profile

<center>login shell 的配置文件读取流程</center>



对于所有用户的 bash 的修改，设置，可以在 /etc/profile 中设置；对于某个用户的个性化设置可修改用户个人的 bash 配置文件


如果是 non-login shell 则只会读取 /etc/bashrc


**source：读入环境配置文件的命令**

在 bash 全局配置文件 /etc/profile ，用户的 bash 配置文件中会读取其他文件。它们会使用`source`或`.`+ 配置文件名读取配置文件

如果用户自行修改了 bash 的配置文件（包括 /etc/profile 和用户的 bash 配置文件），也可以执行 source 命令重新读取配置文件以更新 bash 环境



### 通配符与特殊符号

<center>通配符</center>


<center>bash 环境中的特殊符号</center>



## 数据流重导向



### 什么是重定向

<center>指令执行过程的数据传输情况</center>



默认，执行命令时命令需要的输入来自键盘，命令产生的输出导向屏幕

因为默认情况下，数据流的输入来自键盘，数据流的输出导向屏幕

使用`>`，`>>`可修改数据流的输出目标，使用`<`，`<<`可修改数据流的输入来源



- 标准输出可用`>`，`>>`，`1>`（`>`会为输出创建新文件或覆写已存在的文件，`>>`会为输出创建新文件或覆写已存在的文件）
- 标准错误输出可用`2>`。如果希望标准错误输出的目标和标准输出的目标一样，使用`2>&1`或`&> target`
- 黑洞设备，/dev/null。这个设备文件能吃掉任何导向这个设备的信息，就像垃圾桶一样
- 标准输入也称：stdin；标准输出也称：stdout


### 连续执行命令的判断依据

| 指令           | 执行效果                                |
| -------------- | --------------------------------------- |
| cmd1 ; cmd2    | 执行 cmd1 和 cmd2                       |
| cmd1 && cmd2   | 执行 cmd1，如果返回值为 0 就执行 cmd2   |
| cmd1 \|\| cmd2 | 执行 cmd1，如果返回值不为 0 就执行 cmd2 |


指令的返回值保存在 bash 的变量`$?`中


## 管道命令

管道的作用：接收管道符前的命令传来的标准输出的信息（不接受标准错误输出的信息）并把信息传给管道符后的管道命令

管道命令：能接收标准输入的命令。如：less，more，head，tail

<center>管道命令的处理示意图</center>



# 第 11 章：正则表达式与文件格式化处理

暂时不学


# 第 12 章：学习 shell 脚本

暂时不学



# 第 13 章：Linux 账号管理与 ACL 权限设置

Linux 账号管理与 ACL 权限设置包括

- user 和 group 的 curd
- 管理员对 user 和 group 的权限设置
- 管理员对 user 和 group 能调度的系统资源的限制
- Linux 中的系统管理员账号


## Linux 的账号与用户组

> Linux 是如何辨别每个用户的


### 用户标识符：UID 和 GID

用户标识符：Linux 根据用户的 ID 来识别用户。用户至少有两个 ID：UID，GID

- UID：用户的 ID 号
- GID：用户所属的主用户组的 ID 号

可用 `id [username]`查看指定用户/当前用户的完整 ID。用户的完整 ID 被保存在`/etc/passwd`文件中


### 用户账号

<center>用户通过 ssh 连接服务器时发生了以下流程</center>

```
1. 先找寻 etc/passwd 里面是否有你输入的账号？如果没有则跳出，如果有的话则将该账号对应的 UID 与 GID(在/ etc/group 中)读出来。另外，该账号的家目录与 shell 设定也一并读出
2. 再来则是核对密码表。Linux 进入/etc/shadow 找出对应的账号与 UID ，然后核对一下你刚刚输入的密码与里头的密码是否相符
3. 如果一切都OK的话，就进入 Shell 控管的阶段
```

由上述流程可知，用户的 UID 和 GID 保存在 /etc/passwd，用户的密码保存在 /etc/shadow

下面重点介绍这两个文件


**/etc/passwd 文件结构**

文件内容类似这样。每行数据代表一个账号（其中有很多系统内置的账号，称为系统账号），账号有多个信息/字段组成，信息/字段间用冒号分割

```
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
```

每行字数据的格式如下

```
[账号名称]:[密码]:[UID]:[GID]:[用户信息说明栏]:[家目录]:[shell]
```

PS：密码字段的值通常为`x`，真正的密码保存在 /etc/shadow 中

- UID：0—系统管理员，1\~999—系统账号，1000\~60000—可登录账号

- 系统账号的 UID 和普通的可登录账号的 UID 并没有区别，只是人为规定将系统账号和普通账号的 UID 划分到了不同的范围

  LInux 运行网络服务或后台服务仅需要较小的权限，又不希望用 root 身份启动这些服务，所以通常会为每个服务创建一个用户


**/etc/shadow 文件结构**

曾经密码直接保存在 /etc/passwd 中，但 /etc/passwd 文件必须对所有用户有 r 权限，这样不安全的。所以后来把密码单独提取到 /etc/shadow 文件中，且仅有 root 用户和 shadow 组的成员有 r 权限，root 还有 w 权限

文件内容类似这样。每行有 9 个字段，字段间用冒号分割

```
root:$6$C5mOTfRh$fPNMfEf2z12bB1tup7D1KGbvi37ClFTF5SBKQpHo1ZcBcOwHvMnWx0fKBonH1cvmKPO9RjDxDXFaI2FszuMcu/:18709:0:99999:7:::
daemon:*:18375:0:99999:7:::
bin:*:18375:0:99999:7:::
sys:*:18375:0:99999:7:::
```

每行数据的格式如下

```
[账号名称]:[密码]:[最近修改密码的日期]:[密码不可被修改的天数]:[面膜需要重新修改的天数]:[密码需要修改期限前的警告天数]:[密码过期后的账号宽限时间]:[账号失效日期]:[保留字段]
```

PS：密码字段保存的当然是被加密过的数据。当密码字段的值为 ! 或 * 时，表示密码暂时失效。新建立的用户的密码都是 ! 或 *


### 用户组：有效与初始用户组，groups，newgr


**/etc/group 文件结构**

```root:x:0:
root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
```

每行数据都表示一个组的信息，信息由多个字段构成

```
[组名]:[用户组密码]:[GID]:[此用户组支持的账号名称]
```

PS：初始用户组的用户不会加到第四个字段中，比如 root 组中第四个字段没有 root 用户，但 root 用户是 root 用户组的

- 让某个用户加到某个组里，本质上就是把这个用户添加到了指定组的第四个字段中


**有效用户组和初始用户组**

- 初始用户组：/etc/passwd 的 GID 记录的是初始用户组。用户登录系统后，立即获取这个用户组的权限
- 有效用户组：用户创建文件时，文件默认所属的用户组就是该用户的有效用户组
  - 可用过 groups 指令查询用户所属的用户组，第一个用户组就是有效用户组
  - 可以通过 newgr 指令修改有效用户组，但这个组必须是用户已经有支持的用户组。这个指令不是永久修改用户的有效用户组，它只是让用户进入了一个新的 shell 中，新的 shell 中用户的有效用户组是新的，退出这个 shell 后有效用户组恢复到旧的


## 账号管理

> curd 用户和用户组


### 用户的 add，mod，del

- useradd：创建用户。-r 选项表示创建系统用户。默认密码是失效的，是无法登录的，需要使用 passwd [username] 指令设置密码
- usermod：修改用户信息。其选项和 useradd 基本一样，不过多了 L（冻结用户） 和 U（解冻用户） 选项（它们是 lock 和 unlock 的缩写）
- userdel：删除用户。-r 选项会连同家目录一块删除

上述 3 个命令都是系统管理员才能使用的


### 普通用户能执行的功能

- id [username]：查询指定用户/当前用户的 ID
- chsh：更换登录系统时使用的 shell

### 用户组的 add，mod，del

- groupadd：创建用户组。-r 选项表示创建系统用户组
- groupmod：修改用户组信息
- groupdel：删除组。如果没有用户使用这个用户组当作初始用户组，那么这个用户组可以被删掉
- gpasswd：用户组管理功能。设置用户组管理员，用户组管理员和 root 能用 gpasswd 执行以下操作：把某位用户添加到组内或将其从组内移除


## 主机的详细权限规划：ACL 的使用

Linux 传统的权限控制是通过为文件或目录设置 owner，group，other 的 rwx 权限实现的

这种控制在某些情况下有些不够用，ACL （Access Control List）能提供更细粒度的权限控制，比如指定某用户或某组对某个文件或目录的 rwx 权限


通过`dmesg | grep -i acl`查看系统是否支持 acl，现在几乎所有的 Linux 发行版都支持 acl

- getfacl [filename]：获取某文件的 acl
- setfacl：为文件或目录设置 acl


以下是 setfacl 和 getfacl 的示例

```shell
# 单独给 user1 分配 file1 的 rw 权限
$ setfacl -m u:user1:rw file1
# 单独给 group1 分配 file2 的 rwx 权限
$ setfacl -m g:group1:rwx file2

# 有额外 acl 的文件的权限列表都有一个 +
-rw-rwxr--+  1 root root       0 Apr  4 23:20 test*

# 获取文件的 acl
$ getfacl test 
# file: test
# owner: root
# group: root
user::rw-  # 文件 owner 对文件的权限
user:cx1:rwx # 额外设置的 acl
group::r--
mask::rwx # 用户和用户组的权限范围必须在 mask 的范围内
other::r--

# 设置文件的 mask 范围
$ setfacl -m m:rw file3
```

- 此外还有 acl 的权限继承功能，设置子目录或子文件能继承上级目录的 acl 
- 删除或修改目录或文件的所有 acl 或某条 acl 记录



## 用户身份的切换

使用服务器时，通常使用普通用户，而不是 root 用户。有以下几个原因

- 防止误用 root 的命令造成问题
- 用较低权限的用户启动的系统服务相对安全。即使系统服务被攻击也不会对服务器造成影响

可使用`su [username]` +  password 切换到其他用户；可使用`sudo command`以 root 的身份执行一些命令



### su [-lm] [-c command] [username]

su 命令切换用户时，需要输入目标用户的密码（root 使用 su 时不需要输入密码）

`su [username]`命令能切换当前用户的身份，但切换用户后，没有加载新的环境变量，当前环境还是旧用户的，su 命令只不过是切换了用户身份

`su - [username]`中的 - 能以 login-shell 方式切换用户，加载新用户的环境

PS：su 命令不能切换到使用 /sbin/onlogin 这个 shell 的用户


### sudo [-b] [-u username] command

sudo 命令能暂时获取指定用户的权限执行命令，需要输入自己的密码（root 使用 sudo 时不需要输入密码），但不是所有用户都能使用 sudo 命令

只有在 /etc/sudoers 中被记录有执行 sudo 权限的用户才能执行 sudo 命令


### /etc/sudoer 和 visudo

通常通过 visudo 命令去修改 /etc/sudoer 文件。visudo 命令用于 root 用户赋予其他用户全部或部分的 root 命令功能

visudo 命令其实是通过 vi 或 nano 打开 /etc/sudoer 文件，但在退出文件后会自动检查其语法是否有问题。如果直接使用文本编辑工具打开此文件就不会有这个后置检查语法的功能

<center>/etc/sudoer 文件格式如下</center>

```
# Host alias specification

# User alias specification

# Cmnd alias specification

# User privilege specification
root    ALL=(ALL:ALL) ALL

# Members of the admin group may gain root privileges
%admin ALL=(ALL) ALL

# Allow members of group sudo to execute any command
%sudo   ALL=(ALL:ALL) ALL

[用户账号] [登录者的来源主机名称=(可切换的身份)] [可执行的命令]
```


- 给用户赋予所有 sudo 权限

  ```
  user1	ALL=(ALL)	ALL
  user2	ALL=(ALL)	NOPASSWD:ALL
  ```

  说明：user2 使用 sudo 时不需要输入自己的密码（因为配置了免密码 sudo）

- 给用户组赋予所有 sudo 权限（组内成员就均有 sudo 权限）

  ```
  group1 ALL=(ALL)	ALL
  ```

- 限制用户的 sudo 权限

  ```
  user3	ALL=(root)	!/usr/bin/passwd, !/usr/bin/passwd root, /usr/bin/passwd [A-Za-z]*
  ```

  说明：user3 只能切换到 root 用户，且不能修改 root 的密码，只能执行 passwd 命令修改非 root 用户的密码


sudo 命令注意事项

- 使用 sudo 后，用户切换用户的效果会持续 5 分钟
- 使用 sudo root 执行 su - 的效果是：不知道 root 密码的情况下把身份切换为 root，而不是个几分钟就得执行一次 sudo。这样很方便


## 用户的特殊 shell 与 PAM 模块


### 特殊的 shell，/sbin/nologin

一般系统用户是不需要登录的，这时会给这些用户设置 /sbin/nologin 这个 shell。可以用 /etc/nologin.txt 文件展示拒绝用户登录 /sbin/nologin 的提示信息

不能登录并不意味着这个用户不能调用系统资源，它们都能进行系统程序的工作，但就是无法登录主机获取交互的 shell 而已


### PAM 模块

略。PAM 是一套应用程序编程接口，它提供了一连串的验证机制。比如 登录 shell 时用的 login 程序，修改密码时用的 passwd 指令程序都使用了 PAM 模块。暂时判断 PAM 为目前不需要涉及的领域


## Linux 主机上用户信息传递

> 介绍几个比较水的指令而已


### 查询用户信息

- id：显示用户的ID以及所属群组的ID
- last：列出目前与过去登入系统的用户相关信息
- w：显示目前登入系统的用户信息
- who：显示目前登录系统的用户信息
- lastlog：显示系统中所有用户最近一次登录信息

补充几个更水的指令

- 用户对谈。登录同一个服务器的用户可进行在线聊天（只能和在线用户聊天）。write—私发消息，mesg—设置是否接收消息，wall—群发消息
- 用户邮箱。可以理解为离线聊天，把信息发到其他用户的邮箱里

## CentOS 环境下大量创建账号的方法

直接跳过。因为没有这个需求


# 第 14 章：磁盘配额（Quota）与高级文件系统管理

暂时无法没决定是否有学习高级文件系统管理的需要，所以暂时跳过。等学完其他内容后再回头来看


# 第 15 章：计划任务 （crontab）


## 两种计划任务

- 例行性的计划任务。周期性的任务，每隔一个周期就执行一次的任务教例行性计划任务
- 突发性的计划任务。只执行一次的任务，任务执行的时间和任务内容被提前设定好



计划任务工具

- crontab：执行例行性计划任务的指令工具。除此工具外也可以通过修改 /etc/crontab 文件来支持例行性任务。需要 crond 服务的支持
- at：突发性计划任务的指令工具。需要 atd 服务的支持

PS：crond 和 atd 服务在第 17 章讲



## 仅执行一次的计划任务



### atd 的启动和 atd 运行的方式

```shell
$ systemctl restart atd	# 重启 atd 服务 
$ systemctl enable atd # 设置 atd 服务开机自启
$ systemctl status atd # 查看 atd 服务的状态
● atd.service - Deferred execution scheduler
     Loaded: loaded (/lib/systemd/system/atd.service; enabled; vendor preset: enabled)	# 是否开机自启
     Active: active (running) since Tue 2021-03-23 20:02:47 CST; 1 weeks 5 days ago		# 是否正在运行中
       Docs: man:atd(8)
   Main PID: 818 (atd)
      Tasks: 1 (limit: 9450)
     Memory: 520.0K
     CGroup: /system.slice/atd.service
             └─818 /usr/sbin/atd -f

Mar 23 20:02:47 ecs-e80c-0010 systemd[1]: Starting Deferred execution scheduler...
Mar 23 20:02:47 ecs-e80c-0010 systemd[1]: Started Deferred execution scheduler.
```



**atd 的运行方式**

使用 at 指令来产生所要运作的任务，并将这个任务以文本文件的方式写入 /var/spool/at目录内，该任务便能等待 atd 这个服务的取用与执行了

为了提高安全性，at 使用黑白名单的方式限制能执行 at 指令的用户

- /etc/at.deny：黑名单。在黑名单上的人都不能执行 at
- /etc/at.allow：白名单。在白名单上的人能执行 at

PS：如果只有黑名单，则除黑名单上外的人都能执行 at；如果黑白名单都有，则白名单上的人能执行 at，黑名单上的人和没有在白名单上的人不能执行 at



### 实际运行单一计划任务



```bash
$  at now + 5 minutes	# 从现在起，5 分钟后开始执行以下任务。然后进入 at shell 编写任务内容
at> touch /tmp/atsucceed	# 创建一个文件。按回车后写下一条命令
at> <EOT>				# 按下 ctrl + d 后可退出 at shell
```

at 能设置很多格式的时间参数，请自行查文档

PS：at shell 中设置的 echo 命令，默认 echo  的输出在邮件里，而不是终端里


- `at -l`或`atq`：查询 atd 的任务列表
- `at -d [id]`或`atm [id]`：删除某个任务


PS：`batch`指令和`at`指令类似。其作用是在系统不是太繁忙时再执行定时任务；其本质是调用`at`指令执行定时任务


## 循环执行的计划任务



### 用户的设置

使用 crontab 指令建立任务后，该项任务就会被纪录到`/var/spool/cron`里，而且是以账号来作为判别。举例来说，desai 使用 crontab 后，他的工作会被纪录到`/var/spool/cron/dmtsai`里

cron执行的每一项工作都会被纪录到`/var/log/cron`文件中



- crontab 也有黑白名单（/etc/cron.allow ，/etc/cron.deny），但只需要保留一个即可

- `crontab -e`进入定时任务的编辑界面，每行表示一个定时任务。每行由 cron 表达式 + command 组成

  <center>cron 表达式</center>




```shell
# 每天十二点向 user1 发送一封邮件
0	12	*	*	*	mail user1 < /home/user2/text.txt

# 每隔 5 秒执行一次指定 sh 程序
*/5	*	*	*	*	/home/user1/hello.sh
```


### 系统的配置文件 /etc/crontab，/etc/cron.d

cron 的任务文件分布在`/var/spool/cron/`，`/etc/crontab`，`/etc/cron.d/`，`/etc/cron.xxx/`目录或文件中

crontab 指令创建的任务会被放到`/var/spool/cron`里；也可通过修改`/etc/crontab`文件来来创建任务

<center>/etc/crontab 文件结构</center>

```
SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name command to be executed
17 *    * * *   root    cd / && run-parts --report /etc/cron.hourly
25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )
```

可以看出 /etc/cron.xxx/ 中的任务执行其实都是通过 /etc/crontab 文件中的任务来执行的


- 用户个人的循环型任务用`crontab -e`来创建
- 系统维护管理的循环型任务通过修改`/etc/crontab`文件来实现
- 对于自行开发的软件，可把定时任务文件放到`/etc/crontab.d/`目录下
- 对于不重要的且需要每小时/天/周/月执行的循环型任务自行编写文件后放到`/etc/cron.hourly`，`/etc/cron.daily`，`/etc/cron.weekly`，`/etc/cron.monthly`目录下

PS：cron 会定时读取 /etc/crontab 和 /var/spool/cron/ 里的数据和文件。所以不管是用指令添加任务还是编译文件添加任务都能被及时执行


## 可唤醒停机期间的工作任务

anacron 的使用场景：服务器关机后，导致某些定时任务没有被执行。服务器开机后，anacron 会检测 anacron 定时任务，检测关机期间没有被执行的任务，然后执行这些任务


anacron 不是一个独立的服务，而是一个 crontab 中的定时任务。anacron 会被定时执行检查未被执行的任务，然后执行它

anacron 在 CentOS 中被放在 /etc/cron.hourly/0Anacron 文件中作为一个每小时执行一次的任务。任务内容为执行`/usr/sbin/anacron -s`指令


- anacron 的配置文件为 /etc/anacrontab
- anacron 的任务列表为 /var/spool/anacron

根据 anacron 配置文件的内容可知，被 anacron 管理的任务为`/etc/cron.daily`，`/etc/cron.weekly`，`/etc/cron.monthly` 下的任务

也就是说这些任务如果因系统关机而未被执行，在系统开机后 anacron 会重新执行这些任务。而 /etc/crontab 文件中未被执行的任务不会被重新执行

<center>crontab 和 anacron 的总体执行流程</center>




# 第 16 章：进程管理与 SELinux 初探

> 一个程序被加载到内存中运行时，程序在内存中的数据就被称为进程（process）
> 所有系统上面跑的程序都会以进程的形态存在
>
> 问题：
>
> - 系统的进程有哪些状态？
> - 不同的状态会如何影响系统的运作？
> - 进程之间是否可以互相控管
>
> 另外与进程有关的还有 SELinux 这个加强文件存取安全性的东西也必须要做个了解


## 什么是进程

在 Linux系统当中触发任何一个事件时，系统都会将他定义成为一个进程，并且给予这个进程一个 ID 称为 PID，同时根据触发这个进程的用户与相关属性关系，给予这个PID一组有效的权限设定。从此，这个 PID 能够在系统上面进行的操作就与这个 PID 的权限有关

### 进程与程序

操作系统只认识二进制文件。执行二进制文件时，操作系统会为其在内存中创建一个进程并赋予 PID

进程保存了根据执行者的 UID，GID 给予进程的权限信息（这些权限也将作为进程读写文件系统中文件的权限的依据），程序文件代码和参数

举个例子：bash 也是一个程序，用户登录后会进入到运行中的 bash。不同用户执行 bash 后得到的环境时不同的，比如 root 得到的 bash 进程的 User/Group 都是 root，user1 的 bash 进程的 User/Group 都是 user1

可用`ps -l`查看当前正在运行的进程


### 父子进程

在进程中触发事件，创建一个新进程。新进程被称为当前进程的子进程，当前进程是新进程的父进程。比如在 bash 进程中执行 bash 命令，进入另一个 bash 进程

```bash
$ ps -l
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0  146547  146465  0  80   0 -  2723 do_wai pts/0    00:00:00 bash
0 S     0  146651  146547  0  80   0 -  2459 do_wai pts/0    00:00:00 bash
0 R     0  146658  146651  0  80   0 -  2853 -      pts/0    00:00:00 ps
```

第一个 bash 的 PID 是第二个 bash 的 PPID（parent PID 父进程的 ID）


### fork and exce：程序调用流程

进程都会借由父进程以复制（fork）的方式产生一个模一样的子进程，然后被复制出来的子进程再以 exec 的方式来执行实际要进行的程序，最终就
成为一个子进程的存在


### 常驻在内存中的进程

常驻在内存中的进程内被称为服务（daemon）

服务大致被分为两类

- 系统服务：系统本身需要的服务。如：crond，atd 等
- 网络服务：负责网络连接的服务。如：mysqld，nginx，apache 等
  - 负责网络连接的服务会启动一个可以负责网络监听的端口，以提供外部客户端（client）的连接请求


### Linux 的多用户多任务环境

- Linux 中的进程相对独立，一个进程宕机通常不会影响服务器也宕机
- Linux 中的进程 kill 掉过一段时间后又重新出现，且 PID 是新的。可能是因为其父进程重新创建了被 kill 掉的进程。这表示进程间存在依赖。所以想完全 kill 掉进程，需要找相对独立存在的进程，比如较为顶级的父进程
- bash 环境下的任务管理（job control）：bash 下可以在执行命令是加上`&`后缀让其在后台运行（PS：最好修改输出流，防止后台程序把输出打在 bash 终端上，影响用户操作 bash）


## 任务管理


### 什么是任务管理

在单一 bash 终端下同时执行多个任务的操作管理就叫任务管理

任务管理中，每个任务都是当前 bash 进程的子进程。不同的 bash 不能干涉其他 bash 下的任务

- 可以出现提示字符（如：命令提示符）让你操作的环境称为前台
- 放到后台的任务不能接收 terminal 或 shell 的输入，也不能通过 ctrl + c 终端任务


### job control 的管理

> 在后台运行的任务有 3 种状态：已完成 Done，暂停 Stoped，运行中 Running

**1. 把命令/任务丢到后台运行**

使用方式：`command &`

执行完`&`后，会返回一个 job number 和一个 PID。这个 PID 是 command 所属的进程的 ID 号

```shell
$ ll &
[1] 148336 # job number 是 1，PID 是 148336
```


为防止后台任务的 stdout 和 stderr 打印到前台，可修改输出流

```bash
$ ll > /tmp/test.txt 2>&1 &
```


**2. 把目前前台的任务丢到后台并暂停**

使用方式：`ctrl + z`

执行完后，会返回一个 job number

```bash
$ vim /tmp/test
# 输入 ctrl + z，vim 被放到后台且被暂停
[1]+  Stopped                 vim /tmp/test
```

**3. 让在后台处于暂停的任务运行起来**

使用方式：`bg %jobnumber`（`%`可省略）

**4. 查看目前的后台任务状态**

使用方式：`jobs [-lrs]`

```bash
选项与参数
l : 除了列出 job number 与指令串之外,同时列出PID的号码
r : 仅列出正在后台运行(run)的任务
s : 仅列出正在后台当中暂停(stop)的任务
```

带有`+`的任务是最近被丢到后台的任务，带`-`的任务次之

**5. 把后台的任务放到前台**

使用方式：`fg %jobnumber`（`%`可省略）

不加 job number 的话，默认把带`+`的任务拿回前台


**6. 给进程发送信号**

使用方式：`kill -singnal %jobnumber/pid`（如果给 job 发信号，用`%`+jobnumber；如果给进程发信号，直接用 PID）

kill 命令可以细粒度控制进程，信号种类较多

```bash
# 列出所有信号名称：
$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL
 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE
 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2
13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT
17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU
25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH
29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN
35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4
39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12
47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14
51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10
55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6
59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX

# 下面是常用的信号。
# 只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略。

HUP     1    终端挂断
INT     2    中断（同 Ctrl + C）
QUIT    3    退出（同 Ctrl + \）
KILL    9    强制终止
TERM   15    终止
CONT   18    继续（与STOP相反，fg/bg命令）
STOP   19    暂停（同 Ctrl + Z）
```


### 脱机管理问题

在 bash 下使用`&`把任务放到后台运行。但退出 bash 后，这些任务就不再继续运行，因为它们是 bash 的后台任务，不是系统的后台任务。这些任务的最长生命周期就是到退出 bash 前

想要让任务在系统后台运行，可使用`nohup`指令

```shell
$ nohup [命令与参数]		# 在终端前台中执行任务
$ nohup [命令与参数] &	# 在终端后台中执行任务
```

PS：nohup 后跟的命令不能是 bash 的内置命令，因为 nohup 并没有说明任务是在 bash 这个 shell 下运行的，所以没有 bash 的环境，自然就不能用 bash 的内置命令（可用 type 指令判断命令是否是 bash 内置命令）


- pstree：以树状图的方式展现进程之间的派生关系，显示效果比较直观


## 进程管理


### 查看进程

多个查看进程的命令，如：ps，htop，top，pstree

ps（Processes Status）：报告当前系统的进程状态。ps 命令有大量选项可用，且不同版本的 ps 的选项有所差异

常用的 ps 选项如下

- ps -l：查看自己的进程（只与自己的 bash 有关的进程）
- ps aux：查看系统运行的进程
- ps axjf：进程树的进程显示

<center>ps 示例</center>

```bash
$ ps -l
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0  150487  150379  0  80   0 -  2723 do_wai pts/0    00:00:00 bash
0 R     0  150578  150487  0  80   0 -  2853 -      pts/0    00:00:00 ps
```

- F（process flags）：代表这个进程标识。4 表示此进程的权限为 root；1 表示此子进程仅进行复制 ( fork ) 而没有实际执行 ( exec )
- S（STAT）：代表这个进程的状态
  - R（Running）：程序正在运作中
  - S（Sleep）：程序处于睡眠状态（idle），但可以被唤醒（signal）
  - D：不可被唤醒的睡眠状态，通常这个进程可能在等待 IO 的情况（ex>打印）
  - T：停止状态（stop），可能是在任务控制（后台暂停）或跟踪（traced）状态
  - Z（Zombie）：僵尸状态，进程已经终止但无法被移除至内存外
- UID/PID/PPID：代表：进程被该 UID 所拥有 / 进程的 PID 号码 / 进程的父进程的 PID
- C：代表CPU使用率。单位为百分比
- PRI / NI：Priority / Nice的缩写。代表此进程被 CPU 执行的优先级，数值越小代表该进程越快被 CPU 执行
- ADDR / SZ / WCHAN：都与内存有关
  - ADDR是 kernel function，指出该进程在内存的哪个部分，如果是个 running 的进程，一般会显示 -
  - SZ 代表此进程用掉多少内存
  - WCHAN表示目前进程是否运作中。若为 - 表示正在运作中
- TTY：登入者的终端机位置，若为远程登录则使用动态终端接口（pts/n）
- TIME：使用的 CPU 时间。是此进程实际花费CPU运作的时间，而不是系统时间
- CMD：就是 command的缩写。造成此进程的触发进程的命令是什么


**产生僵尸进程的原因**：进程应该已经已经执行完毕，或是应该要终止了，但该进程的父进程却无法完整地将该进程结束掉


由 pstree 可知，所有进程都是依附在`systemd`这个进程下的。这个进程的 PID 是 1，因为它是由 Linux kernel 主动调用的第一个进程。重启 systemd 就是 reboot

PS：pstree 可以很方便地找到某个进程的父进程


### 进程的管理

进程的管理可通过信号实现。向进程发送一个信号，告诉进程去做什么事

- `kill -signal pid`：使用 pid 指定进程
- `killall -signal commandname`：通过进程的 command 字段指定进程


### 进程的执行顺序/优先级

进程的执行优先级和 Priority，Nice 的值有关。可用 ps -l 指令查看这两个字段的值

Priority 的值是内核控制和动态调整的，用户无法直接修改。但用户可以修改进程的 Nice 的值。PRO(new) = PRO(old) + nice

PRO 的值越小，进程的优先级越高，被 CPU 执行的机会越多


**nice 的取值范围**

- root 可修改所有人的进程的 nice 值，取值范围为 -20~19
- 普通用户只能修改自己的进程的 nice 值，取值范围为 0~19

**用户修改 nice 的方式**

- 执行命令之初就指定 nice 的值（nice 指令）
- 在进程运行时调整进程的 nice 的值（renice 指令 或 top/htop 指令）


```bash
# 命令执行之初就执行 nice 的值
$ nice [-n 数字] command # -n 选项后的数字就是 nice 的值
```

```bash
# 在进程运行时调整进程的 nice 的值
$ renice [number] PID # number 就是新的 nice 的值
```


### 查看系统资源信息

说几个查询内存和进程的命令

- free：显示内存的使用情况

- uname：用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）

- uptime：打印系统总共运行了多长时间和系统的平均负载

- netstat：追踪网络或 socket 文件（此命令在 Web 协议与抓包实战里有比较详细的用法）



  进程间通过 socket file 来通信。使用 socket file 通信的进程在 netstat 中的 Type 字段值为 unix

- dmesg：显示Linux系统启动信息。系统启动时，内核会去检测系统的迎接是否被识别，其记录会被保存到文件里，dmesg 命令能查看这个文件

- vmstat：显示虚拟内存状态（“Viryual Memor Statics”），但是它可以报告关于进程、内存、I/O等系统整体运行状态（详细字段见书，这里不详述）


## 特殊文件与进程


### 具有 SUID/SGID 权限的命令执行状态

以具有 SUID 权限的 passwd 命令为例。普通用户使用 passwd 命令时，在 passwd 程序内用户将临时具有 root 权限

用 pstree -uA 可知，这是因为 SUID 权限的二进制文件在运行时创建的进程会被 SUID 赋予进程 root 权限



PS：`find / -perm /6000`可查看系统中所有的 SUID/SGID 文件


### /proc/* 代表的意义

进程都在内存当中，而内存中的数据都被写在 /proc/* 目录下

/proc/ 目录下的文件主要分为两类

- 进程相关的目录。每个进程都对应一个进程目录，目录名和进程 PID 相同，目录中的文件就是进程的数据
- 和 Linux 系统相关的参数文件，如下图介绍





### 查询已使用文件或已执行进程使用的文件

- fuser：借由文件（或文件系统）找出正在使用该文件的进程
- lsof：列出被进程所使用的文件名称
- pidof：找出某个正在执行的进程的 PID


## SELinux 初探

> 在没有自行开发网络服务软件和使用其他其三方软件的情况下，建议不要关闭 SELinux

[Linux 下为何要关闭 SELinux？](https://www.zhihu.com/question/20559538?sort=created)

但是 SELinux 的权限凌驾于 root 之上，对权限进行了更细粒度的配置。配置麻烦，且安全过度，甚至可能影响管理员操作服务器（比如启动 nginx 结果无法访问本地资源，可能就是因为 SELinux 限制了 nginx 进程对本地资源的读取）

所以暂时跳过 SELinux


# 第 17 章：认识系统服务


## 什么是 daemon 与 服务（service）

> 参考博客
>
> - [init,service和systemctl的区别](https://blog.csdn.net/lineuman/article/details/52578399)
> - 


旧的 System V 开机启动服务的流程已经被淘汰（init，chkconfig，service），现使用 systemd，所以跳过 System V 开机启动服务流程不学

> systemd 是一个启动服务管理的机制
>
> 基本上 systemd 这个启动服务管理机制主要通过 一个名为 systemctl 的命令来完成的

systemd 把所有服务定义为一个服务单位（unit），systemd 把服务单位区分为多种不同的类型（type）

- service：系统服务
- socket：数据监听和数据交换的 socket 文件
- target：提供不同类似运行级别分类的操作环境（target 就是包括了很多 daemon 的集合）
- path
- snapshot：存储系统状态的快照
- timer


### systemd 使用的 unit 分类



**systemd 使用的配置文件**

- /usr/lib/systemd/system/：每个服务最主要的启动脚本设定，有点类似以前的 /etc/init.d 下的文件
- /run/systemd/system/：系统执行过程中所产生的服务脚本，这些脚本的优先序要比 /usr/lib/systemd/system/ 高
- /etc/systemd/system/：管理员依据主机系统的需求所建立的执行脚本，其实这个目录有点像以前 /etc/rc.d/rc5.d/Sxx 之类的功能，执行优先序又比 /run/systemd/system/ 高


**systemd 的 unit 类型分类说明**

/usr/lib/systemd/system/ 下的文件通过文件扩展名区分不同的类型



.service 服务最为常见


## 通过 systemctl 管理服务


### 通过 systemctl 管理单一服务（unit）的启动/开机与观察状态


```
[root@study ~]$ systemctl [command] [unit]
command主要有
start : 立刻启动后面接的unit
stop : 立刻关闭后面接的unit
restart : 立刻关闭后启动后面接的 unit，和执行 stop 再 start 是一个意思
reload : 不关闭后面接的 unit 的情况下,重载配置文件,让设定生效
enable : 设定下次开机时，后面接的 unit 会被启动
disable : 设定下次开机时，后面接的 unit 不会被启动
status : 输出这个 unit 的状态，会列出有没有正在执行、开机预设执行否、登录等信息等
is-active :目前有没有正在运作中
is-enable : 开机时会不会启动这个 unit
```

PS：执行 systemctl disbale unit 就是删除 /usr/lib/systemd/system/ 下对应的文件

```bash
$ systemctl status atd # 查看 atd 服务的状态
● atd.service - Deferred execution scheduler
     Loaded: loaded (/lib/systemd/system/atd.service; enabled; vendor preset: enabled)	# 是否开机自启
     Active: active (running) since Tue 2021-03-23 20:02:47 CST; 1 weeks 5 days ago		# 是否正在运行中
       Docs: man:atd(8)
   Main PID: 818 (atd)
      Tasks: 1 (limit: 9450)
     Memory: 520.0K
     CGroup: /system.slice/atd.service
             └─818 /usr/sbin/atd -f

Mar 23 20:02:47 ecs-e80c-0010 systemd[1]: Starting Deferred execution scheduler...
Mar 23 20:02:47 ecs-e80c-0010 systemd[1]: Started Deferred execution scheduler.
```

- Active 有以下几种状态

  - active(running)：正有一个或多个程序正在系统中运行

  - active(exited)：仅执行一次就正常结束的服务，目前并没有任何程序在系统中执行

    举例来说，开机或者是挂载时才会进行一次的 quotaon 功能。quotaon 不一直执行，只须执行一次之后就交给文件系统去自行处理。通常用 bash shell 写的小型服务大多是属于这种类型（无须常驻内存）

  - active( waiting)：正在执行当中，不过需等待其他的事件执行完才能继续处理。举例来说，打印的队列相关服务就是这种状态。虽然正在启动中，不过也需要真的有队列进来（打印作业）它才会唤醒打印机服务来进行下一步打印
    
  - Inactive：服务目前没有运行
  
- Loaded 有以下几种状态

  - enabled：daemon 将在开机时被启动
  - disabled：daemon 在开机时不会被启动
  - static：daemon 不可以自己启动，不过可能会被其他的 enabled 的服务来唤醒（相依属性的服务）
  - mask：daemon 无论如何都无法被启动。因为已经被强制注销（非删除），注销的具体方式是让此 daemon 的脚本文件变为 /dev/null。可通过 systemctl unmask 方式改回原本状态


### 通过 systemd 观察系统上的所有服务

```
systemctl [command] [--type=TYPE] [--all]
```

command 可取 list-units，list-units-files


### 通过 systemctl 管理不同的操作环境（target unit）

据几个易懂的不同的操作环境示例



暂停/挂起：将系统状态保存在内存中国，然后关闭大部分系统硬件，但实际没有关机

休眠：将系统状态保存到硬盘中，然后关机。唤醒系统时，从硬盘中读取系统状态



### 通过 systemctl 分析各服务之间的依赖性


PS：可以在这里补充前面据 的 cpus 打印服务的三个 daemon 的依赖示例

```bash
$ systemctl list-dependencies [unit] --reverse
```

systemctl list-dependencies 的作用是查找指定服务依赖于哪些其他服务，或被哪些服务所依赖


### 网络服务

网络服务：基本上，会产生一个网络监听端口的进程就可以称为网络服务

后面三节暂时跳过


# 第 18 章：认识于分析日志文件


## 什么是日志文件

日志文件通常被分类放到 /var/log/ 目录下

- /var/log/boot.log：开机时 kernel 检测与启动硬件，接下来开始各种内核支持的功能启动等。这些流程都会记录在
  var/log/boot.log里。不过这个文件只会存在这次开机启动的信息，上次开机的信息不会被保留下来
- /var/log/dmesg：记录系统在开机的时候内核检测过程所产生的各项信息。由于 CentOS 默认将开机时内核的硬件侦测过程
  取消显示，因此额外将数据记录一份在这个文件中
- /var/log/lastlog：记录系统上所有账号最近登录系统时的相关信息
- /var/log/messages：几乎系统发生的错误信息和重要信息都会记录在这个文件中
- /var/log/secure：只要涉及需要输入用户名和密码的操作都会被记录到这个文件中。如：ssh 登录，telnet 登录



日志文件可以由系统的日志文件管理服务管理，也可以由第三方软件自行处理

为防止日志文件单个文件膨胀，日志管理服务通常使用 logrotate（日志文件轮询工具）定期创建新日志文件，新的日志记录在新日志文件中，把旧日志文件保存一段时间


针对日志文件所需的功能，完整的日志文件管理服务应该有

- systemd-journald.service：最主要的信息记录者，由 systemd 提供的
- rsyslog.service：主要收集登录系统与网络等服务的信息
- logrotate：主要在进行登录文件的循环功能


## rsyslog.service：记录日志文件的服务

Linux kernel 提供 syslog 相关规范来设置日志文件服务

rsyslogd 是一个遵守 syslog 规范的 daemon，rsyslogd 为了整合到 systemd / systemctl 的管理范围内，提供了 rsyslog.service 启动服务脚本程序


### rsyslog.service 的配置文件：/etc/rsyslog.conf

rsyslogd 通过 /etc/rsyslog.conf 配置文件设置哪些服务的哪些级别的日志要被记录到哪个设备或文件中

syslog 规范把服务分为以下几类，把日志输出级别分为以下几类

<center>服务分类</center>



<center>日志输出级别划分</center>





### 日志文件的安全性设置

- 如果日志文件被手动修改过，如用户用 vim 修改过日志文件，rsyslogd 将不再向日志里写数据
- 可用 chattr 指令设置文件的隐藏权限（+a 权限，文件只能被追加数据不能被删除）
- a 权限会导致日志文件轮询无法修改旧日志文件的文件名，但可以用 logrotate 的配置文件解决这个问题


### 日志文件服务器的设置

需要使用日志文件服务的场景：多台服务器运行属于同一个系统的程序或相关联的程序，所以需要分析多台服务器上的程序产生的日志

使用日志服务器，让这些服务器的日志输出目标都指向日志服务器，只在一台日志服务器上就能分析多台服务器上的日志


搭建日志文件服务器，需要搭建服务端和客户端。rsyslogd 这个 daemon 已经提供了这些功能

- 服务端的搭建（让 rsyslogd 监听端口，变为一个网络进程）

  ```bash
  $ vim /etc/rsyslog.conf
  
  # provides UDP syslog reception
  #module(load="imudp")
  #input(type="imudp" port="514")
   
  # provides TCP syslog reception
  # module(load="imtcp")
  # input(type="imtcp" port="514")
  ```

  /etc/rsyslog.conf 提供两种协议监听端口。根据网络情况去掉注释后再用`systemctl restart rsyslogd`重启服务即可

  重启后可用`netstat -tupl | grep rsyslogd`验证服务是否变为网络服务并开始监听端口

- 客户端的搭建

  在客户端的 /etc/rsyslog.conf 文件中用`@@ip`或`@ip`指定远程日志文件服务器地址（2 个 @ 表示用 TCP，1 个 @ 表示用 UDP）


## 日志文件的轮询

系统通过 cron 的 /etc/cron.daily/logrotate 每天执行一次日志分割

logrotate 用 /etc/logrotate.conf + /etc/logrotate.d/ 下的配置文件指定要分割的日志文件，文件多大时才分割，最多保留几个日志文件，日志文件是否需要被压缩等



## systemd-journald.service 简介

systemd-journald.service 服务把日志保存在内存里

Linux 利用文件的形式把日志记录在 /run/log 中，但 /run 其实是内存中的数据，/run 并没有关联硬盘



### joutnalctl：查看日志

可使用 journalctl 指令查看 systemd-journald.service 服务记录的日志

```
[root@study ~] journalctl [-nrpf] [--since TIME] [--unitl TIME] optional
选项与参数
默认展示全部的1og内容,从旧的输出到最新的讯息
-n : 展示最近的几行
-r : 反向输出,从最新的输出到最旧的数据
-p : 展示后面所接的信息重要性排序
-f : 类似 tail，持续显示 journal 日志的内容(实时监测时相当有帮助)
```

### logger：记录日志

logger 指令可主动向 systemd-journald.service 提交日志

```
logger [-p 服务名.等级] "把这条日志提交给 systemd-journald.service"
```

### 保存日志文件

需要修改 /etc/systemd/journald.conf 的内容，并创建 /var/log/journal/ ，然后重启 systemd-journald.service 服务即可



# 第 19 章：启动流程、模块管理与 Loader

跳过

# 第 20 章：基础系统设置与备份策略

跳过

# 第 21 章：软件安装：源代码与 Tarball



## 开源源码的软件安装与升级简介



### 什么是开放代码、编译器与可执行文件

Linux 真正能识别的可执行文件是可执行的二进制程序，shell 脚本最终也是调用二进制程序进行工作

制作可执行二进制程序的流程开放代码经过编译器编译生成可执行的二进制文件


### 什么是函数库

函数库：当前系统环境提供的能被其他程序调用执行的一段功能函数


### 什么是 make 和 configure

以 C 语言程序为例，编写完 C 语言程序的源代码后，经过 gcc 编译后生成可执行文件

但程序通常有多个文件，所以可使用 make 指令简化编译过程，但 make 需要读取一个 Makefile 文本文件才能进行编译

1. 执行 configure 或 config （软件开发商提供的检测程序文件）：检查当前操作环境中是否有此程序源码需要的其他功能，如检查当前系统环境中有没有所需类库，有没有合适的编译器等。检查完毕后，若没有问题则会在程序目录下生成 Makefile 规则文件（Makefile 规定了源代码如何编译的详细信息）
2. 执行 make：make 寻找并读取 Makefile 文件后编译源代码（make 还会检查源代码是否经过变动，并自动更新执行文件）

同一个软件在不同平台上执行时，必须重新编译（这有点体现 Java 多平台下运行的意思了）


### 什么是 Tarball 软件

通俗点说就是包含有程序的被压缩过的 tar 文件，例如：*.tar.gz，\*tar.bz2 等。 Tarball 是一个软件包


### 如何安装与升级软件

基本上更新方式有两种

- 以源代码通过编译来安装和升级（手动安装）
- 以编译好的二进制程序来安装和升级（自动安装）

Red Hat 用 RPM 软件管理机制和 yum 在线更新模式；Debian 用 dpkg 软件管理机制和 APT 在线更新模式

那么一个软件的 Tarball 的基本安装流程是这样的

1. 将 Tarball 从软件开发厂商的网页下载下来
2. 解开Tarball，产生很多的源代码文件
3. 用 gcc 对源码进行编译（会产生目标文件 object files）
4. 然后用 gcc 进行函式库、主、子程序的链接，形成主要的二进制文件（binary file）
5. 把上述的 binary file 和相关的配置文件安装至自己的主机上面

上面第 3，4 步骤可用 make 指令简化，不过你就得需要至少有 gcc 和make 这两个软件


## 用 C 语言进程编译的简单范例

### 单一程序：打印 Hello World

写一个 hello.c

```c
#include<stdio.h>
int main(void){
	printf("hello world\n");
}
```

- 直接编译并执行连接，生成可执行文件

  ```bash
  $ gcc hello.c
  $ ls
  hello.c		a.out
  ```

  执行 a.out

  ```bash
  $ ./a.out
  Hello World
  ```

- 编译后再执行连接操作，生成可执行文件

  ```bash
  $ gcc -c hello.c # 只编译
  $ ls
  hello.c		a.out	 hello.o
  
  $ gcc -o hello hello.o # 执行连接并生成可执行文件
  $ ls
  hello.c		a.out	 hello.o	 hello
  ```

用 gcc 编译源程序并生成可执行文件有上述两种方式


### 主、子程序链接：子程序的编译

目标：在 hello.c 中调用 thanks.c 中的函数（上述两种方式中，第一种方式就实现不了这个需求）

写一个 thanks.c，再修改 hello.c

```c
// thanks.c
#include<stdio.h>
void thanks(void){
	printf("Thank you!\n");
}

// hello.c
#include<stdio.h>
int main(void){
	printf("hello world\n");
    thanks();
}
```

编译两个文件

```bash
$ gcc -c thanks.c hello.c # 两个文件名的顺序随便来
$ ls
thanks.c   	 hello.c	thanks.o	hello.o
```

链接两个目标文件并生成一个可执行的二进制文件

```bash
$ gcc -o hello hello.o thanks.o
$ ls
thanks.c   	 hello.c	thanks.o	hello.o		hello
```

执行 hello

```bash
$ ./hello
Hello World
Thank you!
```


### 调用外部函数库

目标：在 sin.c 中调用 math.h 中的函数

写一个 sin.c

```c
#include<stdio.h>
#include<math.h>
void main(void){
	printf("sin 3.14/2 is ");
	float value = sin(3.14/2);
	printf("%f\n", value);
}
```

编译并执行

```bash
$ gcc sin.c
$ ./a.out
sin 3.14/2 is 1.000000
```



实际上 gcc 会自动帮你找到外部函数库并执行链接，上述的`gcc sin.c`实际上等价于`gcc sin.c -lm -L/lib -L/lib64`

- 现在 Linux 默认函数库在`/lib`和`/lib64`下，所以不用 -L 显示指定也行
- Linux 默认会在`/usr/include`下找 .c 文件中 #include 需要的文件（stdio.h 和 math.h 均在 /usr/inlcude/ 下）。也可以用 -I 选项修改 include 文件的目录



补充 gcc 的其他选项

-O：优化编译，产生最佳的编译结果

-Wall：编译过程中打印警告信息



## 用 make 进行宏编译



### 为什么要用 make

make 命令能简化编译过程，直接根据 makefile 设置好的编译流程编译，链接，生成可执行文件

且能在编译前检查哪些文件时被修改过的，然后只重新编译那些被修改过的文件。这是 shell 脚本没有的功能



举例：编写一个 makefile，然后执行 make 对 hello.c 和 thanks.c 进行编译，链接并产生可执行文件

```makefile
# makefile
main: hello.o thanks.o
	gcc -o hello hello.o thanks.o
```



### makefile 的基本语法和变量

makefile 的基本语法是这样的

```
目标(target): 目标文件1 目标文件2
<tab>	gcc -o 欲建立的可执行文件名 目标文件1 目标文件2
```



- \# 是注释
- 目标(target) 类似函数，比如在安装 nginx 的时候先执行`make`再执行`make install`。install 是一个 目标（target）的名字，它对应它下面的命令
- 变量的定义和使用规则这里不详述



## Tarball 的管理与建议



### Tarball 安装的基本步骤

1. 取得原始档：将 tarball 文件在 /usr/local/src 目录下解压缩
2. 建立 makefile：以自动检测程序（configure 或 config）检查系统环境，并建立 Makefile 文件
3. 编译：以 make 这个程序并使用该目录下的 Makefile 做为他的参数配置文件，来进行 make（编译或其他）的动作
4. 安装：以 make 这个程序，并以 Makefile 这个参数配置文件，依据 install 这个目标（target）的指定来安装到正确的路径



PS：通常 ./configure 自动检测程序能接收多个参数，比如：可执行文件的安装目录，配置文件所在的目录等。 configure 会把你设定的参数写入 Makefile 文件，供 make / make install 使用



### patch 更新源代码

Tarball 更新后，可以重新下载完整的 Tarball 后解压，编译，安装。但重新安装的过程比较繁琐，且新的 Tarball 中并不是所有的文件都更新过

所以软件开发商会提供 patch 补丁文件，.path 文件配合 patch 命令就能更新源代码，仅覆盖被更新的文件而覆盖所有文件

[nginx patch补丁方式添加 nginx_upstream_check_module 模块，并测试健康检查](https://blog.csdn.net/chenshuai1993/article/details/83107769)



## 函数库管理

Linux 系统提供函数库可供软件使用，configure 检测程序也会在执行的时候检查系统环境是否提供了软件所需要的函数库

这里说的函数库通常是包含 C&C++ 的函数代码库。函数库文件通常在 /lib/ 和 /lib64/ 中 



### 动态函数库和静态函数库

**静态函数库**

- 通常是以 .a 结尾的文件
- 编译程序时，系统的静态函数库会被编译在可执行程序中。程序运行时直接调用被编译在程序内部的函数，而不需要调用系统环境提供的函数库
- 软件使用的静态函数库需要升级时，就需要重新编译软件

**动态函数库**

- 通常是以 .so 结尾的文件
- 编译程序时，动态函数库不会被编译进程序，而是会以指针的方式记录动态函数库的位置。程序通过指针来调用系统环境提供的动态函数库
- 软件使用的动态函数库需要升级时，软件无需被重新编译。只需要升级系统环境下的动态函数库文件即可，因为程序是通过指针调用的系统环境提供的动态函数库



### ldconfig 与 /etc/ld.so.conf

ldconfig 与 /etc/ld.so.conf 是用于将指定文件主动读取到内存中，可用于主动把动态函数库读到内存中，提高调用动态函数的速度


### 程序的动态函数库解析：ldd

ldd：打印程序或者库文件所依赖的共享库列表（打印程序使用了那些库函数）

```bash
$ ldd filename # filename 必须使用绝对路径
```


# 使用物理机或虚拟机后需要做的事

- 查看装置在 Linux 的 /dev 目录下的文件名
  - 以硬盘为例。虚拟机中硬盘的文件名为 /dev/vd，物理机中的硬盘名为 /dev/sd。物理机中，当硬盘被分成多个区后，如被分为 4 个区，那么 /dev/sd 的这 4 个分区槽在 Linux 系统中的设备文件名为 /dev/sd1，/dev/sd2，/dev/sd3，/dev/sd4
- 尝试使用弟弟用户（最普通的用户）cx 对在自己家目录中 root 的文件（rwx------）进行改名和删除
- 对某个文件只有 w 权限，能用 vim 修改这个文件吗 
- 对某目录只有 x 权限，没有r权限，是不是就是能cd进去但不能用ls？
- 尝试直接用 apt install 安装 mysql redis nginx 等软件，看它们是不是都是被安装到 /usr/local/ 下。通常编译源码安装软件时，configure 都可使用选项修改安装位置



**补充**

netstat：用于查询目前主机开启的网络服务端口

稍后补充 tty 0~6   6 个终端的笔记。因为 w 指令中会显示 tty 这个字段，所以还是补充一下比较好

问题：用 netstat 命令时，看到有些网络进程使用的协议是 tcp6：参考[为什么 netstat 对某些服务只显示了 tcp6 监听端口](https://www.cnblogs.com/wlzjdm/p/8684202.html)

