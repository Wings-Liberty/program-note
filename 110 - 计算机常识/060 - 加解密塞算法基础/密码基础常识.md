#还没有复习 

# 概要和知识地图


加解密防止明文被读取仅仅是密码技术的一部分

密码技术是多种技术的总称，每种技术都能为数据提供一些特性（机密性，完整性，认证，完整性，防否认等）


## 密码技术中易被混淆的名词

- 散列值 = hash = 哈希值 = 密码校验和 = 指纹 = 消息摘要


## 密码技术中的主要角色

为了在例子中更生动地描述密码技术的使用常见，定义如下存在于例子中的角色

![[../../91 - 静态资源/Pasted image 20220601224400.png]]

- 窃听者，攻击者，验证者等都可能不是人类，而是运行中的程序
- 接收者以外的其他人试图将密文还原为明文，称为 `密码破译`、`破译` 或 `密码分析`
- 进行破译的人称为破译者，破译者并不一定是坏人


## 信息安全面临的威胁与应对威胁的密码技术

场景：Alice 向 Bob 发送一封邮件

![[../../91 - 静态资源/Pasted image 20220601225231.png]]

上述邮件传输过程是不安全的，因为数据传输过程中可能存在以下问题


- Q1：被他人破译密文
- Q2：Mallory 篡改 Alice 的数据后发送给 Bob
- Q3：Mallory 伪装为 Alice 后和 Bob 通信
- Q4：Alice 不承认自己发送过的 msg


通常来说，不能防止 Eve 窃听通信内容
但即使内容被窃听也能用下列手段保证安全通信

- A1：加解密算法 = 机密性
- A2：单向散列函数 = 完整性（感知消息是否被篡改）
- A3：消息认证码 =  完整性 + 认证（检查消息发送方是不是伪装者）
- A4：数字签名 = 完整性 + 认证 + 防止事后否认

> [!NOTE] 密码技术的其他使用场景
> 除了两个人互相发送数据外的场景需要密码技术提供支持外，密码技术还可以被用在其他常见下
> 
> 比如 Alice 创建的数据，要求只能被 Alice 读取。
> 
> 这需要保证数据不能被破译，感知到数据是否被他人篡改过


信息安全所面临的威胁与用来应对这些威胁的密码技术之间的关系如下

![[../../91 - 静态资源/Pasted image 20220601231927.png]]


## 密码与信息安全常识

- 不要使用保密的密码算法
- 使用低强度的密码比不进行任何加密更危险  
- 任何密码总有一天都会被破解  
- 密码只是信息安全的一部分

**不要使用保密的密码算法**

- 密码算法的秘密早晚会公诸于世
- 开发高强度的密码算法是非常困难的

基于以上两点推出，一旦密码算法被暴露，算法将有很大概率被快速破解

所以，试图通过对密码算法本身进行保密来确保安全性的行为， 一般称为**隐蔽式安全性**。这种行为是危险的


**使用低强度的密码比不进行任何加密更危险**


**任何密码总有一天都会被破解**  


**密码只是信息安全的一部分**

通过人类的社会行为，通过偷窃，欺骗等手段也能获取到明文。这些手段和密码算法强度无关，但也是信息安全的一部分



# 加解密算法和破译方法的基本概念

本章所介绍的密码在现代都已经不再使用了，但在寻找密码弱点的方法 、破译密码的思路以及密码算法与密钥的关系等方面， 这些密码与现代的密码技术依然是相通的

## 恺撒密码

恺撒密码通过将明文中所使用的字母表按照一定的字数 “平移” 来进行加密

假设字母加密过程就是被平移 3 个字母，那么得到如下字典表

![[../../91 - 静态资源/Pasted image 20220602101506.png]]

比如："abc" 加密后变为 "DEF"

密钥就是 3

加密者和解密者都需要知道算法种类是 “凯撒算法”，密钥是 3 后才能进行加解密

## 暴力破译破解凯撒密码

暴力破译又称穷举搜索

对于凯撒密码来说，破译需要进行 26 种尝试。因为密钥的取值范围为 0~25


## 简单替换密码

“凯撒密码” 的加解密过程是对字母进行 “平移”，使得每个字母都能映射到另一个字母。但这种映射是有规律的

简单替换密码用的映射表是没有规律的，比如下图所示的字典表

![[../../91 - 静态资源/Pasted image 20220602104919.png]]

简化以后得到

![[../../91 - 静态资源/Pasted image 20220602120735.png]]

字典表的排列组合方式有 26! 种，也就是说，暴力破译要破解简单替换密码需要进行 26! 次尝试

因此，简单替换密码很难通过暴力破解来破译


> [!NOTE] 凯撒密码是简单替换密码的特殊情况


## 频率分析法破译简单替换密码

频率分析利用了明文中的字母的出现频率与密文中的字母的出现频率一致这一特性

**工作原理**

场景：假设明文是用英语写的，那么明文内容一定遵守英语语法，每个单词也一定都是现存的单词。密文采用简单替换密码加密

**工作方式**：
- 分析现有的单词库，和大量的英文文章。计算出词频数高的单词，字母频数高的字母
- 分析密文中的字母频数，把密文中字母频数高的字母替换为明文形式下英文文章中字母频数高的字母
- 分析密文中词频数，根据密文中词频数高的词出现的位置，长度等信息，尝试将其替换为合适的单词，并在这个过程中尝试确定简单密码替换的字典表


根据上述工作方式得出以下结论

- 高频字母，低频字母都能够成为破译线索
- 搞清开头和结尾能够成为线索， 搞清单词之间的分隔也能够成为线索
- 密文越长越容易破译，因为密文越长，可参考的词频，语境就越多
- 同一个字母连续出现能够成为线索（因为在简单替换密码中， 某个字母在替换表中所对应的另一个字母是固定的)


## 密钥和密钥空间

**密钥**

上述两个破译过程既是在破译明文，又是在寻找密钥

这些加解密算法是公开已知的，但需要一定的方法才能破译密文。这是因为虽然算法是已知的，但算法中用到的变量，是未知的，如果不知道这个变量就无法破译密文

- 在凯撒密码中，变量为字母平移的偏移量
- 在简单替换密码中，变量为字母替换表

这些变量就是算法的密钥。因此 加密算法 + 密钥 + 明文 = 密文，一旦知道了加密算法的种类和密钥就能破解密文，因此密钥的管理是密码技术的精髓



**密钥空间**


密钥的取值范围又称密钥空间，是密钥值的所有取值的集合，它决定了暴力破译的时间复杂度


> [!NOTE] 两种算法的密钥空间
> - 凯撒密码的密钥空间是 26
> - 简单替换密码的密钥空间是 26!

## Enigma 算法

Enigma 是能进行加解密的机器，要求发送者和接收者必须使用相同的密钥才能够完成加密通信

密钥通常被放在 `密码本` 里，密码本里记载了 `每日密码`。每日密码一天一换

设置密钥：机器根据每日密码，在接线板设置密钥

加密：在输入端（键盘）输入明文，输出端（灯泡）输出密文

解密：在输入端（键盘）输入密文，输出端（灯泡）输出明文


但实际情况下，每日密码并不作为通信密钥

通信密钥的明文 A 由人为规定，并用 Enigma + 每日密码进行加密，得到的密文 B 就是通信密钥

再次用 B 配置接线板作为加密用的密钥进行通信

![[../../91 - 静态资源/Pasted image 20220602153924.png]]


> [!NOTE] 通信密钥明文 A 需要输入两次
> A 被输入两次，再进行加密得到密文 B。如果用每日密码解密 B 后能得到一串类似 "abcabc" 的序列，说明 A 再传输过程中没有被改变
> 
> 之所以这么做是因为当时的通信质量差，这是防止发生通信错误导致通信密钥发生错位的手段


> [!NOTE] 每日密钥和通信密钥的区别
> 每日密钥每天一换，通信密钥最少每天一换
> 
> 通信密钥用于加密通信消息，每日密码仅用于加密通信密钥。每日密码一般被称为 `密钥加密密钥`
> 
> 之所以要采用两重加密，即用通信密码来加密消息，用每日密码来加密通信密码，是因为用同一个密钥所加密的密文越多，破译的线索也会越多，被破译的危险性也会相应增加

Enigma 的弱点在于
1. 及其依赖每日密码，如果密码本泄露，需要重新发放密码本
2. 通信密码的明文是人为定义的，不具有随机性


## 基于通信密钥特点破译 Enigma

Enigma 的通信密码明文需要被输入两次，根据这个特点经过数学分析后的暴力破解能破译通信密码的密文


这种方式是根据加密算法、密钥、密文的特点进行数学分析得出破译方案的分析方法


# 对称密码（ 共享密钥密码 ) 
用相同的密钥进行加密和解密


## 加解密算法中的位运算

加解密算法中常用异或运算 ⊕（没有进位的加法运算） 对明文进行运算

异或运算有如下特点

A ⊕ B = C，C ⊕ B = A

![[../../91 - 静态资源/Pasted image 20220602160821.png]]

如果把 A 当作明文，B 是密钥，C 是密文。那么让密文和密钥进行异或运算就能还原出明文。这明示了异或运算能实现对称密码对密钥能加明文也能解密密文的要求

如果 C 的选值足够好，那么 A 经过和 B 的异或运算后，C 会掩盖掉 A 的数据特征，仅用 C 很难计算出 A

当 C 是一串不可预测的随机比特序列时，认为 C 的选值是良好的。C 就是密钥


## 一次性密码本——绝对不会被破译的密码

一次性密码本是一种非常简单的密码，它的原理是 “将明文与一串随机的比特序列进行 X0R运算”

密钥长度 = 明文长度 = 密文长度


即使有运算能力无穷大的计算机，它能瞬间尝试密钥空间里的所有密钥也不能破译一次性密码本，**因为无法判断解密后的数据是不是正确的明文**


一次性密码本仅存在于理论上，实际上是不可行的，因为

- 无法保证密钥绝对安全的交换，一旦被窃取就完全失去安全性
- 密钥长度过长，难以保存，且对其压缩的效率极低
- 密钥只能被用一次，难以重复使用



> [!NOTE] 密钥不适合被压缩
> 密钥通常是随机比特序列。而压缩的原理是识别并去掉数据中重复，冗余的部分。但密钥的随机性导致它理论上没有重复，冗余的部分。如果密钥能被压缩，说明它不是一个随机的比特序列


> [!NOTE] 一次性密码本和流密码
> 一次性密码本孕育出了[[流密码和块密码#流密码的定义|流密码]]


> [!Question] Title
> 一次性密码本也属于流密码



## DES 和三重 DES
> [!WARNING] 
> 现在 DES 已经能在短时间内被暴力破解，因此除用它来解密以前的密文以外，现在我们不应该再使用 DES 了

DES 的密钥只有 64 位，密钥每次只能对 64 位的明文加密，所以明文的每  64 位称为一个 `分组`。如果明文的长度超过 64 位就需要对 DES 加密进行迭代（ 反复 ）， 而迭代的具体方式就称为 `模式`

DES 加密明文的过程就是进行若干次轮的循环，一轮表示加密的一个完整子过程，如左图表示 DES 加密的一轮


=== multi-column-start: ID_r9g4
```column-settings
Number of Columns: 2
Largest Column: standard
```

![[../../91 - 静态资源/Pasted image 20220603094851.png]]

=== end-column ===

![[../../91 - 静态资源/Pasted image 20220603095220.png]]

=== multi-column-end



DES 的加密需要 16 轮，且为保证输入的 64 比特的左右侧都能被加密，每轮都会交换左右侧的相对位置，如右图所示


> [!NOTE] Feistel 网络
> DES 中这种每轮交换左右侧的行为构成的执行流程被称为 Feistel 网络


解密过程是加密过程的逆过程，如下图所示

![[../../91 - 静态资源/Pasted image 20220603095509.png]]



> [!NOTE] 子密钥和轮函数
> 直接对数据进行加密的不是子密钥，而是子密钥经过轮函数计算后得到的局部密钥

由于 DES 已经能被暴力破解，所以发展出了三重 DES，它增强了 DES 的强度，但其处理速度不高， 而且在安全性方面也出了一些问题

![[../../91 - 静态资源/Pasted image 20220603100020.png]]

## AES 和 Rijndael

AES 是一个对称密码的标准，多个候选算法竞争后，Rijndael 被认可，并作为 AES 标准的实现，所以现在 AES = Rijndael

AES 的分组长度有多个可选项，有 128 、 192 和 256 比特三种。AES 的加解密过程需要进行 10~14轮，现在假设分组长度为 128，其加密的一轮过程如左图，解密的一轮如右图


=== multi-column-start: ID_govr
```column-settings
Number of Columns: 2
Largest Column: standard
```

![[../../91 - 静态资源/Pasted image 20220603102046.png]]

=== end-column ===

![[../../91 - 静态资源/Pasted image 20220603102122.png]]

=== multi-column-end


> [!INFO] AES 的优点
> AES（Rijndael）安全、快速，而且能够在各种平台上工作。虽然从明文到密文的计算过程可以全部用公式表达，但目前还未找到有效的攻击手段

# 分组密码的模式——分组密码是如何迭代的

DES 和 AES 都属于[[流密码和块密码#块密码的定义|分组密码]]，每次能加密数据的位数 = 密钥位数。如果需要加密任意长度的明文，就需要对分组密码进行迭代，分组密码的迭代方法就称为分组密码的 “模式”

除 ECB 外，其他模式中，每次分组加密都会参考上次分组加密的结果。这样就能保证对像 "abcabcabc..." 这种有循环特征，或某些组合重复出现的数据加密时能得到不同的加密结果


模式有很多种，主要有以下几种方式

- ECB 模式： Electronic CodeBook mode ( 电子密码本模式 ）  
- CBC 模式： Cipher Block Chaining mode ( 密码分组链接模式 ）  
- CFB 模式： Cipher FeedBack mode ( 密文反馈模式 ）  
- OFB 模式： Output FeedBack mode ( 输出反馈模式 ）  
- CTR 模式： CounTeRmode ( 计数器模式 ）

下面把 “用分组密码算法加密一个分组” 简写为 “加密”


## ECB 电子密码本模式

![[../../91 - 静态资源/Pasted image 20220603141446.png]]

当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行填充

## CBC 密码分组链接模式

![[../../91 - 静态资源/Pasted image 20220603142125.png]]

每次加密时都会随机产生一个不同的比特序列来作为初始化向量


## CFB 密文反馈模式

![[../../91 - 静态资源/Pasted image 20220603144036.png]]

CFB 模式下明文和被加密的初始化向量或密文分组会进行 xor 运算，这个一次性密码本像。其 xor 运算的结果又会参与到下一个分组的加密中，因此把 CFB 中和明文分组进行 xor 运算的比特序列称为 CFB 中的密钥流，但这个密钥流的生成依赖上次运算

在 CFB 模式中，明文数据可以被逐比特加密，因此可以将 CFB 模式看做是一种使用分组密码来实现流密码的方式


## OFB 输出反馈模式

![[../../91 - 静态资源/Pasted image 20220603145231.png]]


和之前的模式不同，OFB 模式下每次加解密依赖的密钥都可以提前准备好，这样就能并行执行多个分组的加解密，速度极快


## CTR 计数器模式

![[../../91 - 静态资源/Pasted image 20220603145429.png]]

CTR 模式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码，也能进行并行执行多个分组的加解密，速度快。和 OFB 不同的是，CTR 可以以任意顺序对分组进行加密和解密，因为每个分组用的计数器的值可直接用偏移量算出来，OFB 中每个密文分组用的密钥必须依赖上一个密文分组用的密钥

每次加密时都会生成一个不同的值（ nonce ) 来作为计数器的初始值


## 各种模式的优缺点和选型

上述几种模式中，除了加密过程中用到的密钥外，为了支持分组迭代加密又引入了 “初始化向量” 或 “计数器” 的概念，他们本质上都是一个仅用于一次加密的临时密钥

在上面几种模式中，现在仅推荐用  CBC 和 CTR

![[../../91 - 静态资源/Pasted image 20220603150016.png]]![[../../91 - 静态资源/Pasted image 20220603150041.png]]


> [!NOTE] OFB 的特点
> 在 CFB、OFB、CTR 模式中， 分组密码算法是用来生成密钥流的，因此无论是加密还是解密，分组密码算法本身执行的都是相同的操作
> 
> 但在 OFB 模式中，分组密码算法本身所实际执行的是加密操作


# 公钥密码——用公钥加密， 用私钥解密
在用对称密钥保证数据安全性时，需要让通信双方都持有此次会话的对称密钥。如果对称密钥由通信的某一方生成，并传递给另一方，就需要先保证对称密钥的传输是安全的

![[../../91 - 静态资源/Pasted image 20220603151521.png]]



## 简述对称密码的密钥配送问题及其解决方案

对称密码的难点在于密钥的安全传输，密钥安全传输方式有以下几种

- 通过事先共享密钥来解决  
- 通过密钥分配中心来解决  
- 通过 Diffie-Hellman 密钥交来解决  
• 通过公钥密码来解决


| 解决方案                | 执行流程                                                           | 缺点                                           |
| ----------------------- | ------------------------------------------------------------------ | ---------------------------------------------- |
| 事先共享密钥            | 通信双方线下传递密钥                                               | 不方便，且当通信会话变多时管理密钥的难度也变大 |
| 密钥分配中心            | 密钥分配中心生成临时会话密钥并交给通信双方                         | 密钥分配中心宕机则所有通信均不再安全           |
| Diffie-Hellman 密钥交换 | 通信前双方交换允许被窃听的信息，只有通信双方才能用这些信息生成密钥 | 稍后讨论                                       |
| 公钥密码                | 发送端用公钥加密密钥，只有接收端才能用私钥解密被加密的密钥         | 稍后讨论                                       |

## 公钥密钥对加密通信和公钥认证问题

公钥密钥对也叫非对称密钥对，包含两个不同的密钥。可用密钥对中任意一个密钥进行加密，用另一个密钥解密

使用公钥密码， Alice 向 Bob 发送消息的流程如下

![[../../91 - 静态资源/Pasted image 20220626135440.png]]


上述通信的问题在于 Alice 想和 Bob 通信，但 Alice 并不能确定收到的公钥就是 Bob 的，这叫**公钥认证**，这个问题稍后再解决

## RSA 对称加解密算法

RSA 是一种被广泛应用的公钥密码算法


### 加密
RSA 的加密公式为

```
密文 = 明文 E mod N ( RSA 加密 )
```

密文 = 明文的 E 次方结果，再对结果取 N 的模。所以 E 和 N 的组合就是公钥


### 解密

```
明文 = 密文 D mod N ( RSA 解密 )
```

当 D 足够长时，暴力破解不可能在有限时间内破解出 D


RSA 的破解难度来自于：对大整数进行质因数分解十分困难这一数学理论实时

![[../../91 - 静态资源/Pasted image 20220626140416.png]]

## 中间人攻击

Alice 想要和 Bob 通信时，攻击者夹在两者中间。攻击者伪装为 Bob 对 Alice 建立通信，同时又伪装为 Alice 对 Bob 建立通信

攻击者收到双方发送的数据时会恶意篡改内容再转发给接收方

![[../../91 - 静态资源/Pasted image 20220626141047.png]]

会产生上述的问题在于，Alice 和 Bob 想要建立通信传递通信公钥时，攻击者拦截到了这个公钥并替换为自己的公钥后交给 Alice 或 Bob。所以如果通信方收到公钥后能验证公钥是否来自于真正的对端就能防止这一问题，这叫做**公钥认证**，可以用**公钥证书**实现

# 混合密码系统 —— 用对称密码提高速度，用公钥密码保护会话密钥

## 两种密码抵御暴力破解的能力比较

具备同等抵御暴力破解强度的密钥长度比较如下图

![[../../91 - 静态资源/Pasted image 20220626141701.png]]


同等长度的密钥中，对称密码低于暴力破解的强度要比公钥密码高的多



## 公钥密码的缺点
- 公钥密码的处理速度远远低于对称密码。一般来说， 在采用具备同等机密性的密钥长度的情况下， 公钥密码的处理速度只有对称密码的几百分之一。 因此， 公钥密码并不适合用来对很长的消息内容进行加密
- 公钥密码难以抵御中间人攻击


## 混合密码加密方式

简言之，先用公钥密码作为加密密钥的手段，传输对称密码的密钥。再用对称密码作为通信信息的加密手段，加密会话中的信息

![[../../91 - 静态资源/Pasted image 20220626142214.png]]

会话密钥是为本次通信而生成的临时密钥。会话密钥是对称密码的密钥，同时也是公钥密码的明文

上述加密过程中，会话密钥和消息被不同的加密方式加密过后组合到一个密文里了。但密钥传递和消息传递其实是可以分离的，比如 HTTPS 链接


## 混合密码解密方式

简言之，接收方用私钥解密被加密的会话密钥，再用会话密钥解密被加密的通信信息

![[../../91 - 静态资源/Pasted image 20220626142652.png]]

## 搭建高强度的混合密码系统


上述混合密码系统的加解密流程中，会话密钥（也就是对称密码的密钥）由伪随机生成器生成

混合密码系统中运用了对称密码和公钥密码两种密码方式，无论其中任何一方的密钥过短，都可能遭到集中攻击， 因此对称密码和公钥密码的密钥长度必须具备同等的强度

然而，考虑到长期运用的情况，公钥密码的强度应该要高于对称密码，因为对称密码的会  
话密钥被破译只会影响本次通信的内容，而公钥密码一旦被破译，从过去到未来的（ 用相同公  
钥加密的 ）所有通信内容就都能够被破译了


接下来介绍的单向散列函数，消息认证码和数字签名均不是用来保证消息的 “机密性”，所以下面举的例子中不需要关心双方传输的数据是否进行了加解密

# 单向散列函数 —— 获取消息的“指纹”

## 单向散列函数简介

- 散列值 = hash = 哈希值 = 密码校验和 = 指纹 = 消息摘要


接收方为了校验收到的数据是否和发送方发送的数据是否一致，发送方在发送前会为数据生成 “指纹”

接收方收到数据后再生成数据的 “指纹”，对比两个指纹是否相同就能得出收发数据是否一致的结论

![[../../91 - 静态资源/Pasted image 20220626143640.png]]

为不定长数据生成定长的 “指纹” 就是 单向散列函数的工作

![[../../91 - 静态资源/Pasted image 20220626143810.png]]


> [!NOTE] 一致性也叫完整性

单向散列函数需要具备

- 能够快速计算出数据的散列值

- 具备抗碰撞性：极低概率发生碰撞（对两个不同的数据计算出的散列值是相同的概率极低）

- 弱抗碰撞性：要找到和该条消息具有相同散列值的另外一条消息是非常困难的

- 强抗碰撞性：要找到散列值相同的两条不同的消息是非常困难的。在这里， 散列值可以是任意值

- 单向性：无法通过散列值反算出消息和消息的性质/特征


![[../../91 - 静态资源/Pasted image 20220626144502.png]]



> [!NOTE] 常用的单向散列函数有
> SHA-1，SHA-2，SHA-3，MD5
> 
> SHA-1 产生的散列值长度为 160 比特
> 
> SHA-2 包含了 SHA-256、SHA-384 和 SHA512。其产生的散列值长度分别为 256、384、512比特


> [!warning] MD5 和 SHA-1 的强抗碰撞性已经被攻破
> SHA-2 还没有被攻破


## 对单项散列函数的攻击


### 冗余攻击

假设攻击者想把文件中的 “Alice 要支付的金额为 100 万元。” 改为 “Alice 要支付的金额为 1 亿元。”，又想要被修改后的文件的指纹值保持不变

攻击者会尝试这样做

- 把 “1 亿元” 用其他方式表述，比如 “一亿元”，“壹亿元”，“¥ 100,000,000”。并尝试选择能得出和原文指纹值一样的表述

- 向文件中添加人感知不到但是机器能感知到的修改。比如在文件末尾添加空格，修改字体样式，边距，段落等样式，并尝试选择能得出和原文指纹值一样的修改。这些行为可以被机器完成

这是从文档文件所具有的**冗余性**人手。 所谓文档文件的冗余性， 是指在不改变文档意思的前提下能够对文件的内容进行修改的程度

这是对弱抗碰撞性的攻击


### 生日攻击

是对单向散列函数的强抗碰撞性的攻击


> [!NOTE] 生日悖论 —— 平均每 23 个人中有两个人的生日是同一天
> 并非平均每 356+1 个人中才有两个人的生日是同一天，

利用此结论，现破解 SHA-1 仅需要不到 300 次尝试就能尝试破解其强抗碰撞性


## 单向散列函数不能解决的问题

单项散列函数能提供防止数据被篡改，保证数据完整性。但不能识别 “ 伪装”，不能识别数据是否就是真正的发送端发送的

因为函数的输入是数据，输出是指纹。这是和发送端，接收端身份无关的行为，所以不校验数据的来源是否可靠


# 消息认证码 —— 消息被正确传送了吗

消息认证码可以判断消息是否被篡改，以及是否有人伪装成发送者发送了该消息


工作原理是这样的

计算数据的消息认证码时的输入为数据和通信双方共享的密钥。密钥被期望只有正确的通信双方才会持有，所以如果通信双方成功共享到了密钥，那么攻击者就无法正确构建出数据的指纹

所以可以暂且这样理解： 消息认证码是—种与密钥相关联的单向散列函数

![[../../91 - 静态资源/Pasted image 20220626172918.png]]

## 消息认证码的密钥配送问题

消息认证码同样存在密钥配送问题，如果攻击者能获取到共享密钥，攻击者就也能伪装成发送者构建数据和数据的指纹


## 对消息认证码的攻击手段


### 重放攻击

攻击者虽然不能自行构建数据的指纹，但能窃听发送端发送的数据和指纹。攻击者把窃听到的数据保存起来并重复发送给接收端。假设数据的含义是 A 向 B 转 1 万元，接收端重复收到数据后就会重复执行这个行为


### 密钥推测攻击

攻击者即破解得到共享密钥。如果密钥是由 MD5 生成的 HMAC，那么共享密钥就有可能被破译出来


## 消息认证码不能解决的问题

消息认证码不能提供 “对第三方证明” 和 “防止否认” 功能

- 对第三方证明：无法向一个可信的第三方证明 Alice 发的消息是 Alice 发的

- 防止否认：Alice 向 Bob 发送完数据 a 后，Bob 根据 a 的内容执行某些动作，结果 Alice 立即否认给 Bob 发送过 a


# 数字签名 —— 消息到底是谁写的

数字签名是一种将相当于现实世界中的盖章、签字的功能在计算机世界中进行实现的技术

使用数字签名可以识别篡改和伪装， 还可以防止否认


以盖章类比，纸质文件上盖了 Alice 就证明文件是 Alice 签发的，因为被人没有 Alice 的章。Bob 收到 此文件后找权威机构检查这个章是不是合法的，是不是 Alice 的。如果一切都没问题，Bob 就能确认此文件确实 Alice 发的

把上述过程转为数字签名后就变成了这样：

Alice 用持有私钥（章）加密（盖章）数据并发送给 Bob，Bob 用 Alice 给的公钥（权威机构）解密（检查章合不合法）数据

对数据进行数字签名的流程如下

![[../../91 - 静态资源/Pasted image 20220626200552.png]]


其也用到了非对称密钥对，但数字签名和公钥密码不同点在于后者的公钥用于解密，私钥用于加密

![[../../91 - 静态资源/Pasted image 20220626200707.png]]




> [!NOTE] 对散列值进行数字签名
> 对全部数据进行数字签名非常耗时，因为涉及到了加密。所以通常只对数据的散列值进行数字签名
> 
> 所以有时会听到 “数字签名不对数据进行加密”，比如 JWT 用到了数字签名，但默认情况下 JWT 中的数据是明文



> [!NOTE] 数字签名别称
> 数字签名也称为电子签名， 或者简称为签名



> [!NOTE] 认证符号
> 像数字签名这样被用于代表一种只有持有该密钥的人才能够生成的信息一般被称为**认证符号**
> 
> 消息认证码也是认证符号的一种，但仅用单向散列函数生成的指纹不是认证符号

## 对数字签名的攻击方式

重放攻击，中间人攻击，对单向散列函数的攻击


此外大多针对对称密码的攻击都能攻击数字签名


### 数字签名无法解决的问题

正确使用数字签名，有一个大前提，那就是用于验证签名的公钥必须属于真正的发送者。即便数字签名算法再强大，如果你得到的公钥是伪造的，那么数字签名也会完全失效

为了验证获取到的公钥是否属于真正的发送者，需要用证书技术。需要让公钥以及数字签名技术成为一  
种社会性的基础设施，即公钥基础设施 ( Public Key Intrastructure )，简称 PKI


# 证书 —— 为公钥加上数字签名


如果不能判断自己手上的公钥是否合法，就有可能遭到中间人攻击。证书就是用来解决这个问题的

证书 = ( 公钥所有者的个人信息 + 公钥 ) + 数字签名算法 +认证机构的数字签名

生成证书的 Bob 为了让全世界知道 mypublickey 是自己公钥，Bob 把公钥交给权威认证机构 Trent，Trent 为公钥生成证书并保存起来

当 Alice 需要 Bob 的公钥时，会向 Bob 获取。Alice 为了校验得取到的 mypublickey 是否合法，Alice 向 Trent 索取 Bob 的公钥证书，根据证书里的公钥校验自己收到的公钥

![[../../91 - 静态资源/Pasted image 20220626203038.png]]


> [!NOTE] 校验从认证机构那获取到的证书
> Alice 先用 Trent 的公钥校验证书是否合法，再用证书中 Bob 的公钥和 Alice 收到的公钥做对比
> 
> CA 的公钥会直接内嵌在软件里，比如浏览器，PC 客户端

## PKI 的组成

 - 用 户 —— 使用 PKI 的人
 - 认证机构（CA） —— 颁发证书的人
 - 仓库 —— 保存证书的数据库


## 私钥丢失和证书作废

用户的私钥丢失，就相当于人丢失了章。自从 Alice 丢失章那一刻起，所有用此章盖的文件都将不能再被信任，因为这些文件的章都不再是 Alice 本人盖的

CA 需要作废证书，告诉全世界 Alice 把自己的私钥丢了。要作废证书，CA 需要制作一张证书作废清单


## 证书和 CA 的层级结构

没人能保证 CA 绝对可信，因为这个 CA 也可能是骗子公司开的。所以 CA 又需要另一个 CA 证明其合法性和可信度

CA 发布的证书也需要层层向上进行认证，最顶层的 CA 就是根 CA，根 CA 对自己颁发证书


# 密钥 —— 秘密的精华


## 密钥的价值

- 如果窃听者能够获得用于解密的密钥， 则密文的机密性就无法得到保证

- 如果攻击者能够获得用于数字签名的私钥， 就可以发动伪装攻击

密钥是发送双方身份的象征，也能用于加解密明文和密文


机密性不应该依赖于密码算法本身， 而是应该依赖于妥善保管的密钥。 这是密码学的常识

所以，密钥和明文是等价的

密钥就是一个巨大的数字或一串长的二进制比特序列。密钥空间越大，进行暴力破解就越困难。 密钥空间的大小是由密钥长度决定


## 各种用途的密钥

| 密钥分类                               | 密钥用途                                                               |
| -------------------------------------- | ---------------------------------------------------------------------- |
| 对称密钥和非对称密钥                   |                                                                        |
| 消息认证码的密钥与数字签名的密钥       | “持有合法的密钥” 就是发送者和接收者合法身份的证明                      |
| 会话密钥和主密钥                       | 每次通信只能使用一次的密钥称为会话密钥，一直被重复使用的密钥称为主密钥 |
| 用于加密内容的密钥与用于加密密钥的密钥 | CEK ( 内容加密密钥 ) ，KEK ( 密钥加密密钥 ）                           | 


会话密钥都是被作为 CEK 使用，主密钥则作为 KEK 使用

KEK 可以减少需要保管的密钥数量，比如被 KEK 加密的会话密钥通常不需要被密钥中心长久保存，会话密钥仅作为临时密钥使用

再比如，假设有 100 万个文件需要被加解密，每个文件有一个 CEK 密钥，用户就需要管理 100 万个密钥。如果这 100 万个 CEK 被当作文件，并被 KEK 加解密，用户只需要小心保管好 KEK 不被窃取即可

从管理 100 万个 CEK 不被窃取到管理 1 个 KEK 不被窃取


## 密钥的生成

密钥的生成有两种：随机数生成器生成，用口令生成密钥

用口令生成密钥通常用于人为设置某个账号的电子密码，这种人为设置的口令也叫 password，而口令通常会被加密再保存到 DB 中

口令密钥的生成通常需要把 ( 口令, 盐 ) 输入到单向散列函数或加密算法中得到散列值或密钥

这种方法称为 “基于口令的密码”


> [!NOTE] 盐是随机数，用于防止字典攻击


## 保存密钥

由于会话密钥在通信过程中仅限使用一次，因此不需要保存这种密钥。但当密钥需要重复使用时，就必须要考虑保存密钥的问题了


## 字典攻击和盐的作用

如果没有盐，用口令生成密钥的过程就变成了仅仅把 password 输入到单项散列函数

但人为设置的明文口令避免不了使用一些有意义的单词或数字组合，比如有人偏爱用某些单词或汉字拼音的拼写，这样的话，哈希值的取值范围就会缩小

攻击者会准备一些常用的词的哈希值作为字典进行暴力尝试，缩短破解时间

![[../../91 - 静态资源/Pasted image 20220627142723.png]]

如果计算哈希值时添加上随机数，就能使得哈希值的取值范围扩大，且随机数的长度越长，随机数对计算哈希值的影响就越大，就越难用字典攻击破解

![[../../91 - 静态资源/Pasted image 20220627142756.png]]





> [!NOTE] 用生日，身份证，名字作为口令是弱强度口令的表现，即使加盐也救不了把这些当密码的人


## 随机数生成器

随机数生成器产生的随机数必须具有：随机性，不可预测性，不可重现性

所以随机数产生的依据必须也是随机的，比如今天的天气，温度，湿度

这些被称为随机数生成器的 "内部状态“

软件实现的随机数生成器会接收 ”种子“ 作为初始 ”内部状态“ 来产生随机数

”种子“ 可以使用户随机定义的数字。”种子“ 可以经过加密算法，单向散列函数，线性同余法等计算产生一个随机数。每产生一个随机数后就改变 ”种子“ 使得下一个随机数变得不可预测


> [!NOTE] 种子的来源
> 种子用于产生随机数，但又希望种子的值是随机的。这和密钥不同，密钥可用随机数表示，但种子值需要人为随意赋值或收集周围环境的随机信息产生

# PGP —— 密码技术的完美组合

简言之，PGP 是密码学工具箱的软件实现，提供了完善的密码学工具，比如

- 对称密码，非对称密码的加解密
- 数字签名，消息认证码的签名和认证
- 密钥的生成和管理
- ...


# SSL/TLS —— 为了更安全的通信

SSL/TLS 作为计算机网络协议，提供网络数据的安全传输工作

SSL/TLS 之上能承载各种应用层协议，可以为 HTTP，SMTP，POP3，FTP 等协议提供安全的数据传输功能

其工作方式为：SSL/TLS 提供了一种密码通信的框架，在正式通信前，通信双方先协商好通信时使用的密码学组件

比如用哪种对称加密算法，非对称加密算法，密钥交换方式等

且 SSL/TLS 就像事先搭配好的盒饭一样， 规定了一些密码技术的 “推荐套餐”， 这种推荐套餐称为**密码套件**

![[../../91 - 静态资源/Pasted image 20220627151641.png]]




# 第十一章

- 单向散列函数也被用于基于口令的加密（ Password Based Encryption, PBE )。  
PBE 的原理是将口令和盐（ salt, 通过伪随机数生成器产生的随机值 ） 混合后计算其散列  
值， 然后将这个散列值用作加密的密钥。 通过这样的方法能够防御针对口令的字典攻击， 详细  
内容我们将在第 11 章中介绍

- 数字签名的处理比较耗时，一般不对整个消息内容进行数字签名，而是对单向散列函数计算出的散列值进行数字签名

- 伪随机数生成器可以根据单项散列函数的不可预测性生成

- 数字签名也可以加上消息有效期，公钥的证书上就有这个信息

# 第一章
- 密钥：是一串字符串。即使保险箱再坚固， 如果钥匙被盗， 则里面的贵重物品也会被盗。所以密钥 = 明文，但是密钥长度 < 明文。所以 密钥 ≈ 压缩明文
- 对称密码；公钥密码 = 非对称密码；混合密码系统 = 对称密码 + 公钥密码
- 密码技术 => 机密性 + 完整性 + 认证
- 散列值 = hash = 哈希值 = 密码校验和 = 指纹 = 消息摘要
- 伪随机数生成器在密码技术中用于生成密钥


# 名词纠正

记录一些容易被混淆或误解的专业名词

**口令**

门户网站或应用程序中，用户登录时，要求用户输入的信息。账号和 “密码“ 都是口令的一部分。口令是身份认证的凭据，口令的英译：password，passcode，pin。口令和密码不是一个意思

**密码**

本书中的密码是安全传送消息的方法，密码的英译是：cryptography

涉及信息的安全性，完整性，认证等多方面的技术。这个技术能提供包括但不限于以下功能

-   “密码” 可以让窃听者无法解读窃取的消息
-   “单向散列函数” 可以检测出消息是否被篡改过
-   “数字签名” 可以确认消息是否来自合法的发送者



**哈希值**

散列值（ hash )又称哈希值、 密码校验和（ cryptographic checksum )、 指纹（ fingerprint )、 消息摘要（ message digest )

**消息认证码**

也叫 MAC

注意对称加密中密钥的安全性传递

一次性密码本最致命的缺点就是对称加密最致命的缺点：不能保证密钥被安全传输

一次性密码本发展出了流密码，流密码是对称加密算法的一种

[流加密_百度百科](https://baike.baidu.com/item/%E6%B5%81%E5%8A%A0%E5%AF%86/15537830?fr=aladdin)

<aside> 🤔 了解一下密码学的应用场景

-   比如 HTTPS 的 TLS / SSL 用的加密算法，模式，分组长度都有哪些。在建立安全链接时为什么不仅仅是协商好加密算法就行了，还需要证书，比如开发者需要生成证书，进行数字签名
-   还有其他应用层协议是这么用的密码学，比如安全的 SSH，WSS
-   应用程序中哪些场景用哪些算法比较合适？比如即时通讯的聊天记录是不是每个会话都有一个加密算法，模式，分组长度，密钥。如果用户换手机了是不是需要更新算法等。JWT 这是怎么用密码学的？JWT 的超类是怎么用密码学的？
-   密码学除了在应用层有应用外，在其他层是否也有应用

</aside>

-   问题：CFB 末尾提到的重放攻击会出现在其他模式中吗？


# TLS 的密码学初探

-   密钥生成算法（上述的 ECDHE 就是一种，用来生成加密算法用的密钥。之前的笔记是这样的：“• 客户端与服务器通过交换部分信息，各自独立生成最终一致的密钥”）
-   密钥交换用的非对称加密算法
-   通信用的对称加密算法
    -   对称加密算法的分组长度
    -   对称加密算法用的模式
-   哈希算法（暂时不知道这里的哈希算法是干什么用的？猜测是用来做数字签名的，提供防篡改，防否认，校验完整性三大功能），MAC 是消息认证码的意思

加密算法是公开且固定的，密钥作为加密算法中的变量，为加密算法提供了难以破解的依据

<aside> 🤔 有时间的话，再弄清楚证书是啥？比如 Wirshark 需要配置 chrome 的证书后才能对浏览器中的 HTTPS 加密报文进行解密。获取手机软件里的证书后并配给 Wirshark 后才能抓手机的包 还有一个问题，为啥获取 chrome 浏览器自身的证书就能破译所有网站的加密流量，而不是获取每个网站的？是因为 HTTPS 的密钥是由站点指定，但是由浏览器生成的吗？

</aside>

# 非对称加密

明文 → 密文（加密函数）

密文 → 明文（解密函数）

前提：加解密算法是公开已知的，加密函数的参数是公钥，是公开的。解密函数的参数是私钥，是非公开的

安全性主要取决于已知加密函数的参数，求出解密函数的参数的难度是否很大

# 对消息认证码的疑问

书上说消息认证码 = 对消息和共享密钥进行 hash 计算 = MAC 指纹

为了防止伪装者伪装发送者，这个共享密钥必须保证被安全地发送给接收端

-   问题：共享密钥由发送者生成，那伪装者不也能自行生成共享密钥后和接收者通信吗？这样接收者也知道消息确实来自与通信发起人（虽然通信发起人是伪装者伪装的发送者）
    
    答：确实伪装者也能。所以消息确认码不能保证上述功能，上述的行为即向他人证明，消息和 MAC 确实都是真正的发送者发送的，不是伪装者干的，**这叫“第三方证明”，数字签名才能做到这点（见本书的 8.7.1）**
    
-   问题：上述用到的共享密钥貌似不是用于通信的对称密钥或用于传递密钥用的非对称密钥中的公钥。那它是哪个密钥
    
    答：这个密钥是伪随机数生成器专门为消息认证码生成的
    

经过上述两个问题的解答，得出结论

消息认证码的认证作用是：保证本次通信中，消息均只会在两个人（或机器）之间发送，不会有中间者（前提是为消息认证码添加了防止重放攻击的措施）。就像第八章的标题一样：消息认证码——消息被正确传送了吗？（所以本书的标题是非常严谨的，而不仅仅是为了生动有趣才编出的容易理解的文字）

# 数字签名

在 9.3.3 节中介绍的数字签名有点这种意思

Alice 为了证明某条消息是自己发的，Alice 会把解密密钥公开，如果消息能被公开的解密密钥解密，那么说明消息就是 Alice 发的，因为只有 Alice 才有加密用的私钥

实际上，书上也是这么说的，“数字签名就是把公钥密码反过来用”

但因为数字签名把解密密钥公开了，所以数字签名常用来传递那些可对外暴露的信息，且能保证信息完整，不被篡改，信息来源一定是进行数字签名的一方（即能证明信息是由声明发送信息的一方确实就是发送方），所以数字签名在 TLS 中由于传递非对称加密的公钥，并证明 HTTPS 协议和站点的合法性

数字签名中，加密密钥是私钥，解密密钥是公钥。这和公钥密码刚好相反

同时也得到结论：非对称密钥对中，两个密钥因为存在严格的数学关系，所以只能由一方加密，另一方解密。但并没有规定执行加密的必须是公钥，解密的必须是私钥。公私钥的定义仅取决于密钥是否被公开了。

> 客户端证书是啥

# 证书

公钥证书 = 公钥 + 公钥所属者信息 + CA 的数字签名

公钥证书用于证明这个公钥确实属于证书上这个人的



> [!todo] ssh 无密码登录配置实践
> [ssh 无密码登录配置实践](F:\编程资料\尚硅谷\hadoop\笔记（word版本）\02_尚硅谷大数据技术之Hadoop（入门）V3.3.docx)
