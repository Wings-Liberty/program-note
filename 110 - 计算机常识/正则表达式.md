#还没有复习 

以 Linux 的 grep 命令讲解正则表达式的应用


正则表达式用于检测文本是否符合指定的格式

举个例子

```bash
ls /usr/bin | grep zip
```

查询 /user/bin 里有没有包含 zip 的文本行

如果希望写一个更复杂的匹配式，需要借助元字符的帮助



# 正则表达式的基本元字符

**原义字符**就是能**表达字符本身字面量**值的字符

除了原义字符之外，正则表达式也可能包含**元字符**，**表示特殊含义**，被用来指定更复杂的匹配项

正则表达式元字符由以下字符组成

```
^ $ . [ ] { } - ? * + ( ) | \
```


## 匹配指定字面量文本行


```bash
ls /usr/bin | grep zip
```

查询 /user/bin 里有没有包含 `zip` 的文本行



## 匹配一个任意字符

```bash
ls /usr/bin | grep '.zip'
```

`.`表示任意一个字符，`.zip` 表示四个字符，第一个字符可是任意字符，后面 3 个字符是 `zip`

文本行中包含这 4 个字符格式的会被匹配上


## 匹配以指定字符串为开头或结尾的字符串

```bash
ls /usr/bin | grep '^zip'
```

查询 /user/bin 里以 `zip` 开头的文本行


```bash
ls /usr/bin | grep 'zip$'
```

查询 /user/bin 里以 `zip` 结尾的文本行



## anyMatch 匹配和 anyNotMatch 匹配

```bash
ls /usr/bin | grep '[bg]zip'
```

查询 /user/bin 里有没有这样的 4 个连续字符，第一个字符是 `b` 或 `g`，后面 3 个字符是 `zip`

`[]` 表示一个集合，如果源字符串中某个字符出现在 `[]` 的集合里，就匹配上了 `[]`


`[^]` 表示一个集合，如果源字符串中某个字符没有出现在 `[^]` 的集合里，就匹配上了 `[^]`


## 中括号表达式常用字符集

`[]` 可以写**多个字符**，写字符取值范围，也可以写**字符集符号**

字符集也叫 POSIX 字符集

- 多个字符的写法。`[qwer]`，表示字符可以取 `q` 或 `w` 或 `e` 或 `r`
- 字符取值范围写法。`0-9`，表示字符可以取 0 到 9 任意一个
- POSIX 字符集写法。如下

![[../91 - 静态资源/Pasted image 20220910161002.png]]
![[../91 - 静态资源/Pasted image 20220910161021.png]]


# BRE 和 ERE

POSIX 把正则表达式的实现分成了两类

- 基本正则表达式（BRE）
- 扩展的正则表达式（ERE）

这两种表达式的共同点在于这些元字符的用法相同

```
^ $ . [ ] - *
```


不同点在于 BRE 不能辨别以下元字符

```
{ } ? + ( ) |
```

- 在 BRE 中，这些字符默认情况下被视为原义字符，被视为字面量值
- 在 ERE 中，这些字符默认情况下被视为正则元字符，被视为正则表达式能表示格式的字符


在 BRE 中，字符 `(`，`)`，`{`，和 `}` 用反斜杠转义后，被看作是元字符
在 ERE 中，如果希望这些字符能被视为原义字符，就在这些字符加上反斜杠转义

在 grep 命令上，默认使用 BRE，`-E` 表示切换为 ERE 模式


## anyRegexMatch 匹配


```bash
ls /usr/bin | grep -E 'regex1|regex2|regex3'
```

查询 /user/bin 里有没有符合 `regex1` 或 `regex2` 或 `regex3`

只要符合其中任意一个就判定为符合正则表达式

但为了让 `|` 和其它正则表达式元素结合起来，可以使用 `()` 来分离

```bash
ls /usr/bin | grep -E '(bz|gz|zip)$'
```

表示查询以 `bz` 结尾或以 `gz` 结尾或以 `zip` 结尾的文本行。和 `[]` 的区别在于，前者的作用单位是若干个正则表达式，后者的作用单位是一个字符

## 限定符


扩展的正则表达式支持几种方法，来指定一个元素被匹配的次数

- `?` 匹配零个或一个元素
- `*` 匹配零个或多个元素
- `+` 匹配一个或多个元素
- `{}` 匹配特定个数的元素，有以下四种写方式

![[../91 - 静态资源/Pasted image 20220910162941.png]]
![[../91 - 静态资源/Pasted image 20220910162955.png]]


# 正则拓展用法


以上用法均是正则的基本用法，但上级程序实际应用正则时，仅仅提供上述功能的正则根本不够打

上级程序通常希望用正则表达式做这些事

- 判断字符串是否**完全匹配**正则
- 判断字符串是否**包含**正则中指定的字符串
- 用正则提取字符串中的有效信息，比如从日志中分别提取 IP，port，时间等


下面介绍进阶用法


## 正则表达式的选项

虽然 grep 命令有提供 i, g, l 等选项，但这些选项不全是正则的选项。正则的选项是下main这些

- g：global 全局搜索，否则匹配到一个子字符串后就不再匹配
- i：ignore case 大小写不敏感
- m：mutiline 默认情况下，`^`，`$` 会针对整个字符串，开启 m 后，`^`，`$` 会针对字符串的每行匹配。这可以针对字符串中的 `\n ` 做特殊处理
- s：dotall（没理解）
- u：unicode（没理解）
- y：sticky（没理解）


## 字符集简写

之前提到的字符集写法都是 `[:xxx:]` 有些复杂，一下是简写方式

|    字符集     | 完整写法  | 简单写法 |             说明             |
|:-------------:|:---------:|:--------:|:----------------------------:|
|     word      | [:word:]  |   \\w    |      等价于[A-Za-z0-9_]      |
|   not word    |           |   \\W    |    等价于 [\^A-Za-z0-9\_]    |
|     digit     | [:digit:] |   \\d    |         等价于 [0-9]         |
|   not digit   |           |   \\D    |        等价于 [\^0-9]        |
|   whitspace   | [:space:] |   \\s    | 表示一个空格，tab 或回车换行 |
| not whitspace | [:space:] |   \\S    |       和上一项刚好相反       |

还有和 unicode 相关的字符集 `\p{L}`，`\P{L}`，`\p{Han}`，`\P{Han}`


## Anchors - 边界字符值匹配

之前聊过 `^` 匹配以某个字符开头的**字符串**。`$` 匹配以某个字符结尾的**字符串**

现在聊 `\b` 匹配以某个字符结尾的**单词**，`\B` 匹配以某个字符开头的**单词**


`\b` 会匹配一个 [:word:] 字符和一个非 [:word:] 字符或整个字符串的开头或末尾中一个单词的边界位置

简单地说，`\b` 会匹配字符串中所有单词的最后一个字符是否是指定值，举个例子

![[../91 - 静态资源/Pasted image 20220924190650.png]]

正则是 `s\b`，字符串是 `she sells seashells`

结果匹配到了两个以 s 为结尾的单词中 s 的位置


`\B` 刚好相反，匹配的是以某个单词为开头的单词中字符的位置

![[../91 - 静态资源/Pasted image 20220924190916.png]]

## Groups & References - 捕获组和非捕获组

上级程序经常希望用正则从一个字符串中**提取出部分有用的信息**，而不仅仅是判断一个字符串是否和正则完全匹配

简单来说就是

1. 在正则里声明一个变量
2. 给变量赋予一个正则
3. 如果字符串匹配正则过程中有符合变量正则的子字符串，**变量的值就被赋予为子字符串的字面值**供上级程序获取


### 捕获组

所谓的捕获组就是[[正则表达式#anyRegexMatch 匹配|`(` 和 `)` 元字符]]

**命名捕获组**

就是给捕获组声明一个变量名，语法是 `(?<name>regex)`，name 就是 “变量名”



> [!warning] 不是所有的浏览器和正则工具都支持命名捕获组的
> 这个[正则工具网站](https://regexr.com/)可以识别，但 UTool 的 regex 插件就不能识别命名捕获组


### 捕获组引用

正则里可能用到了多个捕获组，比如正则里写了 5 个捕获组，后面又想用第 2 个捕获组

可以不用重新写一遍第二个捕获组正则，而是用捕获组的序号代替捕获组

PS：对，不是用捕获组的名字，而是用序号作为引用。序号从 1 开始计数

举个例子：正则 `(\w)a\1` 表示的是 `字符a字符`

![[../91 - 静态资源/Pasted image 20220924223545.png]]

所以字符串中 `字符a字符` 都会被匹配到

### 非捕获组

提一个需求，把  `hahaha haa hah!` 中所有连续的 `ha` 找出来

期望的结果是这样的

![[../91 - 静态资源/Pasted image 20220924224220.png]]

一开始发现有 3 个连续的 `ha`，**将其视为一个匹配项**，后续又找到两个不连续的 `ha`，视为两个匹配项

而不是把每个 `ha` 作为一个独立的匹配项，我们不期望得到下面这样的结果

![[../91 - 静态资源/Pasted image 20220924224410.png]]

这个结果把前三个 `ha` 当作了 3 个独立的匹配项，这是不被期望的

如果要实现这样的效果，需要把正则写为 `(ha)+`

也能写为 `(?:ha)+`，这种写法叫非捕获组

捕获组和非捕获组当的区别可以[参考这里](https://benearyou.com/regular-expression-non-capturing-group/)


## Lookaround - 对匹配项掐头去尾

来了这样一些需求，给了一个字符串

```
1pt 2px 3em 4px
```

需求 1

- 我希望能提取出所有单位为 px 的值，且只取数字，舍弃 'px' 这两个字符
- 相反，这次我希望取出所有单位为非 px 的值，也是只要数字，不要单位的字符字面值


再来个例子

```java
int a; int b; String c; double d; int ef;
```

需求 2

- 我希望取出所有 int 类型的变量名
- 相反，我希望取出非 int 类型的变量名


上述 4 中需求都是在说我要取出符合正则的字串，但我想把取出的结果掐头或去尾

需求 1 的答案是 `\d(?=px)`，`\d(?!px)`

需求 2 的答案是 `(?<=int\s)\w+`，最后一个答案有待进一步研究



## Substitution - 如何取出匹配到的结果

上级程序不光需要知道字符串是否完全匹配正则，有时还需要知道匹配结果

### 获取匹配到的所有项

`$&` 遍历取出所有匹配到的项，然后以字符串直接拼接方式输出结果


如果我想**得到** int 类型变量的变量名，而不是检查字符串和正则是不是完全匹配或匹配到的项有几个

![[../91 - 静态资源/Pasted image 20220924232742.png]]

用 `$&` 去到匹配项后加一个换行符，以此为一个单位遍历所有匹配项并拼接到一个字符串中输出

就会得到上图结果，一个匹配项 + 一个回车换行这种格式不断重复，直到获取到所有匹配结果


### 获取到指定组的匹配项

用 `$数字` 方式获取所有组的匹配项并遍历，追加到一个字符串里后输出


### 获取未被匹配到的字符串

```
$`
```

用上述方式获取到所有未被匹配到的字符串然后拼接到一个字符串里输出出来

![[../91 - 静态资源/Pasted image 20220924233512.png]]

# 实战

- 写一个 IPv4 地址的正则，[参考这里](https://www.cnblogs.com/zhongbokun/p/8878456.html)

```regex
((25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d)))\.){3}(25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d)))
```

- 项目里对正则的使用参考 syslog 日志流转全过程