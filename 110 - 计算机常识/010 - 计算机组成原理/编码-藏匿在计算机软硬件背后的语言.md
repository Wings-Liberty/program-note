#还没有复习 

> 记笔记方式：每看一章或一个很重要/很有意思的部分，就用一段自己的话去概括描述。而不是和记知识点一样的方式尽可能详细记录每个知识点，关键字。重在体会，而不是具体的知识点



# 作者序

前提：计算机有与生俱来的层次化体系结构

本书的目的在于以自底向上的方式讲述计算机是怎么工作的



# 第 1 部分：编码

编码是把一种格式的信息转换为另一种格式的信息的过程



# 第 2 部分：编码与组合

以莫尔斯码为例解释编码与组合

莫尔斯码用“点”和“划”作为编码字符，用莫尔斯码编码的过程就是根据一张“表”把原信息的每一个字符编码为一串“点”和“划”

1 位莫尔斯码能组合出 2<sup>1</sup> 个码字；2 位莫尔斯码能组合出 2<sup>2</sup> 个码字；3 位莫尔斯码能组合出 2<sup>3</sup> 个码字

所以莫尔斯码也叫二进制码



# 第 3 部分：根据布莱叶盲文和二进制码归纳编码的性质

根据布莱叶盲文得到的二进制码的性质：

在“单一的”编码格式中，n 位二进制编码能有出 2<sup>n</sup> 组合，每种组合仅表示一个字符

在使用了“逃逸码”和“换挡码”的编码体系中，每种组合能表示多种字符，这意味这 n 位二进制编码能表示的字符种类可以远多于 2<sup>n</sup> 种



PS：举一个换挡码的例子。一串二进制组合表示字母大写换挡码，紧跟其后的多组二进制组合将被译为大写字母，直到大写换挡码能表示的范围结束。前面没有字母大写换挡码的编码则被译为小写字母。这表示一个组合可以至少有 2 种含义



# 第 4 部分：手电筒的剖析

闭合电路中，电压/电势差导致电子流动形成电流



# 第 5 部分：绕过拐角的通信

用长导线+开关+灯，可实现简易的传递二进制信息的远程通信



# 第 6 部分：电报机和继电器

电报机用和第 5 部分类似的原理实现传递二进制信息的远程通信，由于导线过长导致电阻过大通信距离被限制，所以配合继电器实现信号/信息的转发进而实现更远程的通信

PS：继电器由通电线圈据有磁性的原理实现



# 第 7~9 部分：二进制的简单应用

相对于其他进制，二进制表示简单，算数运算规则简单，同时又非常适合做逻辑运算

商店里包装袋上的条形码就是二进制的一个非常优秀的应用



# 第 10 部分：逻辑与开关

> 10~11 部分讲逻辑运算

布尔代数的逻辑运算（把传统代数中的“数”抽象出来，称其为类，也可称为集合）。以下每组运算符的含义均相同

- 交集，并集
- ×，+
- AND，OR
- ∧，∨
- ∩，∪
- &，|

此外还有两个关键的概念：全集和空集

==> 布尔代数就是逻辑运算法则，它为逻辑电路提供了夯实的理论基础



# 第 11 部分：门

逻辑门简称门。它是布尔代数的理论实现和实际实现

**简单的逻辑门**

- 与门（输入端全为  1，输出端才为 1）简称 AND
- 或门（输入端有一个 1，输出端就为 1）简称 OR

**相反器**

非门/相反器（输入和输出相反）

严格来说非门/相反器不是逻辑门。因为逻辑门泛指有多个输入的门

**译码器**

由若干与门和相反器组成的使 n 个开关实现 2<sup>n</sup> 种输出结果的结构称为译码器。称为 “n-2<sup>n</sup> 译码器”

**拓展的逻辑门**

其本质是简单逻辑门组合出的工具，可有可无，但其存在能简化开发

- 与非门（输出全全为 1，输入端才为 0）简称 NAND
  - 本质 = 与门 + 相反器。其输出效果和与门完全相反，因此命名为与“非”门
- 或非门（输出端只要有一个 1，输出端就为 0）简称 NOR
  - 本质 = 或门 + 相反器。其输出效果和或门完全相反，因此命名为或“非”门

**缓冲器**

本质是继电器。其功能是方法信号，副作用是延迟信号的传输

**小结**

- 4 个逻辑门和 1 个相反器就是最基础的工具。加上译码器等复杂电路工具就能构建出更复杂的电路
- 异或门（两个输入不同，输出为 1，两个输入相同，输出为 0）简称 XOR。和异或门相反的是“同或门”
- 摩根定理：两个逻辑运算的等式，是一种有效简化布尔表达式的手段



# 第 12 部分：二进制加法器

> 12~13 部分讲算术运算

目标：做一个能计算 2 个 8 位二进制的加法器。其中涉及半加器和全加器电路组件的搭建



理论：在一串二进制数相加过程中，2 个同位的 bit 数相加的全貌是：2 个 bit 加上一位的进位 bit 结果，得到一个两位结果



- 半加器：仅接收 2 个 bit 数的输入，输出 2 个 bit 数。但是不能接收上位的进位结果作为输入（没能把上次加法可能产生的进位位纳入下次运算）
- 全加器：能做到上述完整的 3 个 bit 数的运算。理论上可用 3 个半加器构建，但考虑所有可能性后，第 3 个半加器可用一个或门替代（节省电路元件）



# 第 13 部分：如何实现减法

减法的借位机制让计算变得困难，通过巧妙的方法能消除借位机制。但代价就是需要对被减数大于减数和被减数小于减数两种情况分类计算（**书中仅实现了前者**）

上述减法法则中会用到补数。（补数：在二进制中也叫相反数，反码）计算补数需要用相反器



上述的 8位全加器中，输入为两个 8 bit 数，输出为 9 bit。这是因为存在最高位（第 8 位）相加可能会进位。将其称为上溢（**overflow**）

减法中存在计算结果是正数或负数，将结果是负数的计算结果称为下溢（**underflow**）



**负数的表示方式**

- 用最前面一位表示正负号。0 表示整数，1 表示负数。比较 low，且不好用
- 另一种方式：补码。不仅能解决负数的表示问题，还能够轻松实现正负数相加。缺点是必须提前知道可能遇到的所有数字的位数

即补码的目的是：通过把负数用补码形式表示，把减法运算转换为加法运算



对补码的举例。用补码表示 -500~499

```
原码	-500, -499, -498, ... , -4,   -3,  -2,  -1,   0,   1,   2,   3,   4, ... , 497, 498, 499
---------------------------------------------------------------------------------------------
补码   500,  501,  502, ... , 996, 997, 998, 999, 000, 001, 002, 003, 004, ... , 497, 498, 499
```

这就形成了循环排序。原码中 -1 + 1 = 0，补码中 999 + 1 = 1000，舍去上溢位后，得 0

补码的计算中，如果两个操作数的符号位相同，但结果的符号位不同，则结果是无效的（因为发生了溢出——上溢或下溢）



PS：包括 Java 在内的多种高级编程语言，有符号的数在计算机中均以补码形式表示



总结：使用补码技术后。做减法的本质就是：对减数进行取补码后和被加数**相加**。所以还是做加法😄



# 第 14 部分：反馈与触发器

> 一个有记忆的电路需要有触发器

**电路元件**

- 振荡器（在红石电路中也叫频闪器😅）能主动规律的周期性改变输出状态，但改变状态是需要一点点时间的
- 时钟。振荡器又被称为时钟。振荡器的频闪周期是计算机内一种记时方式（时钟周期），它被用来使不同组件同步工作（时钟就是计算机世界的时间标准）。计算机都配备着某种时钟专门用来计时。Java 中还用时钟作为生成随机数的依据
- 触发器/锁存器 。相同条件下能使电路输出有两种稳定输出状态的电路。这意味着触发器能保存信息。比如 R-S 锁存器，D 型锁存器（1 位存储器）
- 边沿触发器。保持位由 0 变为 1 的瞬间锁存一次数据。如 边沿型 D 触发器
- 分频器。 = 振荡器 + 边沿触发器。能降低振荡器的输出频率（扩大振荡器的周期）
- 计数器。多个分频器构建的多级分频器能做到：1 号分频器的输出周期为 T，2 号分频器的输出周期为 2T， n 号分频器的输出周期为 2nT。根据其数学特性，可将其作为一个 2 进制的计数器，构建行波计数器

**名词概念**

反馈电路：含有输出结果能影响输入的电路

**锁存器**

锁存器是触发器的一种。在数字电路中，锁存器是具有记忆功能的电路。是用来暂时保存数据和信号的

**D 型锁存器**

D 型锁存器或边沿型 D 触发器都需要一个保持位（Clk）。如果保持位为 0，则输入端不能影响输出端当前的状态；保持位为 1，则输入端会修改输出端的状态

各种锁存器还需要有一个清空位（Clr），用于清空锁存器保存的状态

PS：基于上述触发器构建的存储器都是易失性存储器，断电后数据清零



# 第 15 部分：字节与十六进制

Q：为什么 1 个字节是 8 位

A：大部分非象形文字的书面语言文字系统中字符数都少于 256；人肉眼可识别的黑白图像的灰度值约为 256。所以 8 位符合人类的需求



Q：为什么字节中的数据要用 16 进制表示，而不是 6，7，8 进制

A：字节数据通常用 16 进制表示，因为 16 进制中 1 个数字表示 4 位二进制位。1 个 16 进制数字刚好能表示半字节。而包括 8 进制在内的进制都不能做到这件事或做的不完美



# 第 16 部分：存储器组织

- D 型触发器可以构建最简单的存储器
- 2<sup>n</sup>-1 选择器，n 个开关实现从 2<sup>n</sup> 个输入中选择 1 个作为选择器的输出。用来选择存储器中指定的位，并对其进行输出（读）
- n-2<sup>n</sup> 译码器，n 个开关实现从 2<sup>n</sup> 种输出结果。                                           用来选择存储器中指定的位，并对其进行输入（写）

上述的 n 个开关在实际电路中被地址总线所替代，选择器 & 译码器通过地址总线传来的地址选择一个存储单元

选择器 + 译码器 + D 型触发器 = 小 RAM 存储器

综上所述可总结出：RAM 的片外总线包括地址线，数据线，读写控制线（写状态表示用译码器进行输入，写状态表示用选择器）

**RAM 阵列**

之前搭建的 小 RAM 存储器是一个只能向一个 bit 进行读写

用多个 RAM 根据不同的规则组成 RAM 阵列进行字位扩展 + 地址总线共享可实现一组地址读写多位数据



# 第 17 部分：自动操作

目标：设计一台能自动执行加减法的机器，即：使加减法的过程自动化



累加器 = 1 个加法器 + 1 个锁存器。加法器的输入可以来自锁存器的输出；即这次加法用的加数可以是上次加法的计算结果。累加器用来累加多个数的缓存器。可以做简单的累加，还能当锁存器

PS：下面使用的累加器的数据宽度为 8，即加数，被加数，结果都占 8 位



**自动加法器的改进与迭代**

- 第 1 代自动加法器
  - 组成：1 个 RAM，1 个累加器，1 个计数器，1 个控制面板
  - 组件说明：RAM 用于保存要累加的数据；计数器的输出用来表示下一个需要被读取的数据在 RAM 中的地址
  - 功能：从 RAM 的 0 地址开始取数（因为计数器从 0 开始计数），把数输出到累加器计算结果，从 RAM 中入去下一个数据再进行累加
  - 缺点：不能自动停止工作；不能记录计算结果，只能展示最终的累加结果；只能做加法；计算结果的范围有限（只能计算两个 8 bit 数）
- 第 2 代自动加法器
  - 改进：添加了操作码概念。和第 1 代相比，它能控制停止计算；能记录计算结果；能做减法
  - 组成：**2 个 RAM**，1 个 累加器，1 个计数器，**2 个控制面板**， **1 个相反器**，**1 个 2-1 选择器**
  - 组件说明：一组 RAM 和控制面板用来保存代码和控制各组件的控制信号，另一组用来执行累加和记录累加结果；相反器用于求反码 & 实现减法逻辑；选择器用于实现 Load 指令（开始执行计算操作的第一步的指令）
  - 功能：从 1 号 RAM（指令 / 代码 RAM）读取操作码控制累加器执行相应操作
  - 缺点：只能做加法；计算结果的范围有限（只能计算两个 8 bit 数）
- 第 3 代自动加法器
  - 改进：添加了进位加法和借位减法操作码。和借位和第 2 代相比，无限扩大了累加器能进行计算的数的范围
  - 组成：2 个 RAM，1 个 累加器，1 个计数器，2 个控制面板， 1 个相反器，1 个 2-1 选择器，**1 个 1 位锁存器**
  - 组件说明：1 位锁存器用来保存进位或结尾
  - 功能：把大数的计算分为低字节计算和高字节计算，用进位加法和借位减法实现。高低字节的总和为计算结果
  - 缺点：代码 RAM 中的一条指令能作用仅能作用于数据 RAM 相同地址中的数据。即代码 RAM 只能顺序执行并从 00h 地址开始顺序操作数据 RAM 中的数据
- 第 4 代自动加法器
  - 改进：给操作码添加了操作数的概念。和第 3 代相比，它能让操作码操作指定地址的数据，而非线性顺序操作数据 RAM中的数据
  - 组件：**1 个 RAM**，1 个 累加器，1 个计数器，2 个控制面板， 1 个相反器，2 个 2-1 选择器，1 个 1 位锁存器， **3 个 8 位锁存器**
  - 组件说明：因为已经实现随机使用数据 RAM 中的地址，无需进行严格的顺序操作，所以可合并两个 RAM；3 个 8 位锁存器。从 代码 RAM 中读操作码（8 位） + 操作数（ 16 位），1 个 锁存器保存操作码，2 个锁存器保存操作数；代码 RAM 需要接收时钟信号，数据 RAM 需要接收寻址信号，两 RAM 合并后就需要 2-1 选择器选择接收上述两种信号
  - 功能：操作码 + 操作数 组成的简单指令集，用代码 RAM 中的指令操作自动加法器进行计算
  - 缺点：由于代码 RAM 中的指令还需要严格的顺序执行，所以代码 RAM 和数据 RAM 的合并导致：如果 Halt 终止指令后紧跟数据 RAM，那么想在 Halt 后面添加指令将非常困难
- 第 5 代自动加法器
  - 改进：添加 Jump 指令。和 第 4 代相比， Jump 跳转指令指定了下一个需要执行的指令的地址，它实现了代码的执行不再严格顺序执行
  - 功能：Jump 指令强制把计数器的输出修改为 Jump 操作数指定的地址，实现指令的跳转执行
  - 组件：1 个 RAM，1 个 累加器，1 个计数器，2 个控制面板， 1 个相反器，2 个 2-1 选择器，1 个 1 位锁存器， 3 个 8 位锁存器
  - 组件说明：保存操作数的 2 个 8 位锁存器的输入还可指向 16 位计数器，用于 Jump 指令修改下一个指令的地址
  - 缺点：缺少条件跳转指令
- 第 6 代自动加法器
  - 改进：添加条件跳转指令
  - 组件：1 个 RAM，1 个 累加器，1 个计数器，2 个控制面板， 1 个相反器，2 个 2-1 选择器，**2 个 1 位锁存器**， 3 个 8 位锁存器
  - 组件说明：1 号 1 位锁存器是进位锁存器，用来进行扩大能计算的数的范围。2 号 1 位锁存器是零锁存器，用来实现条件跳转
  - 功能：实现条件跳转，比如循环执行某段代码并指定循环次数
  - 功能实现流程：以循环为例，循环变量初始值为循环次数，循环变量每次循环后 -1（halt 操作码 FF 为 -1 的补码形式），如果结果不为 0，则继续循环；如果为 0，则退出循环



尽管机器的功能很简单，但第 6 代自动加法器确实可以被称为一台计算机了！😀



**分析上述的第 6 代自动加法器**

上述数字计算机主要由 4 部分构成：处理器，存储器，输入 & 输出设备（控制器已经被包含在电路里了。控制器是由代码 RAM 担任的，运算器由累加器担任）

- 存储器：RAM 阵列
- 输入 & 输出：控制面板上的开关和灯泡
- 处理器 / 中央处理单元 / CPU：除上述外的其他设备都属于处理器
  - 算术逻辑单元 / ALU：上述的 8 位相反器和 8 位加法器构成 ALU
  - 程序计数器 / PC：由上述的 16 位计数器担任 PC



把上述的操作码和操作数用助记符的形式编写得到的程序就是汇编程序

汇编语言：是全数字的机器语言和指令的文字描述的结合体。汇编语言和机器语言是对同一种事物的不同描述方式。如果说有 K（助记符） : V（机器代码 / 操作码的 16 进制格式），那么机器语言就是在用 V 写程序，汇编用 K 写程序



# 第 18 部分：从算盘到芯片

讲计算机硬件的发展史

- 电子元件的发展（真空电子管 ==> 晶体管）
- 史电子组件的发展史（把电子元件组成逻辑门后再组建振荡器，加法器等芯片整合到面包板或直接在集成电路上集成完整的结构）
- 衡量微处理器的 3 个指标（数据线宽度，主频——振荡器的最大频率，寻址能力——地址总线宽度）



# 第 19 部分：两种典型的微处理器

目标：此部分会把微处理器看作黑盒，现在要了解的是微处理器和其他设备是如何交互的，即关注微处理器的输入和输出。说白了就是在讲汇编语言



微处理器中的寄存器本质上是锁存器，用于保存少量数据。累加器就是一种特殊的寄存器，累加器除能保存少量数据外还能进行算数运算

讲了大量机器指令和对应的助记符（讲汇编）



**和处理器相关的几个有趣的存储器**

- RAM 是随机访问存储器
- 栈是有优先级的存储器，它总优先处理栈顶的数据。但通常很少用专门的栈的硬件存储设备，通常是在存储器中划分一块空间构建一个栈。然后用一个寄存器（栈指针）保存栈顶或栈底的地址
- 输入输出设备从本质上来说也是一种存储器。外设连上微处理器的 I/O端口后，微处理器通过对外设的存储器寻址，对外设中的数据进行读写



**几个有意思的指令**

- PUSH, POP。入栈，出栈的指令
- CALL。和 JUMP 相比，CALL 把当前的地址保存到栈中，再修改地址。执行完指令或再出栈获取原地址，继续执行之前的指令（用于实现函数 / 子程序的调用）。CALL 需要配合 RETURN 使用
- RST。用于执行中断。比如当微处理器需要接收键盘 RAM 中的数据时（敲击键盘，来自键盘的输入就会被保存到键盘的存储器中），应该先保存现场（中断），再处理完外设的数据后，恢复现场继续工作。保存现场的原理和 CALL 类似，用栈实现

互不兼容的芯片使用的操作码不同，对应的机器码也就不同。所以为一种芯片编写的汇编程序不能在另一种芯片上运行



**提高处理器运行速度的新技术**

- 流水线技术。在执行一条指令的同时读取下一条指令
- Cache 缓存技术。缓存少量信息，减少对主存的访问



BCD（Binary-Coded Decimal‎）码：用 4 位 bit 表示 1 个 10 进制的数

第 17 部分构造的计算机，准确来说它只是一个处理器，而一台非完整的计算机。第 22 章中会构造一台计算机系统



# 第 20 部分：ASCⅡ 码和字符转换

为每一个字符提供唯一一个编码的系统称为字符编码集，系统内每个独立的编码称为字符编码

ASCⅡ 码中，每 7 位表示一个字符。ASCⅡ 码本质上是 7 位编码，但仍以 8 位的形式存储。ASCⅡ 码能表示的字符非常有限

Unicode 字符编码集，每 2 个字节表示一个字符，兼容 ASCⅡ 中的编码

此外还有 UTF-8 ，GBK 等常用字符编码集



# 第 21 部分：总线

总线是数据总线，地址总线， 控制总线的统称。总线被设计在扩展板 / 主板上

总线的评判标准主要有

- 总线宽度：如果微处理器需要一次性同时穿 64 位数据，但数据总线只有 32根，说明总线需要升级了
- 总线传输效率：如果总线传输数字信号（数据）的速度跟不上微处理器的频率，说明总线需要升级了



~~介绍了键盘的实现，非易失性存储器的实现~~



# 第 22 部分：操作系统

Q：用上述技术构建出微处理器（不是第 17 部分中专门做加法的自动加法器，而是具有通用功能的微处理器），键盘，屏幕，一些 RAM 和磁盘驱动器。把它们组成一台电脑。开机后会发生什么？

A：毛也没有。它唯一知道的事就是从 0 地址开始读数据 / 指令。接下来它会做的事完全取决于这条数据 / 指令的内容

综上所述，为了做出一台能正常使用的电脑，除上述完整的硬件外，还需要对计算机进行以下升级和更新

- 在计算机通电后能向内存的 0 地址处写入第一条指令。此指令用于引导微处理器开始执行工作（开机）
- 在计算机刚通电时，内存中完全没有一点数据。所以向内存 0 地址写入数据的方式为：用控制面板上的开关向 0 地址写一条指令
- 用键盘替代掉控制面板。方便向计算机输入指令 / 数据
- 用 ROM 保存一小段开机引导程序，通电后让微处理器通过计数器从 ROM 的 0 地址开始加载引导程序。而非通电后手动向 0 地址输入引导指令（BIOS 的雏形）
- 用磁盘保存提前写好的程序。让计算机通电后，读取磁盘中的程序到内存中，而不再是在计算机运行时手动输入程序指令让微处理器运行
- 通过显式指定地址去保存数据会很不安全且繁琐，因为需要手动找到一片大小足够的，连续的存储空间后才能保存数据。且如果想要获取之前保存的数据也只能提前在纸上记录哪些数据之前被保存到了哪些地址上。因此，磁盘需要有文件系统来帮助人类管理数据
- 文件系统把数据组成文件来保存和读取。在文件系统中，文件就是完整数据单元
- 文件系统 + 键盘处理程序 + 刚需的命令处理程序  + ... = 操作系统。而 ROM 中保存的引导程序的作用就是用来加载磁盘中的操作系统



综上所属，计算机开机的流程大致为计数器从 0 开始计数，微处理器就从 ROM 的 0 地址读取引导程序。执行引导程序加载操作系统。加载完操作系统后，计算机就拥有能处理输入，输出，运行已有程序的功能了

所以操作系统的功能就是尽可能有效地，合理地调度硬件设备，让硬件设备完成各种计算任务



完全启动计算机后，就会进入由键盘和显示器组成的 Console。用键盘在 Console 中输入指令后，通过键盘程序的中断机制让微处理器立即执行来自键盘输入的指令

操作系统会被加载到内存中的指定空间，而非任意为其分配一段内存空间去保存操作系统

操作系统的第三个功能：操作系统为应用程序提供的用于访问硬件的 API（应用程序接口），理论上应用程序不能直接访问计算机的硬件，因为这样不安全。应用程序只能通过操作系统提供的接口来进行



为满足多用户同时用不同的终端操作同一台计算机，发展出了 UNIX。后又有了 Linux



# 第 22 部分：定点数和浮点数

浮点是是基于科学计数法设计存储方案的

10 进制的科学计数法的规范化式：±有效数 * 10<sup>指数</sup>。有效数的范围为 [1,10) 。有效数又称尾数，小数部分或首数。有效位前有正负号



例：二进制数`101.1101`和十进制数`5.8125`是相等的

<center>101.1101 = 1 * 2<sup>2</sup> + 0 * 2<sup>1</sup>  + 1 * 2<sup>0</sup>  + 1 * 2<sup>-1</sup> + 1 * 2<sup>-2</sup> + 0 * 2<sup>-3</sup> + 1 * 2<sup>-4</sup></center>

二进制数的科学计数法的规范化式：±有效数 * 2<sup>指数</sup>。尾数一定为 1.xx 或 0

- 浮点数规范化表示中，上述信息被分为 3 部分：符号位，指数位，尾数（也称，数符，阶码，尾数）
- 浮点数的不规范化表示中，上述信息被分为 4 部分（了解即可）



> [IEEE 标准中浮点数的二进制存储格式在线查看](http://www.binaryconvert.com/convert_float.html)



**单精度浮点数**

```
+-------------+-------------+------------+
| s = 1 位符号 | e = 8 位指数 | f = 23 尾数 |
+-------------+-------------+------------+
```

(-1)<sup>s</sup> × 1.f × 2<sup>e-127</sup>

**双精度浮点数**

```
+-------------+--------------+------------+
| s = 1 位符号 | e = 11 位指数 | f = 52 尾数 |
+-------------+--------------+------------+
```

(-1)<sup>s</sup> × 1.f × 2<sup>e-1023</sup>



其中，当 e 和 f 取某些值时会表示一些特殊值

- e = f = 0。表示 0
- e = 0, f ≠ 0。等价于 (-1)<sup>s</sup> × 0.f × 2<sup>-127</sup>
- e = 255, f = 0。表示无穷大或无穷小，正负号根据符号位而定
- e = 255, f ≠ 0。表示 NaN（not a number）



**浮点数的复杂运算**

对于对浮点数进行三角函数，对数，开方运算。可以让处理器用泰勒展开式进行近似运算，因为浮点数的精度有限，所以泰勒展开式只需要展开很小一部分即可



# 第 24 部分：高级语言与低级语言

汇编器能把汇编语言代码 汇编 / 翻译 为机器语言代码。汇编器拥有一张汇编语言助记符和机器码指令的映射表，汇编器的汇编过程就是把汇编语言的助记符替换为对应的机器码指令

汇编语言存在不可“移植”性。同一个汇编程序能在 A 芯片上运行，但不能在 B 芯片上运行。因为不同芯片使用的硬件和指令集不同，导致无法执行其他芯片上的汇编程序



**高级语言**

编译器可以把高级语言转换为机器码指令。编译器通常需要把一条高级语言语句转换为多条机器码指令，而汇编语言比较就简单，一条汇编语句对应一条机器码指令。高级语言通常有良好的可移植性，但如果高级语言具有完全的可移植性，这代表她不能使用某些处理器的特有功能。因为可移植性越高表示其逻辑越通用



**UNIX 和 C**

很久前的操作系统都是基于某种特定的处理器，并用汇编语言编写的，基本没有可移植性可言。UNIX 是由高级语言 C 语言编写的，所以 UNIX 具有可移植性



# 第 25 部分：图形化革命

显示器通过显卡 / 显示适配器的支持进行工作

光栅图形：显卡用显卡内部的存储器保存显示器上每个像素点需要显示的颜色信息。电子枪读取这些信息后向显示器不断扫描发射实现显示图像的效果

矢量图形：不失真



声卡：用于支持模拟信号转为数字信号的设备，用于保存，传递声音的信息





# 问题



Q：地址线能选择一个单位。这个单位是一个 bit 还是一个存储单元还是一个存储芯片？

A：选择一个存储单元。一个存储单元有多少个 bit 取决于存储单元是否使用了字扩展或位扩展

 
