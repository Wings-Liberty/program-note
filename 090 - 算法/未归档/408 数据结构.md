# 绪论

需要掌握估算算法的时间复杂度和空间复杂度

计算时间复杂度和空间复杂度时以最坏的情况为准



# 线性表

- 线性表的**元素的序号从 1 开始计数**，但下标从 0 开始计数

经典题目：原地逆置（顺序表和链表）



## 顺序表

- 基于数组的结构体实现。随机访问的时间复杂度为 O(1)，删除和插入的时间复杂度为 O(n)
- 顺序表：写代码的时候注意 length - 当前数组长度，max - 数组最大长度
- 有序顺序表查询元素默认最快方式：二分



## 顺序常用算法

- 逆置 & 多次逆置。用于数组的整体逆序，或循环左移 / 右移
- 多指针。定义若干个指针指向满足某些条件的下标或数字，通过移动指针进行 解题 / 计算



## 链表



## 链表常用算法

- 头插，尾插（头插使插入元素的顺序和保存元素的顺序相反，即链表实现的顺序表有栈的特性）
- 原地逆置（链表 / 数组 的原地逆置）
- 双指针 / 快慢指针
- 归并



# 栈和队列



## 栈



## 栈常用算法

- 用于深搜
- 用于递归转非递归（递归算法通常会包含一些冗余的计算，所以非递归的效率通常比递归的效率高）
- 中序转后序
- 栈和括号匹配
- 表达式求值
  - 波兰表达式 = 前缀表达式
  - 逆波兰表达式 = 后缀表达式
- 进制转换，迷宫求解（这俩都没听说过）



## 表达式求值

- 前缀表达式：符号在两个操作数之前
- 中缀表达式：符号在两个操作数之间
- 后缀表达式：符号在两个操作数之后

表达式求值通常用：波兰表达式 = 前缀表达式 or 逆波兰表达式 = 后缀表达式。所以需要把中缀变前缀或后缀

D:\考研\408\2021 数据结构课件\3.3.2_栈在表达式求值中的应用(上).pdf

D:\考研\408\2021 数据结构课件\3.3.2_栈在表达式求值中的应用(下).pdf

D:\考研\408\2021 数据结构课件\3.3.1_栈在括号匹配中的应用.pdf

- 中缀转后缀，后缀表达式求值
  - 后缀表达式结果不唯一。除非按照 “左操作数，右操作数，运算符” 和 “左优先” - 优先运算左边的运算符
  - 手算中缀转后缀时，对括号的处理很简单。机算此过程时，需要用一个栈，栈中只保存运算符 / 操作符 和左括号
  - 计算后缀表达式时，用一个栈，且栈中无括号
- 中缀转前缀，前缀表达式求值
  - 前缀表达式结果不唯一。除非按照 “运算符，左操作数，右操作数” 和 “右优先” - 优先运算左边的运算符
  - 手算中缀转前缀时，对括号的处理很简单。机算此过程时，需要用一个栈
  - 计算前缀表达式时，用一个栈，且栈中无括号
- 中缀表达式的计算
  - 机算中缀转后缀时，用到了运算符栈。用于保存不能确定运算次序的运算符
  - 机算后缀表达式时，用到了操作数栈。用于保存不能确定运算次序的操作数
  - 用两个栈实现中缀表达式的计算。本质上还是用中缀转后缀，计算后缀两个过程同时进行

<img src="https://wings-liberty.oss-cn-beijing.aliyuncs.com/note/Snipaste_2021-12-04_18-47-57.png" alt="Snipaste_2021-12-04_18-47-57" style="zoom:67%;" />



## 队列

- 基于数组的队列
  - 初始时，头尾指针均 = 0，**尾指针指向最后一个元素的下一个位置**
  - 普通的数组队列存在 “上溢出” 和 “假溢出” 的问题
  - 循环队列判空：队头等于队尾下标时，队空（做过且不会 1 次。误以为有多种判空方式）
  - 循环队列判满方式
    - 方式 1：队尾的下一个位置是否是队头（常考。下面两种不常考）
    - 方式 2：为队列设置剩余空间计数器，或已使用空间计数器（和 max / capacity 比大小）
    - 方式 3：设置 tag 位；删操作引起 队头 = 队尾时，tag 置 0；增操作引起 队头 = 队尾时，tag = 1
- 基于链表的队列：带有头结点和尾指针的链表
- 输出 / 输入受限的链式双端队列。实际双端队列只会问给定的输出序列是否合法，而不会问给定输入序列能得到几种输出序列
  - 输出受限的双端队列：一端的输出受限
  - 输入受限的双端队列：一端的输入受限



## 队列常用算法

- 层序遍历实现的广搜



# 特殊矩阵的压缩存储

二维数组经压缩后存放在一维数组中

- 压缩对称矩阵 - 原矩阵是对称矩阵：只保存对角线和下三角
- 压缩上/下三角矩阵：此处的下三角矩阵指上三角元素均相等的矩阵，**并不是上三角元素必均为 0**。压缩方式为在对称矩阵的基础上在压缩数组后追加一个元素（即上三角中元素均相等的那个元素）
- 压缩三对角矩阵：三对角矩阵，其余元素均为 0
- 稀疏矩阵：用（行，列，值）三元组作为压缩格式

原二维数组的第一个元素均以 a(1,1) 开始，而不是 a(0, 0) 开始（ 艹 ？？）





# 字符串和 KMP

字符串分类

- 基于数组实现的定长存储：静态大小的数组实现的定长字符串
- 堆分配存储表示：用指针实现的 malloc 动态申请的字符串
- 链表实现的不定长字符串



匹配值数组 p[i]：表示 模式字符串 i 下标对应的最长相等前后缀长度

遇到不匹配时，模式字符串整体向后移动位数 = 已匹配的位数 - p[i]



~~next 数组：next[i] 表示模式字符串匹配到 i 时匹配错误，模式字符串的指针应该移动到模式字符串的哪个下标下~~



KMP

主字符串长度为 n，子字符串长度为 m

暴力解，时间复杂度 O(nm)

常规 KMP，时间复杂度 O(n+m)

常规 KMP 的 next 数组构建算法还可以被改进，求 nextval 数组，能进一步减少子字符串和主字符串的比较次数



# 树与二叉树

## 树

定义：除根节点外，所有节点均有且只有一个前驱，有 0~多个后驱

- 树中节点的子节点数量不是固定的
- 公式
  - 节点数和边数的关系 / 节点数和度数的关系
  - 叶结点数和节点数的关系（二叉树常用）
  - 有 n  个节点的 m 叉树的最小高度为多少（好像没考过）



## 二叉树的分类

二叉树定义：在树的定义上追加，一个节点可以有 0~2 个子节点。空二叉树连根节点都没有

- 满二叉树
- 完全二叉树
- 有序二叉树
- 平衡二叉树：任意节点的左右子树深度差不超过 1
- 线索二叉树

**编码注意事项**

- 用数组实现二叉树时，建议从下标 1 的元素开始存数据。这样方便用下标计算子节点的父节点在数组中的下标



## 二叉树的遍历

先，中，后序遍历，层序遍历。递归遍历，非递归遍历

- 先序遍历 = 入栈次序
- 中序遍历 = 出栈次序

序列化和反序列化：中序遍历序列 + 其他遍历序列 确定一个唯一的二叉树



线索二叉树：不考代码，记住前中后序线索二叉树的构造方法和遍历流程即可

- 中序现所二叉树构造规则：

  如果 cur.left 为空，指向上一个访问的节点（中序前驱）

  如果 pre.right 为空，指向 cur。中序序列最左和最右代表的节点均指空

- 先 / 后序线索二叉树构造规则：同上，只不过左指针为空时，指的是先 / 后序序列中的前驱节点

**切记，节点有空指针时才会建立线索指向前 / 后驱**



## BST（二叉排序树）

BST：中序遍历是递增序列的树

- BST 的插入不需要调整树，而是直接找到合适的位置插入

- BST 的删除，如果删的不是叶子节点，随便找一个前驱或后继节点

  （不一定是其直接子节点顶替它，但通常规定先考虑左再考虑右，或先考虑右再考虑左）顶替它（一般不涉及写代码，所以不慌）



## AVL（平衡二叉树）

子树高度差不超过 1，插入和删除数据都可能会引起高度差出现问题，通过旋转调整高度差。408 不考代码且只考插入

旋转的对象是最小不平衡子树 A，A 的左子树 - B，右子树 - C

- LL（右单旋转）：向 A 的 L 子树的 L 子树插入新节点导致的不平衡。B 代替 A，A 挂到 B 的右边
- RR（左单旋转）：向 A 的 R 子树的 R 子树插入新节点导致的不平衡。C 代替 A，A 挂到 C 的左边
- LR（先右后左双旋转）：向 A 的 L 子树的 R 子树插入新节点导致的不平衡
- RL（先左后右双旋转）：向 A 的 R 子树的 L 子树插入新节点导致的不平衡



PS：节点的平衡因子取值可以为 0，1，-1。1 表示左子树高，-1 表示右子树高，0 表示左右子树高相同



## 哈夫曼树

哈夫曼树 / 最优二叉树：WPL 最小的最优二叉树

- 带权路径长度 WPL 最小
- 数据相同时，构造的哈夫曼树不是唯一的，但 WPL 必然相同且最优（为啥不是唯一的？）



PS：m 叉哈夫曼树的特点：只有度为 0 和 m 的节点

PS：如果不是二叉树，则构建哈夫曼树时可能需要添加虚段保证 WPL 最小

k 叉树的虚段个数求法

1. (n<sub>0</sub>-1)%(k-1) = m。表示想要构建完全 k 叉树，但多了 m 个节点
2. 虚段数 = k-m-1。添加虚段的目的是让多出来的节点和虚段组合起来便能组成完全二叉树



# 图

有空表，空树，但**没有空图**：边集可以为空，点集不能为空



## 图的名词

- 简单图（数据结构全程简单图）：无重复边，无自环边。多重图（不讨论）
- 完全图：有最多边的有向 / 无向简单图 或者说 任意两个顶点互相可达的有向 / 无向简单图
- 子图：点集和边集均为子集的图
- 生成子图：点集是全集，边集是子集
- 连通，连通图：任意两点均可达。连通分量 / 极大连通子图（无向图）
- 强连通，强连通图：任意两点双向可达。强连通分量（有向图）
- 生成树（无向图）：极小连通子图，生成森林
- 稀疏图，稠密图的判别公式（不重要）
- 回路 / 环；简单路径（顶点不重复出现 - 无环），简单回路（除起点和终点外，顶点不重复出现）
- 有向树：1 个顶点入度 = 0，其余顶点入度 = 1



## 图的 4 种数据结构实现方式

- 邻接矩阵：二维数组保存有向 / 无向边（适用于稠密图）
  - 无权图：1 - 边存在，0 - 边不存在
  - 有权图：x - 边存在且权重为 x；0 或 ∞ - 边不存在
- 邻接表：一维数组 + 链表（适用于稀疏图）



PS：注意无向图和有向图的邻接矩阵中 0 和 ∞ 的作用

PS：邻接矩阵，邻接表中如果不全是双向边，默认是有向图；如果全是双向边，默认是无向图（但也可能是有向图）

PS：无权图的邻接矩阵 A 和 A<sup>n</sup> ( 矩阵乘法 ) 的含义，以及 A<sup>n</sup>\[i\]\[j\] 的含义：i 到 j 的路径长度为 n 的路径数量



## 图的遍历

- 遍历方式：有向图和无向图的 DFS 深搜，BFS 广搜（Dijkstra 和 Prim 也用了 BFS 思想）
  - 用邻接表时，深搜广搜的时间复杂度是 O(V+E)；用邻接矩阵时，深搜广搜的时间复杂度是 O(V<sup>2</sup>)
- 非强连通分量的连通性




BFS 的应用

- 单源最短路径
- 广度优先生成树：BFS 访问节点顺序组成的树结构，一个图对应的广度优先生成树不是唯一的



PS：同 1 个图，用邻接矩阵的 BFS 和 DFS 得到的访问顺序唯一；用邻接表的 BFS 和 DFS 得到的访问顺序不唯一

PS：DFS 和 BFS 的性能（使用邻接矩阵和邻接表的时间复杂度是不同的）



## 最小生成树（MST）

> 像 MST 和 BST ，AVL 等算法，408 都不会要求写代码

最小生成树：权值和最小的极小连通子图

带权连通无向图的基于贪心策略的切分定理的 Prim 算法和 Kruskal 算法

- Prim 用于稠密图（边多点少）。因为其时间复杂度不依赖于边的数量；时间复杂度 O(V<sup>2</sup>)
  - 工作流程：从当前连通分量中的点中，选权重最小的邻接边，且另一个点不在连通分量中
- <a id="Kruskal">Kruskal</a> 用于稀疏图（边少点多）。因为其时间复杂度不“太”依赖于顶点的数量；时间复杂度 O(ElogE)
  - 工作流程：从所有边中，选权重最小的边，且边的两点不属于同一个连通分量
  - 用[并查集](#并查集)判断两个点是否属于一个连通分量

这两种算法都需要从候选边中选最小的边，因此都需要小根堆的支持



## 最短路径

最短路径的性质：两点之间的最短路径也包括了路径上其他顶点之间的最短路径

带权有向图的最短路径问题

- [Dijkstra 算法](D:\workspace\IDEA-workspace\algs_study\src\algorithm\sp\DijkstraSP.java)（不熟）（求一点到其他各顶点的最短路径；也可把每个节点当作起点，多次使用算法，实现求任意一点到任意一点的最短路径）
  - 工作流程：初始只有起点，不断把离起点最近的点加入点集，并把新加入的起点和边直接确定为最短路径的一部分（即这一个点和边一定不需要松弛）
  - 能处理环路，不能处理有负权值边的有向图（所以也能处理没有负权值的无向图）
  - 不管使用你邻接矩阵还是邻接表，其时间复杂度都是 O(V<sup>2</sup>)
- Floyd 算法（求任意一点到任意一点的最短路径）
  - 工作流程：一层循环以 0~n 为中间节点（循环时间复杂度为 n），循环内尝试对所有边进行松弛（又嵌套两层循环，复杂度为 n<sup>2</sup>）
  - 能处理负权值的边，但不能处理由负权值的边组成的环的图
  - 时间复杂度为 O(V<sup>3</sup>)

PS：注意 Dijkstra 和 Prime 的区别。在代码上的区别见王道书 P266 10 答案





## 有向无环图（DAG）

描述公共子式的工具，**尽可能**复用已有的节点表达式



## 拓扑排序

拓扑排序是基于无权无环的有向图（这种图被称为 AOV 网）的排序



-  拓扑有序实现方法：从 AOV 网中选一个没有前驱的节点，删其节点和邻接边后，输出
- 逆拓扑有序实现方法：从 AOV 网中选一个没有后驱的节点，删其节点和邻接边后，输出



时间复杂度 O(V+E)。因为有 1 个一维数组保存了节点的入度。如果纯靠 DFS，那时间复杂度就不止如此了



## 关键路径

有权值的 AOV 网被称为 AOE 网。节点 - 事件，边 - 活动

> 构造流程不是太熟

- 事件 v<sub>k</sub> 最早发生时间 ve(k)
- 事件 v<sub>k</sub> 最迟发生时间 vl(k)
- 活动 a<sub>i</sub> 最早开始时间 e(i)
- 活动 a<sub>i</sub> 最迟开始时间 l(i)
- 一个活动 a<sub>i</sub> 的最迟开始时间 l(i) 和其最早开始时间 e(i) 的差额 d(i) = l(i) - e(i)

d(i) = l(i) - e(i) = 0 的相关点和边组成关键路径



计算过程

1. 手算 ve 和 vl
2. e(i)= 活动起点的 ve(i)
3. l(i) = 活动终点的 vl() - a<sub>i</sub> 
4. l(i) - e(i) = 0 的活动（边）和事件（点）组成关键路径



# 查找

静态查找：查找性能高，插删性能低的查找

动态查找：查找性能低，插删性能高的查找



平均查找长度

- 平均成功查找长度
- 平均失败查找长度



## 顺序查找和折半查找





## B 树和 B+ 树

B 树 - 多路平衡查找树

B 树和 B+ 树的插入都可能涉及“分裂”行为，删除都可能涉及“合并”行为

**B 树**

- m 阶 B 树的特性
  - 每个节点**最多**有 m 个子树，**最多**有 m-1 个关键字
  - 非根节点的非叶子节点**至少**有 m/2 （**向上取整**）棵子树，即**至少**有 m/2-1（向上取整）个关键字
  - 根节点没子树或至少有 2 个子树。叶节点代表查找失败节点，逻辑上存在，物理上不存在
- B 树是所有平衡因子均等于 0 的多路平衡二叉树



B 树的查找：节点内采用顺序查或二分查



**B+ Tree**

B Tree & B+Tree 被保存在磁盘中。磁盘中的每个块保存若干个节点，操作系统需要将块读到内存中后才能执行 curd

在 B+Tree 中，磁盘块包含的关键字越多，B+Tree 的阶越大，树高越矮，读取磁盘的次数就越少，查找就更快

为使一个块中的节点尽可能包含更多关键字，非叶节点就不包含关键字对应的记录的存储地址



## 散列表/哈希表



**散列函数的构造方法**

- 直接定址法：对 key 做一次线性计算
- 除留余数法：对 key 取 p 的模。p 最好为最接近散列表表长的质数
- 数字分析法：bbbb
- 平方取中法：取关键字的平方值的中间几位

**解决冲突的方法**

- 开放定址法。它是抽象方法，包括好几种具体方法
  - **线性**探测法 / **线性**探测再散列法：哈希碰撞后，线性寻找下一个空闲的地址空间
  - 平方探测法：哈希碰撞后，线性寻找下 k<sup>2</sup> （k 是常数）个空闲的地址空间（和线性探测相比就是找空闲的地址空间时多跳几个地址空间）
  - 再散列法：哈希碰撞后，用 2 号哈希函数，hash1 作为参数计算 hash2。又碰撞后用 1 号哈希函数，hash2 作为参数，循环往复
  - 伪随机序列法：哈希碰撞后，线性向后跳 random 个地址空间，寻找下一个空闲的地址空间

散列表的查找效率取决于：散列函数，处理冲突，装填因子（表示表的装满程度 - 表中记录数 / 散列表长度）

- 拉链法 / 链接法。桶下面挂链表



# 排序

- 排序算法的稳定性的概念
- 内部排序：待排序的数据都在内存中
- 外部排序：待排序的数据在内存和外存中



## 内部排序

> 排序的一 “趟” 指的是对数组中所有尚未确定最终位置的元素进行一遍处理

- 插入排序
  - 基本思想：每次将一个待排序的记录按其关键字大小插入到前面已排好的子序列中
  - 直接插入排序。时间 O(n<sup>2</sup>)，空间  O(1)；稳定；适用于数组和链表；**数据基本有序时，时间复杂度接近 O(n)，非常快**
  - 折半插入。时间 O(n<sup>2</sup>)，空间  O(1)；稳定；适用于数组。仅是对直接插入做了小改进，减少了比较次数，未改变元素移动次数
  - 希尔排序 / 缩小增量排序。时间 O(n<sup>2</sup>)，空间  O(1)；不稳定；适用于数组。通常实际时间小于 O(n<sup>2</sup>)。内部用直接插入排序
- 交换排序
  - 基本思想：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置
  - 冒泡排序。时间 O(n<sup>2</sup>)，空间  O(1)；稳定；如果冒泡过程中检查到剩余数组有序，则直接完成排序（标志位实现）
  - **快速排序**。最坏时间 O(n<sup>2</sup>)，空间  O(log<sub>2</sub>n)；不稳定；平均性能最优；在**有多个相同元素**或**原数组基本有序**的数据排序中**性能比较差**，体现在递归次数增多。每趟完成后，标兵会在最终位置上。平均时间 O(nlog<sub>2</sub>n)
- 选择排序
  - 基本思想：第 i 趟中，从后面 n-i+1 个元素中选最小的元素作为有序子序列的第 i 个元素。直到第 n-1 趟做完
  - 简单选择排序。时间 O(n<sup>2</sup>)，空间  O(1)；不稳定；**移动元素的次数很少**
  - 堆排序：时间 O(nlog<sub>2</sub>n)，空间  O(1)；不稳定。堆排序包括：构造堆 + 堆排序。堆一定是完全二叉树
- 归并排序。时间 O(nlog<sub>2</sub>n)，空间  O(n)；稳定
- 基数排序。时间 O(d(n+r))，空间  O(r)；稳定；支持链表和数组。不基于比较和移动



PS：基于比较的算法的时间复杂度不可能小于 O(nlog<sub>2</sub>n)

PS：快排在具体数据上排序时，执行速度可通过每次划分时两边是否等长，原数组是否近似有序来定性分析

PS：基于划分思想的快排，如果仅用于查找无序数组中第 k 大的数，找中位数等多种场景中。此时的采用快排思想的非递归实现的时间复杂度是 O(n)，空间复杂度是 O(1)（不用递归，用双层循环） --- 见 16 年 43 题

PS：数组实现的堆排序中，堆顶输出到数组末尾，并让堆的长度 -1。大根堆构建递增序列，小根堆构建递减序列

PS：折半查找的命中 / 未命中时最长查找长度为折半查找树的树高 log<sub>2</sub>n + 1（向下取整）



堆排序：构造堆 + 堆排序

- 构造堆。从 n/2 (向下取整) 个节点开始构造堆（归并思想。最初的堆只有 1~3 个元素，构造堆是上浮过程）
- 堆排序。堆顶元素和最后一个元素交换（逻辑删除堆顶元素），堆顶元素下浮再次实现堆有序



线索搜索树和 B 树的题都还没做

看一下荷兰国旗和逆波兰表达式的题



# <a id = "并查集">并查集</a>

逻辑结构：集合。所有元素被划分到不同的子集中，子集互不相交

物理结构：森林 = 不相交的多个树。树用双亲表示法实现

基本操作：Find，Union

- 查（Find 函数）：查询指定节点所在的集合（返回集合的根结点）
- 查：查询两个节点是否属于同一个集合。即查看两个节点所属的集合的根节点是否是同一个
- 并（Union 函数）：给定两个根节点，合并两个集合



[代码实现](D:\考研\408\冲刺课复习资料\算法\(3.1.2)--【课件】并查集课件.pdf)：

- 数组表示并查集
- 对并查集的初始化就是把数组元素全刷为 -1
- -1 表示节点是根节点，根节点数量 = 子集数量



优化前的时间复杂度：find - O(n)，union - O(1)（默认 union 的两个参数就是两个根，不计入找根的开销）



Union 优化：并查集的时间复杂度来自 Find 操作中找根节点的过程，所以如果能让树的高度降低，就能降低时间复杂度

优化策略：

- 小树合到大树下：合并两颗树时，节点多的根节点仍为根节点，节点少的的根节点称为子树

  为实现此功能，根节点的值为 -n，n 表示树包含的节点数（**n 不是树高**...）树高不会超过 log<sub>2</sub>n +1（向下取整）
  
  优化后，find 时间复杂度变为 O(log<sub>2</sub>n)



并查集的应用

- 判断无向图的连通分量个数

- 判断（有向 / 无向）图中是否有环（在把边的两点并入集合时，如果两顶点已在同一集合内，说明存在环）

- 用于 [Kruskal](#Kruskal) 实现 最小生成树算法（MST）：用于检查两个顶点是否属于同一个连通分量

  对 e 条边的两个顶点进行一次 Find 操作，所以 Kruskal 的时间复杂度为 O(elog<sub>2</sub>e)



Find 优化：压缩路径。把查找根节点时经过的节点都挂到根节点下

遍历两次查找路径。第一次遍历用于查找根节点，第二次遍历用于把路径经过的节点都挂到根节点下

经优化后，对于常见的 n 值，树高通常不超过 4，Find 操作的时间复杂度近乎常数。且也会导致 Union 操作时间也接近常数



# 新增考点：红黑树

> AVL 是 2-节点 平衡树
>
> 红黑树是 2-3 查找树的变形。把红黑树的逻辑结构打平后就是 2-3 查找树的逻辑结构。但红黑树的物理结构仍是二叉树



## 定义：

左根右，根叶黑

不红红，黑路同



左根右：节点的值 - 左 < 根 < 右

根节点：空节点 & NULL 节点 & 失败节点

黑高：任一节点到达根节点时经过的黑节点的个数（不包含本节点。所以根节点的黑高为 1）



临时笔记：

- 新插入的节点初始时为红色。这是为了保证黑路同，保证路径上的黑色节点数不变
- 如果插入 val = n 的节点，但 n 已存在。需统一插入规则，新节点统一插入相同节点的左子节点或右子节点
- 叶节点默认是失败节点，物理结构上是 NULL 指针，逻辑上黑节点



## 性质：

性质 1：从根节点到叶结点的最长路径不大于最短路径的 2 倍（最短路径为全黑节点路径，最长路径为全程红黑相间的路径）

性质 2：有 n 个内部节点的红黑树高度 h ≤ 2𝑙𝑜𝑔<sub>2</sub> 𝑛 + 1



## 插入：

<img src="https://gitee.com/wingsofliberty/study-node-imgs/raw/master/img/Snipaste_2021-12-22_08-54-24.png" alt="Snipaste_2021-12-22_08-54-24" style="zoom:80%;" />

PS：

- 父换爷（旋转的结果）+ 染色（原来的父和爷变色）
- 儿换爷 + 染色（原来的儿和爷变色）
