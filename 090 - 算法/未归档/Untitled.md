#还没有复习 



**二叉树的先序，中序，后序序列化，反序列化**



# 常用算法



## 递归和动态规划



贪心例题

![Snipaste_2020-11-08_14-49-58](D:\image\blog\Snipaste_2020-11-08_14-49-58.png)



**暴力递归**

1. 转化为规模缩小了的同类问题的子问题
2. 有明确的不需要继续进行递归的条件（base case）
3. 有当得到了子问题的结果之后的决策过程
4. 不记录每一个子问题的解

**动态规划**

1. 从暴力递归中来
2. 将每个子问题的节记录下来，避免重复计算
3. 把暴力递归的过程，抽象成了状态表达
4. 并且存在简化状态表达，使其更加简洁的可能

暴力递归通常在递归过程中**对某个子问题进行多次求解**，延长了求解时间。这就是暴力递归需要改为动态规划的原因

动态规划的题解可以由暴力递归的题解改进得到，但不是所有的暴力递归都能改进为动态规划。通常没有后效性的题能从暴力递归改为动态规划

**后效性**：如果方法传参相同，则得到的返回值一定相同的方法就是没有后效性的方法

修改套路

- 将暴力递归中的可变返回值变为已知的返回值

暴力递归例题

- 计算n!
- 打印一个字符串的所有子序列，全排序
- 汉诺塔



动态规划例题

![Snipaste_2020-11-08_14-52-16](D:\image\blog\Snipaste_2020-11-08_14-52-16.png)

![Snipaste_2020-11-08_15-14-14](D:\image\blog\Snipaste_2020-11-08_15-14-14.png)

假设：arr和aim都是正数



# 应用算法

许多算法都是由暴力解优化得到的。暴力解中通常包含重复计算某个子问题，优化后的算法通常会用缓存记录某个计算，防止重复计算；或使用当前计算结果作为下一个计算任务的依据，实现**加速**

总的来说就是，算法有效利用了先前的计算结果，从而实现计算加速



## Manacher

## 窗口和窗口更新结构

![Snipaste_2020-11-09_16-46-33](D:\image\blog\Snipaste_2020-11-09_16-46-33.png)

![Snipaste_2020-11-09_18-57-14](D:\image\blog\Snipaste_2020-11-09_18-57-14.png)

ps：子数组是连续的元素组成的数组，不是所有非空子集

## 单调栈

- 栈中数据有序。例如栈底元素值最大，栈顶元素值最小
- 当加入的元素的值小于栈顶元素，直接压栈。大于栈顶元素，栈顶元素一直弹出，直至栈顶元素的值大于新元素或栈空，将新元素压栈



<img src="D:\image\blog\Snipaste_2020-11-09_20-19-40.png" alt="Snipaste_2020-11-09_20-19-40" style="zoom: 67%;" />

只要父节点都大于子节点的树否符合要求

![Snipaste_2020-11-10_14-56-18](D:\image\blog\Snipaste_2020-11-10_14-56-18.png)



例题：

给一个数组，在UI上，数组组成一个环（逆时针还是顺时针组成的都无所谓），每个数字都代表一座山峰，山峰上有烽火

规则

1. 相邻的两座山能互相看见对方的烽火
2. 不相邻的两座山，如果它们之间的山的数字不比这里两座山的数字都大，那么它们也能互相看见烽火（两座不相邻的两座山能顺时针或逆时针看烽火）

如：

[1,2,4,5,3]

<img src="D:\image\blog\Snipaste_2020-11-10_15-04-57.png" alt="Snipaste_2020-11-10_15-04-57" style="zoom:67%;" />

1,2相邻，能看见。14不相邻，且2>1，所以1，4不能看见

3，2不相邻，3，2均大于1，所以3，2能看见

问题：给一个数组，有几对山能互相看见



解：

- 如果数组中没有重复的元素。答案为`2*i-3`对。公式推导视频上有
- 如果有重复的元素。用单调栈。每次弹栈的时候，对数加`C(2,k) + 2*k`。如果栈底只有一个元素，且times=1，则加`C(2,k) + k`，如果是栈底，则加`C(2,k)`   C()是排列组合



## 平衡搜索二叉树

![Snipaste_2020-11-11_10-54-54](D:\image\blog\Snipaste_2020-11-11_10-54-54.png)



## 习题

题1： 

给一个整数组，数组中能包含正整数，负整数，0。给一个整数aim。问题：求和为aim的最长子数组的长度

此题的变形：数组中只有正数。问题相同。要求空间复杂度O(1)，时间复杂度O(N)

题2：

给一个整数数组，数组中只有奇数和偶数。问题：求奇数偶数个数相等的最长子数组的长度



![Snipaste_2020-11-11_15-14-10](D:\image\blog\Snipaste_2020-11-11_15-14-10.png)

ps：不相容的子数组

```java
public class MostXOR {
	public static int mostXOR(int[] arr) {
		int ans = 0;
		int xor = 0;
		HashMap<Integer, Integer> map = new HashMap<>();
		map.put(0, -1);
		int[] dp = new int[arr.length];
		for (int i = 0; i < arr.length; i++) {
			xor ^= arr[i];
			if (map.containsKey(xor)) {
				int pre = map.get(xor);
				dp[i] = pre == -1 ? 1 : dp[pre] + 1;
			}
			if (i > 0) {
				dp[i] = Math.max(dp[i], dp[i - 1]);
			}
			map.put(xor, i);
			ans = Math.max(ans, dp[i]);
		}
		return ans;
	}
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190319223106372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FqaDU2MDY=,size_16,color_FFFFFF,t_70)

```
i有两种情况，
第一，i所在的划分区间，异或不为0；
第二，i所在的划分区间，异或为0。
对于第一种情况dp[i] = dp[i-1]的。0~i和0~i-1的最优划分结果都一样，因为有array[i]不能让最后一个划分区间结果为0，没有array[i]，最后一个划分区间结果还是不为0
对于第二种情况，假设i的最优划分区间是[k,i]，0到i的连续异或为sum，要求出一个最大的下标k-1，使得0到k-1的异或也为sum就行了
```

```
dp记录从左到右每增加一个数后数组划分得到的最大划分数量
```

 



**树形dp套路题（难在可能性分析）**

![Snipaste_2020-11-11_21-25-39](D:\image\blog\Snipaste_2020-11-11_21-25-39.png)

某个节点node的最大搜索二叉树，有以下几个可能

- 左节点或其子节点中有搜索二叉树
- 右节点或其子节点中有搜索二叉树
- 左右节点都是搜索二叉树，且左节点小于node，右节点大于node。node就是最大的搜索二叉树的头节点



**遇到树的搜索或遍历的算法通常都会用递归**



为了在递归中实现  使用递归函数返回值  判断上述3中可能性   需要递归方法返回的数据包含

- 左子树最大搜索树的大小
- 右子树最大搜索树的大小
- 左子树最大搜索树的头节点
- 右子树最大搜索书的头节点
- 左子树最大搜索树的节点的最大值
- 右子树最大搜索树的节点的最小值

精简后

- 搜索树的大小
- 搜索树的头节点
- 搜索树中节点的最大值和最小值





![Snipaste_2020-11-11_22-19-06](D:\image\blog\Snipaste_2020-11-11_22-19-06.png)

![Snipaste_2020-11-12_09-33-02](D:\image\blog\Snipaste_2020-11-12_09-33-02.png)

解：

<img src="D:\image\blog\Snipaste_2020-11-12_10-34-40.png" alt="Snipaste_2020-11-12_10-34-40" style="zoom:50%;" />

分情况讨论

- X来，获取X1不来的最大活跃度，X2不来的最大活跃度，X3不来的最大活跃度
- X不来，获取X1**来或不来**的最大活跃度，获取X2**来或不来**的最大活跃度，获取X3**来或不来**的最大活跃度





题：

判断一棵树是否是平衡二叉树



到此为止，树形dp的题结束

数据结构设计题，重不同不同数据结构之间的配合，轻算法设计

算法设计题，重在算法设计，轻在不同数据结构之间的配合

![Snipaste_2020-11-12_10-52-31](D:\image\blog\Snipaste_2020-11-12_10-52-31.png)

ps：LRU和LFU是两中缓存算法	

LRU：最近最少使用的缓存算法。缓存满时，优先删除最不常用（最长时间未被使用的）的缓存

LFU：最近最不常用的缓存算法。缓存满时，优先删除使用次数最少的缓存

![Snipaste_2020-11-12_12-51-21](D:\image\blog\Snipaste_2020-11-12_12-51-21.png)





![Snipaste_2020-11-12_13-34-17](D:\image\blog\Snipaste_2020-11-12_13-34-17.png)

自己的思路（栈）

逐渐解决以下几个问题

1. 怎么计算一个没有括号，没有乘除，只有加减的多项运算式
2. 怎么计算一个没有括号，有加减乘除的多项运算式
3. 怎么计算一个有括号，有加减乘除的多项运算式

解决思路：用栈

1. 读取一个数，入栈；读一个运算符，入栈；读一个数，将前两个运算符和数出栈。计算出res后将res入栈。循环此操作直到运算式为空
2. 仿照1，但是在有乘除时，遇到加减不做出栈和计算。遇到乘除做出栈和计算。运算式为空后，栈中数据连起来就是只有加减的运算式。执行1即可
3. 遇到加减乘除都不计算。遇到右括号时，出栈，直到弹出一个左括号。弹出的所有数据连一块就是一个运算式，执行2。将res压栈。

ps：res是负数时，需要为res手动添加括号括住。res通常是数字类型，而栈中数据通常是String类型，所以res入栈时是否需要类型转换视情况而定



教程的思路（50行代码）

部分实现用数组代替栈

将res放进结果变量

关于栈的操作。由于栈时用来保存运算式的，根据实际情况来看，不用栈，用数组和一个int类型的变量作为指向栈顶的指针



整体来看，自己的思路和教程的思路差不，都是先算括号里的，先算乘除，再算加减



![Snipaste_2020-11-12_14-51-16](D:\image\blog\Snipaste_2020-11-12_14-51-16.png)

- 暴力解。时间复杂度O(N^3)

![Snipaste_2020-11-13_12-20-13](D:\image\blog\Snipaste_2020-11-13_12-20-13.png)

- 加速解。时间复杂度O(N^2)

![Snipaste_2020-11-13_12-22-58](D:\image\blog\Snipaste_2020-11-13_12-22-58.png)

- 前缀树解.时间复杂度O(N)



核心流程代码

![Snipaste_2020-11-13_12-42-34](D:\image\blog\Snipaste_2020-11-13_12-42-34.png)





前缀数中的节点

![Snipaste_2020-11-13_12-41-41](D:\image\blog\Snipaste_2020-11-13_12-41-41.png)

NumTrie前缀树的代码

![Snipaste_2020-11-13_12-40-55](D:\image\blog\Snipaste_2020-11-13_12-40-55.png)

<img src="D:\image\blog\Snipaste_2020-11-13_13-27-07.png" alt="Snipaste_2020-11-13_13-27-07" style="zoom:50%;" />

## 跳表

完成的功能和红黑树，平衡树一样的。保存kv，取最大最小值。时间复杂度O（logN）。但是不是树结构

参考

- https://blog.csdn.net/zlx_code/article/details/90581451
- http://www.acmerblog.com/skip-list-impl-java-5773.html

> Java API中提供了支持并发操作的跳跃表ConcurrentSkipListSet和ConcurrentSkipListMap。下面摘录"[Java多线程（四）之ConcurrentSkipListMap深入分析](http://blog.csdn.net/vernonzheng/article/details/8244984)"中的一些结论。
>
> - 有序的情况下：
>   - 在非多线程的情况下，应当尽量使用TreeMap（红黑树实现）。
>   - 对于并发性相对较低的并行程序可以使用Collections.synchronizedSortedMap将TreeMap进行包装，也可以提供较好的效率。但是对于高并发程序，应当使用ConcurrentSkipListMap。
>
> - 无序情况下：
>   - 并发程度低，数据量大时，ConcurrentHashMap 存取远大于 ConcurrentSkipListMap。
>   - 数据量一定，并发程度高时，ConcurrentSkipListMap比ConcurrentHashMap效率更高。 





## 暴力递归转动态规划习题

所有无后效性的递归操作基本发都能转为动态规



例题：

有1~N个位置，一个机器人在M位置，能左右移动。一共能移动P步。问题：移动P步后，停留在K位置。这样一共有几种走法



![Snipaste_2020-11-13_18-05-53](D:\image\blog\Snipaste_2020-11-13_18-05-53.png)



![Snipaste_2020-11-13_18-29-24](D:\image\blog\Snipaste_2020-11-13_18-29-24.png)



![Snipaste_2020-11-13_20-09-55](D:\image\blog\Snipaste_2020-11-13_20-09-55.png)

![Snipaste_2020-11-14_13-54-07](D:\image\blog\Snipaste_2020-11-14_13-54-07.png)

