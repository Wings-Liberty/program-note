[算法稳定性分析](https://www.cnblogs.com/xinaixia/p/4444576.html)

[master定理求递归的时间复杂度](https://zhuanlan.zhihu.com/p/113406812)

# 时间空间复杂度

这里只讨论递归的时间空间复杂度

递归过程可以用手绘出一个多叉树，每个节点就是一个函数栈，一次递归会引出其他子递归（节点的子节点）

手绘构建出多叉树后，其程序执行过程就是后序遍历多叉树并执行其节点中的函数栈的过程

所以其递归用到的占空间和树高相同。其机算公式为

![[公式]](https://www.zhihu.com/equation?tex=T%28n%29%3DaT%28%5Cfrac%7Bn%7D%7Bb%7D%29%2Bf%28n%29%5C%5C)

- n 是问题规模大小。即 n 个数据
- a 是原问题的子问题个数。即一个递归会引出几个子递归（递归树的一个节点有几个子节点)
- n / b 是每个子问题的大小，这里假设每个子问题有相同的规模大小。（b = 每个递归处理了上个递归给的多少数据)
- f(n) = O(N<sup>d</sup>)是除子问题的调用之外，剩余的复杂度



```java
// 每次递归调用两个子递归，所以 a 是 2；每次递归处理父递归给的一般数据，所以 b 是 2；f(n) 包括判断 LR 是否相等和计算 mid，是 O(1)
public static int getMax(int[] arr) {
    return process(arr,0,arr.length);
}

public static int process(int[] arr, int L, int R) {
    // 如果只有一个数，直接返回
    if (L == R) return arr[L];
    int mid = L + ((R - L) >> 1);
    int leftMax = process(arr, L, mid);
    int rightMax = process(arr, mid + 1, R);
    return Math.max(leftMax, rightMax);
}
```

但不是所有的递归都能用 master 公式。比如子问题规模不同时，求数组前 1/3 中的最大值和后 2/3 中的最大值中的最大值。子问题规模不同

<img src="D:\image\blog\Snipaste_2021-12-30_17-48-12.png" alt="Snipaste_2021-12-30_17-48-12" style="zoom:80%;" />





# 常用的基本数据结构

- 链表
- 背包，队列，栈，二叉树，图

# 常用算法

- 排序
    桶，选择，插入，冒泡，归并，希尔，快排
    堆排序（包含优先队列），基数排序（索引计数排序，低位优先，高位优先排序）
    
- 查找
    二分，哈希表
    二叉搜索树，AVL树，2-3平衡查找树，红黑树
    前缀树/字典树
    深搜，广搜
    
- 最小生成树
    Prim（延迟和非延迟算法）
    Kruskal
    ps：都使用优先队列和贪心策略
    
- 最短路径（松弛）

    



## 其他数据结构和算法

- 拓扑排序
- KMP（子字符串搜索算法）
- Manacher（最大回文子字符串搜索算法）
- BFPRT（查找无序数组中第k大/小的元素）
- 滑动窗口（能实现快速返回子数组中最大/小值）
- 单调栈（查找离元素最近的较大/小元素的值）
- Morris 遍历（二叉树遍历算法。空间复杂度O(1)）
- 跳表（搜索算法。实现简单，性能与平衡树相近）
- 布隆过滤器
- 查并集
- [哈夫曼树](https://blog.csdn.net/qq_29519041/article/details/81428934)（贪心和最小堆实现，最小堆实现是非必须的，哈夫曼树的构造不是唯一的）







## 查找算法

查找算法主要根据应用场景不同，选择不同的查找算法

查找算法不做性能分析

- AVL树，红黑树，SB树

  维护树的深度尽量一致，减少查找时间

- 跳表

  非树结构，性能和AVL树，红黑树等树的性能相近，但是实现难度远低于上述的树



## 布隆过滤器

作用：查询某个元素是否存在于集合中

举例：做了一个黑名单，用户访问资源，先判断用户是否在黑名单里。

布隆过滤器的组成：一个大bit数组，多个hash函数



假设1表示存在，0表示不存在

查询一个key是否存在的流程

1. 遍历hash函数，key作为参数。获取一个多个下标
2. 如果下标在大bit数组中对应的元素值均为1，说明key存在于集合中



布隆过滤器一定存在失误率。一个不存在于集合中的元素，经过布隆过滤器查询后，可能返回结果是元素存在于集合中

这里说的集合就是布隆过滤器的大数组

当数组足够大时，；失误率会降低

关于布隆过滤器的失误率公式，此处不展示常用思想

- 回溯（常用递归或栈实现。递归的本质就是栈调用，但是递归能传递的信息更多）
- 分治（将大问题分解为相同的小问题，也常用递归实现）
- 动态规划（先尝试用暴力递归解，根据暴力递归中的重复计算，base case，条件判断和返回结果推出类似题解公式）
- 贪心策略。贪心策略多样化，证明正确性难度大。所以无需证明正确性，使用对数器验证后正确即为所求



## jdk提供的数据结构

- LinkedList  相当于单，双向链表，队列，栈
- ArrayList   动态数组
- HashMap，HashSet    哈希表
- TreeMap，TreeSet    树结构。底层是红黑树
- PriorityQueue。优先队列，实质是堆。构造对象时传递一个比较器，通过定义比较规则实现大根堆和小根堆
- ConcurrentSkipListMap，ConcurrentSkipListSet    跳表





## 例题



### 宏观解析问题



```
【题目】
两个单链表相交的一系列问题
单链表可能有环，也可能无环。给定两个 单链表的头节点 head1和head2，这两个链表可能相交，也可能 不相交。
请实现一个函数，如果两个链表相交，请返回相交的第一个节点；如果不相交，返回null即可。
【要求】
如果链表1的长度为N，链表2的长度为M，时间复杂度请达到 O(N+M)，额外空间复杂度请达到O(1)。

题解提示：
将问题分解为 判断单链表是否有环 两个无环链相交问题 两个有环链相交问题 一个无环和一个无环链表相交问题

如何判断单链表是否有环
- 哈希表解决
- 快慢指针解决
	快指针一次走两步，慢指针一次走一步。两个指针第一次在A点相遇，则有环
	快指针回到起点，快指针和慢指针都一次走一步。慢指针从A开始走。两指针相遇处就是单链表的入环节点
	
三种单链表的相交问题，分情况讨论即可
```



### 二叉树



经典二叉树中，节点只有值和左右节点。拓展的二叉树的节点可以有父节点，但是父节点的引用会占用空间



```java
【题目】
在二叉树中找到一个节点的后继节点
现在有一种新的二叉树节点类型如下：
public class Node {
	public int value;
	public Node left;
	public Node right;
	public Node parent;
	public Node(int data) { 
		this.value = data;
	}
}
该结构比普通二叉树节点结构多了一个指向父节点的parent指针。假设有一棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向自己的父节点，头节点的parent指向null。只给一个在二叉树中的某个节点node

【要求】求返回node的后继节点的函数。在二叉树的中序遍历的序列中，node的下一个节点叫作node的后继节点。
    
题解提示
通过执行中序遍历获取node的后继结点效率低，所以不遍历树
根据草图分析
    如果target节点有右节点，找右节点的最左子节点（不断获取左节点，直到左节点为空）
    如果target节点没有右节点
    	如果target是父节点的左节点，后继结点就是父节点
    	如果target是父节点的右节点，后继结点就是父节点所在的最左节点边界的顶级父节点
```

ps：除了后继结点，还有前驱节点



```
【题目】
折纸问题
请把一段纸条竖着放在桌子上，然后从纸条的下边向 上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕 突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。 

【要求】给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向。
		例如：N=1时，打印：down N=2时，打印：down down up
		
题解提示
折纸后发现，新折痕都被添加在旧折痕的两侧。符合树节点每次添加左右节点（符合中序遍历左中右的顺序）
```



```
【题目】判断一棵二叉树是否是平衡二叉树
题解提示
根据平衡二叉树定义，如果左右子树高度差的绝对值不超过1，就是平衡二叉树

【题目】判断一棵树是否是搜索二叉树

【题目】判断一棵树是否是完全二叉树
题解提示
如果某个节点只有右孩子没有左孩子，树不是完全二叉树
```



```
【题目】
已知一棵完全二叉树，求其节点的个数 
【要求】
时间复杂度低于O(N)，N为这棵树的节点个数

题解提示
以树是完全二叉树为前提
如果右子树不是满二叉树，左子树一定是满二叉树
如果右子树是满二叉树，左子树可能是满二叉树或完全二叉树
如此，可不完整遍历一遍二叉树
```



### 滑动窗口



```
【题目】
最大值减去最小值小于等于 num 的子数组数量
给定数组 arr 和整数 num，返回共有多少个数组满足如下情况：
max(arr[i.. j]) - min(arr[i.. j]) <= num
max(arr[i.. j]) 表示子数组 arr[i.. j] 中的最大值，min(arr[i.. j]) 表示子数组 arr[i.. j] 中的最小值
【要求】如果数组长度为N，请事先时间复杂度为O(N)的解法

题解提示
子数组是连续的元素组成的数组，不是所有非空子集
```



### 单调栈



```
【题目】
求最大子矩阵的大小
给定一个整形矩阵map，其中的值只有0和1两种，求其中全是1的所有矩形区域中，最大的矩形区域为1的数量
例如：
1 1 1 0
其中，最大的矩形区域有3个1，所以返回3
再如
1 0 1 1
1 1 1 1
1 1 1 0
其中，最大的矩形区域有6个1，所以返回6
```



```
【题目】
给一个数组，在UI上，数组组成一个环（逆时针还是顺时针组成的都无所谓），每个数字都代表一座山峰，山峰上有烽火
规则
1. 相邻的两座山能互相看见对方的烽火
2. 不相邻的两座山，如果它们之间的山的数字不比这里两座山的数字都大，那么它们也能互相看见烽火（两座不相邻的两座山能顺时针或逆时针看烽火）
如：
[1,2,4,5,3]
1,2相邻，能看见。14不相邻，且2>1，所以1，4不能看见
3，2不相邻，3，2均大于1，所以3，2能看见

【要求】给一个数组，有几对山能互相看见

题解提示
- 如果数组中没有重复的元素。答案为`2*i-3`对。公式推导视频上有
- 如果有重复的元素。用单调栈。每次弹栈的时候，对数加`C(2,k) + 2*k`。如果栈底只有一个元素，且times=1，则加`C(2,k) + k`，如果是栈底，则加`C(2,k)`   C()是排列组合
```





### 其他例题

最长累加和问题

```
【题目】 给一个整数数组，数组中能包含正整数，负整数，0。给一个整数aim。

【问题】 求和为aim的最长子数组的长度

题解提示
i是当前下标
res是arr中下标0~i的元素值和
sum[n] 是arr中下标0~n的元素值和
求以arr[i]结尾且和为aim的最长子数组的方法是查询sum[]中是否包含res-aim的结果。（sum[]实际使用时用map实现k是下标，v是0~k的元素和）


【变形题目】 一个数组中，有奇数和偶数，问奇数，偶数数量相同的最长子数组的长度

题解提示
将奇数改为1，偶数改为-1。aim是0.使用上述题目使用方法即可
```



```
【题目】 给一个整数数组，数组中只包含正整数。给一个整数aim。

【问题】 时间复杂度O(N)，空间复杂度O(1)求和为aim的最长子数组的长度。

题解提示
滑动窗口。比上一题简单
```



```
【题目】
定义数组的异或和的概念
数组中所有的数异或起来，得到的结果叫做数组的异或和
比如：数组{3,2,1}的异或和是，3^2^1 = 0
给定一个数组arr，你可以任意把arr分成很多不相容的子数组，你的目的是，分出来的子数组中，异或和为0的子数组最多

【问题】
请返回，分出来的子数组中，异或和为0的子数组最多是多少？
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190319223106372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FqaDU2MDY=,size_16,color_FFFFFF,t_70)

```
i有两种情况，
第一，i所在的划分区间，异或不为0；
第二，i所在的划分区间，异或为0。
对于第一种情况dp[i] = dp[i-1]的。0~i和0~i-1的最优划分结果都一样，因为有array[i]不能让最后一个划分区间结果为0，没有array[i]，最后一个划分区间结果还是不为0
对于第二种情况，假设i的最优划分区间是[k,i]，0到i的连续异或为sum，要求出一个最大的下标k-1，使得0到k-1的异或也为sum就行了
```

```
dp记录从左到右每增加一个数后数组划分得到的最大划分数量
```

```java
public static int mostXOR(int[] arr) {
    int ans = 0;
    int xor = 0;
    HashMap<Integer, Integer> map = new HashMap<>();
    map.put(0, -1);
    int[] dp = new int[arr.length];
    for (int i = 0; i < arr.length; i++) {
        xor ^= arr[i];
        if (map.containsKey(xor)) {
            int pre = map.get(xor);
            dp[i] = pre == -1 ? 1 : dp[pre] + 1;
        }
        if (i > 0) {
            dp[i] = Math.max(dp[i], dp[i - 1]);
        }
        map.put(xor, i);
        ans = Math.max(ans, dp[i]);
    }
    return ans;
}
```



二叉树的问题多用递归，而无后效性的递归通常能修改为动态规划

```
【题目】
给定一棵二叉树的头节点head，请返回最大搜索二叉子树的大小

题解分析
node下的最大搜索二叉子树，可能在左节点或右节点，或左右节点+node组成最大搜索二叉树
```



```
【题目】
一个公司的上下级关系是一个多叉树，这个公司要举办晚会，你作为组织者已经摸清了大家的心理：一个员工的直接上级如果到场，这个员工肯定不会来，每个员工都有一个活跃的值，决定谁来你会给这个员工发邀请函，怎么让误会的七分最活跃？返回最大活跃值

举例：
给定一个矩阵来描述这种关系
matrix = {
    {1,6}.
    {1,5}.
    {1,4}
}
矩阵含义是：
matrix[0] = {1,6} 表示0这个员工的直接上级为1，0这个员工自己的活跃度为6
为例让晚会活跃度最大，应该让1不来，0和2来，最后返回活跃度为10

题解提示
分情况讨论。举例，X下有三个员工X1,X2,X3
- X来，获取X1不来的最大活跃度，X2不来的最大活跃度，X3不来的最大活跃度
- X不来，获取X1来或不来的最大活跃度，获取X2来或不来的最大活跃度，获取X3来或不来的最大活跃度
```



算法设计题

```
【题目】
设计LRU缓存结构
设计一种缓存结构，该结构在构造时确定大小，假设大小为K，并有两个功能：set(key,value)  get(key)

【要求】
1. set和get方法的时间复杂度为O(1)
2. 某个key的set或get操作一旦发生，认为这个key的记录成了最经常使用的
2. 当缓存的大小超过k时，溢出最不经常使用的记录，即set或get最久远的key和value

题解提示
set和get时间复杂度的限制，说明要用map作为缓存的数据结构
又要记录key的使用记录，可以直接使用map中的对象作为node建立链表，链表头是最久的key
当发生set或get时，将node移动到链表末尾即可

ps：LRU和LFU是两中缓存算法	
LRU：最近最少使用的缓存算法。缓存满时，优先删除最不常用（最长时间未被使用的）的缓存
LFU：最近最不常用的缓存算法。缓存满时，优先删除使用次数最少的缓存
```



```
【问题】
计算器
给定一个字符串str，str表示以一个公式，公式里可能有整数，加减乘除符号和左右括号，返回公式的计算结果
【举例】
str="48*((70-65)-43)+8*1"，返回-1816
str="3+1*4"，返回7
【说明】
1. 给的字符串一定是正确的公式，即不需要对str做公式有效性检查
2. 如果是负数，就需要用括号括起来，比如"4*(-3)
3. 不考虑计算过程中会发生溢出的情况

题解提示
1. 怎么计算一个没有括号，没有乘除，只有加减的多项运算式
2. 怎么计算一个没有括号，有加减乘除的多项运算式
3. 怎么计算一个有括号，有加减乘除的多项运算式

解决思路：用栈

1. 读取一个数，入栈；读一个运算符，入栈；读一个数，将前两个运算符和数出栈。计算出res后将res入栈。循环此操作直到运算式为空
2. 仿照1，但是在有乘除时，遇到加减不做出栈和计算。遇到乘除做出栈和计算。运算式为空后，栈中数据连起来就是只有加减的运算式。执行1即可
3. 遇到加减乘除都不计算。遇到右括号时，出栈，直到弹出一个左括号。弹出的所有数据连一块就是一个运算式，执行2。将res压栈。

ps：res是负数时，需要为res手动添加括号括住。res通常是数字类型，而栈中数据通常是String类型，所以res入栈时是否需要类型转换视情况而定
```



其他题目

```
【问题】
给定一个数组，求子数组的最大异或和
一个数组的异或和为，数组中所有的数组异或起来的结果

题解提示
1. 暴力解。时间复杂度O(N^3)
2. 记忆化搜索/动态规划。时间复杂度O(N^2)
3. Triee。时间复杂度O(N)
讲3

当前下标为i，eor为0~i的异或和
Triee中保存
0~1
0~2
0~3
0~i-1
的异或和的二进制

eor ^ 0~n的异或和 得到的结果是n~i的异或和。
有符号二进制中高位尽可能是1，数就越大（负数也是）
每次计算eor后，将eor转为二进制，进入Triee中，尽可能让每一位异或的结果得到1，得到的异或和就是i结尾的子数组中异或和最大的结果
```



暴力递归转动态规划



```
【问题】
给定一个数组arr，值可正，可负，可0；一个整数aim，求累加和小于等于aim的最长子数组
【要求】 时间复杂度O(N)

题解提示
min_sum[]  min_sum_index[]
第一次遍历arr。从右到左，累加，将累加和不再增加的数组成子数组，将累加和的值和子数组首元素下标计入上述两个数组
以上述子数组为单位整合滑动窗口进行
```





```
【题目】
字符串匹配问题
给定字符串str，其中绝对不含有字符'.'和'*'。再给定字符串exp，其中可以含有'.'或'*'，'*'字符不能是exp的首字符，并且任意两个'*'字符不相邻。exp中的'.'代表任何一个字符，exp中的'*'表示'*'的前一个字符可以有0个或者多个。请写一个函数，判断str是否能被exp匹配。

【举例】
str="abc"，exp="abc"，返回true。
str="abc"，exp="a.c"，exp中单个'.'可以代表任意字符，所以返回true。
str="abcd",exp=".*"。exp中'*'的前一个字符是'.'，所以可表示任意数量的'.'字符，当exp是"...."时与"abcd"匹配，返回true。
str=""，exp="..*”。exp中'*'的前一个字符是'.'，可表示任意数量的'.'字符，但是".*"之前还有一个'.'字符，该字符不受'*'的影响，所以str起码有一个字符才能被exp匹配。所以返回false。

题解提示
暴力递归
由于'*'的特殊性，每次获取一个匹配规则的时候，获取exp的下下一个字符，如果是'*'特殊处理，如果不是，直接根据exp的下一个字符和str进行匹配
如果是'*'，进行下一个匹配规则的匹配，匹配失败就用'*'吃掉
改动态规划
```



ps：目前学过的查找算法中，时间复杂度为O(1)的是哈希表和前缀树



### 例题

![image-20220205210612730](https://gitee.com/wingsofliberty/study-node-imgs/raw/master/img/image-20220205210612730.png)



### 贪心策略

[参考博客](https://www.cnblogs.com/mogeko/p/11762212.html)

 

### 博弈论

可选

[参考博客](https://www.cnblogs.com/674001396long/p/9901811.html)



## 待学习

习题：纸牌博弈问题

一致性哈希

