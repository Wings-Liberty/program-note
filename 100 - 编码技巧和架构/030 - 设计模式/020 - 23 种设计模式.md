#正在复习 

# 创建型模式

创建模式里就工厂和建造者模式有深入学习的价值，其他几种模式早就融入日常使用，已经没有学习的必要

## 单例模式

很常用的模式，无需赘述

![[../../020 - 附件文件夹/Pasted image 20230422173102.png]]

详细介绍参考[[../../021 - 离线网页备份文件夹/设计模式 - 单例模式.html|单例模式]]

## 简单工厂

客户端创建或获取对象时，只持有接口声明，不关心对象的具体实现类即可

![[../../020 - 附件文件夹/Pasted image 20230422181158.png]]

详细介绍参考[[../../021 - 离线网页备份文件夹/设计模式 - 简单工厂.html|简单工厂模式]]

## 抽象工厂

抽象工厂本质上是多个简单工厂的组合

![[../../020 - 附件文件夹/Pasted image 20230422181558.png]]

详细介绍参考[[../../021 - 离线网页备份文件夹/设计模式 - 抽象工厂.html|抽象工厂]]

## 建造者模式

和工厂不同的是，工厂模式入参通常需要一个 code 或一个类型就能返回一个对象，对象的具体类是什么根据入参而定

但建造者模式是用来构建复杂对象

![[../../020 - 附件文件夹/Pasted image 20230422183006.png]]

举个买电脑的例子

- 工厂模式：我告诉工厂我要联想的电脑还是华硕的电脑，工厂就会给我一个对应品牌和型号的电脑
- 建造者模式：我告诉建造者我的电脑要三星 32G 内存条，13 代 i7 的CPU，长江存储的 1T 固态，建造者根据生产电脑的模板流程生产电脑，但每一步的选材都是有客户端自定义的

所以我对建造者模式的理解是：建造者 = 模板模式 + 有更多入参的工厂模式，并用于构建复杂对象

[[../../021 - 离线网页备份文件夹/设计模式 - 建造者模式.html|建造者模式]]里的例子不太好，回头找到好示例和应用后换掉参考文档


## 原型模式

根据一个原始对象克隆一个对象，说白了就是 Cloneable 的理论知识，是一个和迭代器模式一样的，已经很自然地用在所有地方的简单模式

![[../../020 - 附件文件夹/Pasted image 20230422220854.png]]

详情参考[[../../021 - 离线网页备份文件夹/设计模式 - 原型模式.html|原型模式]]

## 结构模式

## 适配器模式

将一个类的接口转换成客户端希望的另外一个接口。使原本由于接口不兼容而不能一起工作的那些类可以一起工作。

适配器模式有“**类适配器**”和“**对象适配器**”两种不同的形式

详情参考[[../../021 - 离线网页备份文件夹/设计模式 - 适配器模式.html|适配器模式（也叫包装模式）]]

### 类适配器

![[../../020 - 附件文件夹/Pasted image 20230422221535.png]]

举个例子，客户端想把 RedisTemplate 当成一个 Cache 用，就创建一个 RedisCacheAdapter，它实现了 Cache 接口又继承了 RedisTemplate

客户端创建了一个 Cache 对象，但实际上它的实现类是 RedisCacheAdapter，就实现了缓存在 Redis里。于是就可以称 Redis 被**适配**成了 Cache

### 对象适配器

和类适配器不同的是，适配器实现类拥有源对象的能力是通过持有源对象（适配器有一个成员变量），而不是自己就是源对象（适配器继承了源对象）

![[../../020 - 附件文件夹/Pasted image 20230422222246.png]]

举个例子，还是刚才的例子，客户端想把 RedisTemplate 当成一个 Cache 用，就创建一个 RedisCacheAdapter，它实现了 Cache 接口，并持有一个 RedisTemplate 的成员变量

客户端创建了一个 Cache 对象，但实际上它的实现类是 RedisCacheAdapter，就实现了缓存在 Redis里。于是就可以称 Redis 被**适配**成了 Cache


## 桥接模式

桥接模式是为了实现将抽象部分与它的实现部分分离，使它们都可以独立地变化

![[../../020 - 附件文件夹/Pasted image 20230422222918.png]]

简单地说就是依赖倒转原则和聚合复用原则的组合使用

1. 在 A 接口里用另一个 B 接口，而不是用另一个 B 的实现类 b
2. A 的实现类里也都是模板方法，并通过持有一个 B 的成员变量，在模板里控制 B 的行为

举个例子，假设我规定一个和数据库打交道的接口体系

```java
public interface DataSource {

	void setUrl(String url);

	void setUsername(String username);

	void setPassword(String password);

	Connection getConnection();
}

public interface Connection {

	Result invoke(String commond);
	
}

public interface Result {

	Integer getStatusCode();
	
}

public abstract DataSourceImpl {

	private Connector connector;

	public Connection getConnection(){
		// 获取 url，用户名，密码
		...
		// 根据 url 里设置的协议类型调用不同的客户端建立连接
		return connector.connect(url, username, password);
	};
}
```


然后 MySQL，Redis，ClickHouse 为了适配我的接口体系，都实现了 Connector 接口

我的理解是：桥接模式有点像模板模式，也有点像建造者模式。或者说它是这两个模式的组合也不为过

详情参考[[../../021 - 离线网页备份文件夹/设计模式 - 桥接模式.html|桥接模式]]

## 组合模式

将对象组合成树形结构以表示“部分-整体”的层次结构，用户对单个对象和组合对象的使用具有一致性

举个例子，Flowable 里不管是节点还是线条，他们都实现了 FlowElement 接口，都拥有 `getResourceId()` 的能力。当我持有一个开始节点的时候，我可以认为我持有了一整个流程图，因为我能通过开始节点遍历到整个流程图里的所有节点

再举个例子，数据结构 - 树，实际上有两种类型的节点：叶子节点和非叶子节点，非叶子节点可以指向其他叶子节点或非叶子节点

在用数据结构 - 树的时候，我们经常通过持有一个节点变量，就视为我持有了一个节点对象或一整个子树

组合模式有两种不同的实现，分别为透明模式和安全模式

### 透明模式

透明模式是**把组合使用的方法放到抽象类中**，不管叶子对象还是树枝对象都有相同的结构，这样做的好处就是叶子节点和树枝节点对于外界没有区别，它们具备完全一致的行为接口

**但因为Leaf类本身不具备add()、remove()方法的功能，所以实现它是没有意义的**（这也是透明模式的缺点）。UML结构图如下

![[../../020 - 附件文件夹/Pasted image 20230422225043.png]]

### 安全模式

安全模式是把树枝节点和树叶节点彻底分开，树枝节点单独拥有用来组合的方法，这种方法比较安全。但由于不够透明，所以树叶节点和树枝节点将不具有相同的接口，客户端的调用需要做相应的判断，带来了不便

![[../../020 - 附件文件夹/Pasted image 20230422230211.png]]

Flowable 用的就是安全模式

- 任务节点，线条，事件都实现了 FlowableElement
- 任务节点实现了 FlowNode
- 线条实现了 Sequence
- 事件实现了 Event

这样他们就都拥有 FlowableElement 的特性，又拥有各自的特性。但是客户端拿到的流程定义里的节点对象通常都是 `List<FlowableElement>`，所以为了能用任务节点的特性，需要客户端自行判断每个对象的实际类型是不是 FlowNode

该复习装饰模式了。https://www.cnblogs.com/adamjwh/p/9033545.html