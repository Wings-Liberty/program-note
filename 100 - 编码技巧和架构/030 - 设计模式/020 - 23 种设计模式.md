#正在复习 

# 创建型模式

创建模式里就工厂和建造者模式有深入学习的价值，其他几种模式早就融入日常使用，已经没有学习的必要

## 单例模式

很常用的模式，无需赘述

![[../../020 - 附件文件夹/Pasted image 20230422173102.png]]

详细介绍参考[[../../021 - 离线网页备份文件夹/设计模式 - 单例模式.html|单例模式]]

## 简单工厂

客户端创建或获取对象时，只持有接口声明，不关心对象的具体实现类即可

![[../../020 - 附件文件夹/Pasted image 20230422181158.png]]

详细介绍参考[[../../021 - 离线网页备份文件夹/设计模式 - 简单工厂.html|简单工厂模式]]

## 抽象工厂

抽象工厂本质上是多个简单工厂的组合

![[../../020 - 附件文件夹/Pasted image 20230422181558.png]]

详细介绍参考[[../../021 - 离线网页备份文件夹/设计模式 - 抽象工厂.html|抽象工厂]]

## 建造者模式

和工厂不同的是，工厂模式入参通常需要一个 code 或一个类型就能返回一个对象，对象的具体类是什么根据入参而定

但建造者模式是用来构建复杂对象

![[../../020 - 附件文件夹/Pasted image 20230422183006.png]]

举个买电脑的例子

- 工厂模式：我告诉工厂我要联想的电脑还是华硕的电脑，工厂就会给我一个对应品牌和型号的电脑
- 建造者模式：我告诉建造者我的电脑要三星 32G 内存条，13 代 i7 的CPU，长江存储的 1T 固态，建造者根据生产电脑的模板流程生产电脑，但每一步的选材都是有客户端自定义的

所以我对建造者模式的理解是：建造者 = 模板模式 + 有更多入参的工厂模式，并用于构建复杂对象

[[../../021 - 离线网页备份文件夹/设计模式 - 建造者模式.html|建造者模式]]里的例子不太好，回头找到好示例和应用后换掉参考文档


## 原型模式

根据一个原始对象克隆一个对象，说白了就是 Cloneable 的理论知识，是一个和迭代器模式一样的，已经很自然地用在所有地方的简单模式

![[../../020 - 附件文件夹/Pasted image 20230422220854.png]]

详情参考[[../../021 - 离线网页备份文件夹/设计模式 - 原型模式.html|原型模式]]

# 结构模式

## 适配器模式

将一个类的接口转换成客户端希望的另外一个接口。使原本由于接口不兼容而不能一起工作的那些类可以一起工作。

适配器模式有“**类适配器**”和“**对象适配器**”两种不同的形式

详情参考[[../../021 - 离线网页备份文件夹/设计模式 - 适配器模式.html|适配器模式（也叫包装模式）]]

### 类适配器

![[../../020 - 附件文件夹/Pasted image 20230422221535.png]]

举个例子，客户端想把 RedisTemplate 当成一个 Cache 用，就创建一个 RedisCacheAdapter，它实现了 Cache 接口又继承了 RedisTemplate

客户端创建了一个 Cache 对象，但实际上它的实现类是 RedisCacheAdapter，就实现了缓存在 Redis里。于是就可以称 Redis 被**适配**成了 Cache

### 对象适配器

和类适配器不同的是，适配器实现类拥有源对象的能力是通过持有源对象（适配器有一个成员变量），而不是自己就是源对象（适配器继承了源对象）

![[../../020 - 附件文件夹/Pasted image 20230422222246.png]]

举个例子，还是刚才的例子，客户端想把 RedisTemplate 当成一个 Cache 用，就创建一个 RedisCacheAdapter，它实现了 Cache 接口，并持有一个 RedisTemplate 的成员变量

客户端创建了一个 Cache 对象，但实际上它的实现类是 RedisCacheAdapter，就实现了缓存在 Redis里。于是就可以称 Redis 被**适配**成了 Cache


## 桥接模式

桥接模式是为了实现将抽象部分与它的实现部分分离，使它们都可以独立地变化

![[../../020 - 附件文件夹/Pasted image 20230422222918.png]]

简单地说就是依赖倒转原则和聚合复用原则的组合使用

1. 在 A 接口里用另一个 B 接口，而不是用另一个 B 的实现类 b
2. A 的实现类里也都是模板方法，并通过持有一个 B 的成员变量，在模板里控制 B 的行为

举个例子，假设我规定一个和数据库打交道的接口体系

```java
public interface DataSource {

	void setUrl(String url);

	void setUsername(String username);

	void setPassword(String password);

	Connection getConnection();
}

public interface Connection {

	Result invoke(String commond);
	
}

public interface Result {

	Integer getStatusCode();
	
}

public abstract DataSourceImpl {

	private Connector connector;

	public Connection getConnection(){
		// 获取 url，用户名，密码
		...
		// 根据 url 里设置的协议类型调用不同的客户端建立连接
		return connector.connect(url, username, password);
	};
}
```


然后 MySQL，Redis，ClickHouse 为了适配我的接口体系，都实现了 Connector 接口

我的理解是：桥接模式有点像模板模式，也有点像建造者模式。或者说它是这两个模式的组合也不为过

详情参考[[../../021 - 离线网页备份文件夹/设计模式 - 桥接模式.html|桥接模式]]

## 组合模式

将对象组合成树形结构以表示“部分-整体”的层次结构，用户对单个对象和组合对象的使用具有一致性

举个例子，Flowable 里不管是节点还是线条，他们都实现了 FlowElement 接口，都拥有 `getResourceId()` 的能力。当我持有一个开始节点的时候，我可以认为我持有了一整个流程图，因为我能通过开始节点遍历到整个流程图里的所有节点

再举个例子，数据结构 - 树，实际上有两种类型的节点：叶子节点和非叶子节点，非叶子节点可以指向其他叶子节点或非叶子节点

在用数据结构 - 树的时候，我们经常通过持有一个节点变量，就视为我持有了一个节点对象或一整个子树

组合模式有两种不同的实现，分别为透明模式和安全模式

### 透明模式

透明模式是**把组合使用的方法放到抽象类中**，不管叶子对象还是树枝对象都有相同的结构，这样做的好处就是叶子节点和树枝节点对于外界没有区别，它们具备完全一致的行为接口

**但因为Leaf类本身不具备add()、remove()方法的功能，所以实现它是没有意义的**（这也是透明模式的缺点）。UML结构图如下

![[../../020 - 附件文件夹/Pasted image 20230422225043.png]]

### 安全模式

安全模式是把树枝节点和树叶节点彻底分开，树枝节点单独拥有用来组合的方法，这种方法比较安全。但由于不够透明，所以树叶节点和树枝节点将不具有相同的接口，客户端的调用需要做相应的判断，带来了不便

![[../../020 - 附件文件夹/Pasted image 20230422230211.png]]

Flowable 用的就是安全模式

- 任务节点，线条，事件都实现了 FlowableElement
- 任务节点实现了 FlowNode
- 线条实现了 Sequence
- 事件实现了 Event

这样他们就都拥有 FlowableElement 的特性，又拥有各自的特性。但是客户端拿到的流程定义里的节点对象通常都是 `List<FlowableElement>`，所以为了能用任务节点的特性，需要客户端自行判断每个对象的实际类型是不是 FlowNode


## 装饰模式

动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更灵活

![[../../020 - 附件文件夹/Pasted image 20230423215930.png]]

JDK 的 IO 流就充分用了装饰模式。单一职责下，为了提高 IO 性能，用 BufferInputStream/BufferOutputStream 增强原有的 IO 流，令其在原来的基础上添加上缓冲区，以便提高读写性能

详情参考[[../../021 - 离线网页备份文件夹/设计模式 - 装饰器模式.html|装饰模式]]


## 外观模式

为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

![[../../020 - 附件文件夹/Pasted image 20230423220500.png]]

简单地说就是封装，比如 Mybatis 的 API 比较复杂，为了简化它就有了 Mybatis-Plus。Plus 封装了一个复杂的框架，向用户提供了容错性更强，更友好的 API

详情参考[[../../021 - 离线网页备份文件夹/设计模式 - 外观模式.html|外观模式]]

## 享元模式

池技术就是享元模式的应用。String 常量池、数据库连接池、缓冲池等等都是享元模式的应用

![[../../020 - 附件文件夹/Pasted image 20230423220901.png]]

通常客户端会持有一个享元工厂，通过 `getFlyWeight(key)` 传递一个外部状态的参数，获取一个对象，或让池中对象执行一件事，但是客户端并不需要知道获取的是池中哪个对象，或执行任务的是哪个对象

拓展性比较强的享元工厂还能设置不使用享元，也就是获取一个新创建的对象或专门创建一个对象执行任务

比如线程池，交给线程池一个 `Runnable`，由线程池内部实现线程调度，线程池作为门面和客户端交互

比如 Spring IOC，创建 bean 可以是单例的，也可以是多例的，甚至能控制多例是请求级别的或是会话级别的

详情见[[../../021 - 离线网页备份文件夹/设计模式 - 享元模式.html|享元模式]]


## 代理模式

AOP，事务等技术的实现方式多为代理模式

![[../../020 - 附件文件夹/Pasted image 20230423221651.png]]

代理有动态代理和静态代理两种，不过本质是一样的

乍一看，上图代理模式，适配器模式，装饰模式都很像，但其目的均不相同

- 与适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口
- 与装饰模式区别：装饰模式是为了增强功能，而代理模式是为了加以控制

举个例子适配器的例子，像把 RedisTemplate 当成 Cache 用，这个肯定只能用适配器模式，因为代理模式和装饰模式都不能改变源对象对外的类型，他们的目的是让客户端以为用了 RedisTemplate，实际上为了提高效率，装饰器或代理令其具有了批处理的功能来提高性能

不过暂时还举不出能很好区别代理模式和装饰器的例子

详情见[[../../021 - 离线网页备份文件夹/设计模式 - 代理模式.html|代理模式]]

## 行为型模式

