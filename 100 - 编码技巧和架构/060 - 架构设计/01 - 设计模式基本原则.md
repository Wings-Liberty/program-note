#还没有复习 

[设计模式 Demo](https://gitee.com/adamjiangwh/GoF)

接下来将逐步的介绍一下常用的23种设计模式及其它的一些设计模式，每一个设计模式都配有模板代码和简单测试用例方便理解


# 什么是设计模式

设计模式是一套被反复使用的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。

# 设计模式的基本原则

## 单一职责原则

类的**职责要单一**

**如果一个类承担的职责过多，就等于把这些职责耦合在一起**

一个职责的变化可能会削弱或者抑制这个类完成其它职责的能力


## 开闭原则

软件实体**可扩展，但不可修改**

简单地说就是**最好只需要加代码，而不是改代码**


## 依赖倒转原则

**高层模块不应该依赖底层模块**，两个都应该依赖抽象

说白了就是**面向接口编程**

举个例子，一个通信中间件需要支持多种序列化方式，每种序列化方式都要有个实体类，但中间件核心代码应该抽象出一个 Msg 类，这个 **Msg 类是消息的实体类，但不具体对应某种序列化方式**

Msg **不一定非得是接口**，**也可以是**中间件自己维护的**一个具体的类**


## 里氏代换原则 

子类必须能提供父类约定的功能


## 接口隔离原则

**接口尽量细化**，同时**接口中的方法尽量少**


## 迪米特法则 / 最少知识原则

一个类对自己依赖的类知道的越少越好；一个对象应该对其他对象有最少的了解

换句话说，每个类都应该尽量降低成员的访问权限，强调了类之间的松耦合

## 合成 / 聚合复用原则

尽量使用合成 / 聚合，尽量不要使用类继承。

- 合成表示一种**强的 “拥有” 关系**，体现了严格的部分与整体的关系，他们的生命周期相同

- 聚合表示一种**弱的 “拥有” 关系**，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分

这里再举个简单的例子，大雁与翅膀是合成关系；而每只大雁都属于一个雁群，即一个雁群可以有多只大雁，所以大雁和雁群是聚合关系。

# 设计模式的类型

常见的设计模式有 23 种，这些模式可分为三大类：

- 创建型模式：创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象

- 结构型模式：结构型模式主要关注类和对象的组合

- 行为型模式：行为型模式特别关注对象间的通信


## 创建型

- [x] [单例模式](http://www.cnblogs.com/adamjwh/p/9033554.html)
- [x] [工厂方法模式](http://www.cnblogs.com/adamjwh/p/9033553.html)（工厂模式）
- [x] [抽象工厂模式](http://www.cnblogs.com/adamjwh/p/9033552.html)
- [x] [建造者模式](http://www.cnblogs.com/adamjwh/p/9033551.html)（生成器模式）
- [x] [原型模式](http://www.cnblogs.com/adamjwh/p/9033550.html)（其实就是深拷贝，浅拷贝）

## 结构型 
- [x] [适配器模式](http://www.cnblogs.com/adamjwh/p/9033549.html)（变压器模式/包装模式）
- [x] [桥接模式](http://www.cnblogs.com/adamjwh/p/9033548.html)（桥梁模式）：功能实现类和接口实现类分离（对，就是功能实现类和接口实现类不是同一个继承体系，它们仅通过合成 / 聚合桥接）
- [x] [组合模式](http://www.cnblogs.com/adamjwh/p/9033547.html)（合成模式/部分-整体模式）
- [x] [装饰模式](http://www.cnblogs.com/adamjwh/p/9036358.html)（装饰器模式）
- [x] [外观模式](http://www.cnblogs.com/adamjwh/p/9048594.html)（门面模式，好像没有啥太大的用处，不如直接用装饰模式）
- [x] [享元模式](http://www.cnblogs.com/adamjwh/p/9070107.html)（经典的实现就是池化，复用对象。这个池化和 IOC 还不太一样，这个池里的元素可以是有状态的，比如线程池，连接池。但 IOC 也是一种享元模式的实现）
- [x] [代理模式](https://www.cnblogs.com/adamjwh/p/9102037.html)（委托模式）

PS：代理模式经常做和目标方法无关的事，比如用 AOP 记录日志，这没有改变目标方法。装饰模式用于增强方法，比如 IO 流的装饰器，让 io 流添加了文件读写，buffer 读写能力。而且有些代理不能层层嵌套（因为会让创建和调用代理的代码变很复杂），装饰器能

## 行为型

- [x] [观察者模式](https://www.cnblogs.com/adamjwh/p/10913660.html)（发布订阅模式）
- [x] [模板方法模式](https://www.cnblogs.com/adamjwh/p/10919149.html)
- [x] [命令模式](https://www.cnblogs.com/adamjwh/p/10923122.html)（命令模式里有四个角色，类似“boss 告诉助理让某个员工做工作 b ”，boss 就是 client，助理是 client 直接控制的对象，工作 b 是 client 下的命令。最终命令是谁执行的，client 不关心，让助理自己找人。实现调用者和执行者解耦，中间工作由助理搭线）
- [x] [状态模式](https://www.cnblogs.com/adamjwh/p/10926952.html)（不是策略模式，但 context 会持有一个 status 对象，且当 context 调用方法时，status 可能会根据被调用的方法做状态切换）
- [x] [职责链模式](https://www.cnblogs.com/adamjwh/p/10932216.html)（责任链模式）
- [x] [解释器模式](https://www.cnblogs.com/adamjwh/p/10938852.html)（和编译原理的解释器类似，让解释器去解释和执行 command / expression。SpringSecurity 的 AuthenticationManager 也一样，让能解析此 token 的解析器去解析，具体怎么解析的，我不管）
- [x] [中介者模式](https://www.cnblogs.com/adamjwh/p/10959987.html)（是中间件的顶级思想，比如 nacos、mq、zk，消费者和生产者互不认识，它们只认识自己的中间件，仅通过中间件进行联系。中间件起协调，转发的作用）
- [x] [访问者模式](https://www.cnblogs.com/adamjwh/p/10968634.html)（没太懂）
- [x] [策略模式](https://www.cnblogs.com/adamjwh/p/11011095.html)（政策模式）
- [x] [备忘录模式](https://www.cnblogs.com/adamjwh/p/11018268.html)（感觉不常用。是一个用于保存对象当前状态的模式，直接用 clone 不也行吗...）
- [x] [迭代器模式](https://www.cnblogs.com/adamjwh/p/11024311.html)


工厂 + 策略 + 模板 + 享元经常一块搭配。工厂生产不同的策略，享元缓存策略对象，策略类都有一个抽象父类，抽象父类里有模板，方法实现交给子类