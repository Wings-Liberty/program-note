#还没有复习 

> 此笔记只涉及使用方式，不涉及部署，配置和架构设计


调度中心和执行器是两个服务，需要独立运行且均支持集群


执行器服务的配置文件里需要指定调度中心的地址


执行器是业务微服务需要导入的依赖，执行器组件可以 Spring Bean 的方式放到容器里


任务执行模式以 Java Bean 模式居多


创建任务后，把任务放到任务执行器里即可


任务创建方式

- 实现一个 IJobHandler，并手动注册到执行器，执行器会把任务发到调度中心，调度中心把任务分配给某个执行器

```java
XxlJobExecutor.registJobHandler("demoJobHandler", new DemoJobHandler());
```

这种方式不要求 Spring 容器环境

- @XxlJob 注解修饰无参无返回值，声明抛出 Exception 的方法，在 XXL-Job Web UI 新建任务并绑定 @XxlJob 的方法


任务的详细属性见文档


调度中心维护一个在线的执行器列表。执行器想要被调度中心管理有两种方式

- 自动注册：执行器服务主动向调度中心注册
- 手动录入：在调度中心配置一个执行器服务的地址，调度中心和执行器联通以后就算是绑定成功了


在 xxl-job 的 Web UI 上创建一个任务以后，~~默认任务不会直接启动~~

- 启动 / 停止 按钮：根据任务模板创建一个任务实例并开始执行，执行时遵守任务属性中的重试次数，执行周期。这个任务实例不会影响本任务模板的其他任务实例
- 执行 按钮：执行一次任务。不管成功与否也不再执行


xxl-job 的任务终止方式是给执行器执行 job 的线程 Interrupt 中断信号。所以 job 所在的线程及其自行创建的子线程都不应该 catch InterruptException


`XXLJobHelper`是 xxl-job 的工具类


调度中心支持执行器 Failover


注册任务以后，即使任务 deployed 延迟时间已经到了，任务可能不会被立即执行，知道调度中心为其进行调度


任务不被调度中心调度的原因有很多

- 执行器服务比较忙，可能是 CPU 忙，可能是内存不够，也可能是线程池满了

这就需要设置过期策略，如果任务注册成功后


通讯模块介绍


调度中心是一个 server 开放 9999 端口

每次调度任务过程包含：

- 调度中心 向执行器发送 http 请求
- 执行器接收请求，执行任务
- 执行器执行完任务，回调调度中心通知任务执行结果


为降低学习成本，xxl-job 采用 db 进行任务注册和发现。而不是像 dubbo 一样，用 zk 实现注册中心

