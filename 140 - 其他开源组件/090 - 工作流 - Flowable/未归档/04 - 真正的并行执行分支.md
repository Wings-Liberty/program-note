
> [!quote] 参考
> [参考 flowable 官网](https://www.flowable.com/blog/true-parallel-service-task-execution-with-flowable)


# 使用方式


用 FutureJavaDelegate 或其子类 FlowableFutureJavaDelegate，MapBasedFlowableFutureJavaDelegate

改造方式

1. 原先实现 JavaDelegate 改成实现上述接口
2. 创建流程定义时调用 `ServiceTask.setImplementation` 传入这个 Spring Bean 的 Bean Name

比如

```java
ServiceTask node = createServiceTask(currentNodeId);  
node.setImplementation("${parallelServiceTask}");
```

```java
public class ParallelServiceTask implements FlowableFutureJavaDelegate<DelegateExecution, Map<String, Object>> {

}
```

实际使用效果

- case1：一个分支，100 个服务节点，且每当执行到编号个位数是 2 的倍数的服务节点时，停顿 5s
- case2：n 条分支，每条分支 m 个服务节点。且每条分支有 m/5 个节点需要执行 5s，其它节点没有逻辑直接通过，期望结果是不管 n 多大，最终执行时间都是 15s 左右。实际效果：n=50，m=10，预期 25s，实际 161s，猜测是异步执行的线程池最大线程数是 8，刚好 161/25\*8=50

默认最大线程数是 8，是因为用了 flowable-spring-common-6.7.2 后

**Spring 自动装配创建**

ProcessEngineAutoConfiguration.springProcessEngineConfiguration

怎么修改参考[这里](https://www.flowable.com/open-source/docs/bpmn/ch05a-Spring-Boot#flowable-actuator-endpoints)



**默认情况下，用以下方式创建**

```
ProcessEngineConfigurationImpl.init().initAsyncExecutor()initAsyncTaskExecutor()
```

这个方法创建了异步任务执行器的线程池

下面用的默认线程池配置里，`ProcessEngineConfigurationImpl.asyncExecutorCorePoolSize` 和 `ProcessEngineConfigurationImpl.asyncExecutorMaxPoolSize` 都是 8（但实际上用的线程池实现是 SpringAsyncTaskExecutor，它持有一个 ThreadPoolTaskExecutor）

```java
protected void initAsyncTaskExecutor() {  
    if (this.asyncTaskExecutor == null) {  
        DefaultAsyncTaskExecutor defaultAsyncTaskExecutor = new DefaultAsyncTaskExecutor();  
  
        // Thread pool config  
        defaultAsyncTaskExecutor.setCorePoolSize(asyncExecutorCorePoolSize);  
        defaultAsyncTaskExecutor.setMaxPoolSize(asyncExecutorMaxPoolSize);  
        defaultAsyncTaskExecutor.setKeepAliveTime(asyncExecutorThreadKeepAliveTime);  
  
        // Threadpool queue  
        if (asyncExecutorThreadPoolQueue != null) {  
            defaultAsyncTaskExecutor.setThreadPoolQueue(asyncExecutorThreadPoolQueue);  
        }  
        defaultAsyncTaskExecutor.setQueueSize(asyncExecutorThreadPoolQueueSize);  
  
        defaultAsyncTaskExecutor.setThreadFactory(asyncExecutorThreadFactory);  
  
        // Core thread timeout  
        defaultAsyncTaskExecutor.setAllowCoreThreadTimeout(asyncExecutorAllowCoreThreadTimeout);  
  
        // Shutdown  
        defaultAsyncTaskExecutor.setSecondsToWaitOnShutdown(asyncExecutorSecondsToWaitOnShutdown);  
  
        defaultAsyncTaskExecutor.start();  
        this.shutdownAsyncTaskExecutor = true;  
  
        this.asyncTaskExecutor = defaultAsyncTaskExecutor;  
    }  
  
    if (this.asyncTaskInvoker == null) {  
        this.asyncTaskInvoker = new DefaultAsyncTaskInvoker(this.asyncTaskExecutor);  
    }  
}
```


# FutureJavaDelegate 并行任务执行过程



Q1：异步任务是什么时候放到todo里，从todo里取出来后是怎么执行的？执行完异步任务后是怎么把下一个命令压栈到todo列表里的？





Q2：场景：多条分支，每条分支上有多个节点。如果只把每条分支上的第一个节点设置成异步执行的任务为什么就实现不了真正的并行执行多个分支？（普通节点的执行命令会被压栈到todo列表里，如果它执行时间非常长，其它分支上压的栈就必须等这个分支的节点执行完，换句话说本来应该并行执行的分支却需要让分支等待其它分支执行完节点后才会被弹栈再执行命令）





Q3：如果把每条分支上的每个节点设置成异步执行的任务后，为什么就能实现真正的并行执行多个分支了？（为什么下一个异步任务会等到上一个任务执行完后才会执行？是上一个异步任务执行完后才会把下一个命令压栈吗？我之前在源码里并没有看到这写code，在我原先的设想里，要实现真正的并行执行需要每一个节点知道自己是哪个分支的）






# 定制flowable的异步任务执行器



Q1：怎么自定义异步执行器的线程池（flowable-spring-boot自动装配），可以是自定义线程池参数，也可以是用 Java Bean 的方式完全自定义一个线程池对象？






Q2：了解为什么 spring boot 自动装配的线程池最大数量是 Integer.MAX 却不会在并行执行的分支大于 8 时扩充线程数量？






# 了解flowable的异步任务



Q1：异步执行器何时被创建？





Q2：异步执行器会被用来执行哪些任务？






