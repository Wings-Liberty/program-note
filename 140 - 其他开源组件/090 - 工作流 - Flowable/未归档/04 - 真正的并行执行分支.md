
> [!quote] 参考
> [参考 flowable 官网](https://www.flowable.com/blog/true-parallel-service-task-execution-with-flowable)


## 使用方式


用 FutureJavaDelegate 或其子类 FlowableFutureJavaDelegate，MapBasedFlowableFutureJavaDelegate

改造方式

1. 原先实现 JavaDelegate 改成实现上述接口
2. 创建流程定义时调用 `ServiceTask.setImplementation` 传入这个 Spring Bean 的 Bean Name

比如

```java
ServiceTask node = createServiceTask(currentNodeId);  
node.setImplementation("${parallelServiceTask}");
```

```java
public class ParallelServiceTask implements FlowableFutureJavaDelegate<DelegateExecution, Map<String, Object>> {

}
```

实际使用效果

- case1：一个分支，100 个服务节点，且每当执行到编号个位数是 2 的倍数的服务节点时，停顿 5s
- case2：n 条分支，每条分支 m 个服务节点。且每条分支有 m/5 个节点需要执行 5s，其它节点没有逻辑直接通过，期望结果是不管 n 多大，最终执行时间都是 15s 左右。实际效果：n=50，m=10，预期 25s，实际 161s，猜测是异步执行的线程池最大线程数是 8，刚好 161/25\*8=50

默认最大线程数是 8，是因为用了 flowable-spring-common-6.7.2 后

**Spring 自动装配创建**

ProcessEngineAutoConfiguration.springProcessEngineConfiguration

怎么修改参考[这里](https://www.flowable.com/open-source/docs/bpmn/ch05a-Spring-Boot#flowable-actuator-endpoints)



**默认情况下，用以下方式创建**

```
ProcessEngineConfigurationImpl.init().initAsyncExecutor()initAsyncTaskExecutor()
```

这个方法创建了异步任务执行器的线程池

下面用的默认线程池配置里，`ProcessEngineConfigurationImpl.asyncExecutorCorePoolSize` 和 `ProcessEngineConfigurationImpl.asyncExecutorMaxPoolSize` 都是 8（但实际上用的线程池实现是 SpringAsyncTaskExecutor，它持有一个 ThreadPoolTaskExecutor）

```java
protected void initAsyncTaskExecutor() {  
    if (this.asyncTaskExecutor == null) {  
        DefaultAsyncTaskExecutor defaultAsyncTaskExecutor = new DefaultAsyncTaskExecutor();  
  
        // Thread pool config  
        defaultAsyncTaskExecutor.setCorePoolSize(asyncExecutorCorePoolSize);  
        defaultAsyncTaskExecutor.setMaxPoolSize(asyncExecutorMaxPoolSize);  
        defaultAsyncTaskExecutor.setKeepAliveTime(asyncExecutorThreadKeepAliveTime);  
  
        // Threadpool queue  
        if (asyncExecutorThreadPoolQueue != null) {  
            defaultAsyncTaskExecutor.setThreadPoolQueue(asyncExecutorThreadPoolQueue);  
        }  
        defaultAsyncTaskExecutor.setQueueSize(asyncExecutorThreadPoolQueueSize);  
  
        defaultAsyncTaskExecutor.setThreadFactory(asyncExecutorThreadFactory);  
  
        // Core thread timeout  
        defaultAsyncTaskExecutor.setAllowCoreThreadTimeout(asyncExecutorAllowCoreThreadTimeout);  
  
        // Shutdown  
        defaultAsyncTaskExecutor.setSecondsToWaitOnShutdown(asyncExecutorSecondsToWaitOnShutdown);  
  
        defaultAsyncTaskExecutor.start();  
        this.shutdownAsyncTaskExecutor = true;  
  
        this.asyncTaskExecutor = defaultAsyncTaskExecutor;  
    }  
  
    if (this.asyncTaskInvoker == null) {  
        this.asyncTaskInvoker = new DefaultAsyncTaskInvoker(this.asyncTaskExecutor);  
    }  
}
```