Q：主题和队列是什么？为什么会有主题？

A：主题和队列是 MQ 架构的一部分，在业务需求的推动下，MQ 架构演进过程中就出现了主题和队列

架构演进过程如下

1. 队列模型：最简单的模型，服务端有一个严格遵守 “队列” 定义的队列数据结构。这令其存在一条消息只能被一个消费者消费，不能让同一条广播给多个消费者
2. 发布订阅模型：客户端和服务端面对的是 “主题 - Topic”，1条消息是怎么发给多个订阅者由其内部实现。这样就能实现 “消息广播”

**它们最大的区别其实就是，一份消息数据能不能被消费多次的问题。**

这是 MQ 的基本架构（消息模型），在不同 MQ 落地实现时又有各自的名词了

- RabbitMQ 仍用队列模型，但用 “交换机”（RabbitMQ 自己的架构里名词） 实现。其实现广播就是把同一条消息复制 n 份放到多个队列里
- RocketMQ 用发布订阅模型。其服务器被称为 Broker。Broker 里有多个 Topic，每个 Topic 有多个 Queue。如果想保证有序性，每个消费者只能消费一个 Queue 里的消息。否则一串消息被轮询发送到多个队列，一个消费者同时消费多个队列，可能先消费刚才那串消息里的最后一条消息
- Kafka 用发布订阅模型。其和 RocketMQ 的消息模型完全一样。但 RocketMQ 是 Broker - Topic - Queue。Kafka 叫 Broker - Topic - Partition（分区）。但是 Kafka 的分区和 RocketMQ 的 队列是同一个东西，仅仅是名字不一样

为了实现 MQ 必备功能和非必备功能

- 用消息确认重发机制保证消息发送成功和消费成功
- 如果要求消息有序消费
- 消费组
- 发布订阅实现方式：像 RabbitMQ 一样把消息复制 n 份，消费一条删一条的**物理实现方式**（实现简单，但费磁盘。估计这也是 RabbitMQ 堆积消息就寄的原因之一）。或 RocketMQ，Kafka 那样不复制消息，而是为每个消费组创建一个 offset 指针指向消费组消费到哪条消息的**逻辑实现方式**（要实现这个功能就需要解决很多 bug）

#结束 