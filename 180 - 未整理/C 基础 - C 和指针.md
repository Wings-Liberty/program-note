#还没有复习 

# 快速上手


## 预处理指令

```c
#include<stdio.h>
#define MAX 100
```

这些指令被称为预处理指令，由预处理器解释。将其头文件中的数据替换掉指令，结果就是指令被头文件中的数据替换掉。预处理器把被修改过的源代码交给编译器编译



.h 头文件中可以写函数声明，函数声明也被称为函数原型。函数原型中的参数可以没有参数名，只有参数类型



## main 函数

- C 语言中，数组参数是引用形式的传递，传递的是地址；标量和常量是案值传递的

实际上 C 语言的函数传递的参数都是按值传递的，但数组的值就是头号元素的地址

- gets 函数能接收标准输入的输入，以换行符表示结束，且 gets 会丢弃换行符，并在接收的数据的结尾加一个 全 0 的字节数据（称为 NUL）。如果 gets 接收到的数据非 null ，则返回非 null 值；否则返回 null

- puts 函数是 gets 的输出版本，能输出指定字符串，并自动追加一个换行符

- NUL 是 '\0' ，NULL 是一个指向 0 的指针。它们都是整形值，其值相同，所以可以互换

- 字符串是一串以 NUL 结尾的字符

- 格式化输入输出中

  <center>标准输出的格式</center>

| 格式 | 含义               |
| ---- | ------------------ |
| %d   | 十进制形式的整形值 |
| %o   | 八进制形式的整形值 |
| %x   | 十六进制的整形值   |
| %g   | 浮点类型           |
| %c   | 表示一个字符       |
| %s   | 表示一个字符串     |
| \n   | 换行               |

<center>标准输入中的格式</center>

| 格式 | 对应的变量类型 |
| ---- | -------------- |
| %ld  | long           |
| %f   | float          |
| %lf  | double         |
| %c   | char           |
| %s   | char 数组      |

- getchar 函数：从标准输入中读取一个字符。如果没读到任何字符就返回 常量 EOF
- scanf 函数的标量参数前添加 & 字符



# 基本概念



## 环境

翻译 = 编译 + 链接

编译 = 预处理（比如预处理指令的文本替换） + 解析（语法检查生成警号和错误信息） + 为源代码生成目标代码（object code）

链接 = 将多个目标文件和库函数链接到一起生成一个单一的可执行程序文件

![[../020 - 附件文件夹/Pasted image 20230405005011.png|500]]

程序执行过程中使用一个运行时堆栈存储函数的局部变量和返回地址



# 数据



## 基本数据类型

C 语言中只有 4 中基本数据类型：整形，浮点数，指针和聚合类型（数组和结构体）



### 整型

所有整形都有 有符号（singed）和无符号（unsigned）两个版本

![[../020 - 附件文件夹/Pasted image 20230405005027.png|675]]

PS：short 和 short int 是等价的

![[../020 - 附件文件夹/Pasted image 20230405005040.png|600]]

为了得到某个类型或某个变量在特定平台上的准确大小，可以使用 **sizeof** 运算符

<center>变量的范围限制</center>

![[../020 - 附件文件夹/Pasted image 20230405005050.png|700]]

补充：
- 字面值
- 枚举类型


### 浮点数

浮点数字面值在缺省的情况下都是 double 类型的，除非它后面跟一个 L 或 l 表示它是一个 long double 类型的值，或跟 F 或 f 表示它是一个 float 类型的值


### 指针

指针变量就是其值为另一个内存地址的变量

而普通变量的值是内存地址中保存的数据

指针变量既可以直接操作指针：在指针/内存地址上执行算数或比较操作，也可以取出指针指向的地址中保存的数据，对数据进行操作

PS：

![[../020 - 附件文件夹/Pasted image 20230405005131.png|700]]

推荐指针的声明用`int *a;`而不是`int* b`

因为`int* a, b, c;`中只有 a 是指针类型，但阅读时很容易误认为 a，b，c 都是指针类型


### 指针的初始化

```c
// 这条语句把 msg 声明为一个指向字符串的指针，并用字符串常量的第 1 个字符的地址对指针赋值
char *msg = "hello";
// 等价于
char *msg;
msg = "hello";
```

指针的赋值是把值赋给了 msg ，而非 *msg


## typedef

typedef 给数据类型定义新名字

比如`typedef unsigned char BYTE;`

```c
typedef unsigned char BYTE;

// 等价于 unsigned char b1, b2
BYTE  b1, b2;

typedef char *ptr_to_char;

// 等价于 char *a, *b
ptr_to_char a, b;
```

typedef 比 `#define` 能更好地处理指针

## 常量

```c
// 对于普通变量的声明，两种声明是等价的
int const a = 1;
const int a = 2;
```


```c
// 不能让 p 指向其他地址，但可以通过 p 修改它所指向的数据
int const *p;

// 不能修改 p 所指向的数据，但可以修改 p 指向的地址
int *const p;
    
// 既不能修改 p 指向的地址，也不能修改 p 指向的数据
int const *const p;
```


## 作用域

作用域分为为 4 种：文件作用域，函数作用域，代码块作用域和原型作用域


**代码块作用域**

代码块的内部能声明和外部变量同名的变量，且代码块内部会隐藏外部的同名变量

在函数体中，如果声明了和形参同名的变量，形参将被隐藏

**文件作用域**

在代码块之外声明的变量和函数都具有文件作用域，在一个文件里，这些变量和函数都能被访问

**原型作用域**

函数原型，即函数声明。函数原型中的参数列表可以只有参数类型，没有参数名。如果定义了参数名，在调用函数时传递的实参变量名可以和函数形参变量名不同

**函数作用域**

在函数体内声明的变量不能在函数外被访问

## 链接属性

没看懂

## 存储类型

变量的存储类型时指存储变量值的内存类型。变量的存储类型决定变量何时创建，何时销毁以及它的值能保持多久

保存变量的地方有三个：普通内存，运行时堆栈，硬件寄存器

- 在任何代码块之外声明的变量存储在静态内存中。这些变量称为静态变量
- 变量的存储类型不会影响变量的作用域范围

**初始化问题**：没有赋值静态变量的默认值是 0，没有赋值的普通变量的默认值是不确定的（随机的）


## static

- 作用在函数上。函数从 external 变为 internal
- 作用在代码块内部的变量声明上。修改变量的存储方式，从自动变量修改为静态便来给你，但变量的链接属性和作用域不受影响

