#正在复习 

# IO 流是什么

IO 流就是输入流和输出流

输入流的作用是：你创建一个 `InputStream` 对象，然后给它指定一个 “源” 表示让它从这里读数据

输出流的作用是：你创建一个 `OutputStream` 对象，然后给它指定一个 “源” 表示让它把内存里的数据写到里面

“源” 可以是磁盘，可以是键盘输入的数据，控制台显示输出的数据，其他网络发送过来的数据，内存里的数据

为了能从各种源里读写数据，`InputStream` 和 `OutStream` 提供了各种实现类。比如 `FileInputStream` 和 `OutputStream`  把磁盘文件作为 “源”

```java
@Test  
public void testReadFile() throws IOException {  
	// 如果指定的文件不存在就会抛异常。输入输出流和 File 文件不同，File 是抽象的，可以不对应到磁盘文件
    InputStream input = new FileInputStream("src/readme.txt");
    while (true){  
        int data = input.read();  
        if(data != -1){  
            System.out.print(data);  
        }else {  
            break;  
        }  
    }  
    input.close();  
}

@Test  
public void testWrite() throws IOException {  
	// 指定的文件可以不存在，且输出流可以设置写入方式是覆盖还是追加
    OutputStream out = new FileOutputStream("src/readme.txt");  
    // write 方法只能写入一个字节的数据。int 是 4 字节的数据，write 只会取低 8 位的二进制数据
    // 举个例子，写入1，读出1；写入255读出255；但写入256，读出0；写入257，读出1
    out.write(1);  
    out.close();  
}
```

上述的输入输出流在读写人类可阅读的文件时用起来很不方便，因为 `FileInputStream` 只能读到文件里的二进制，如果想看到可阅读的信息，还需要对二进制数据编码。同理，`FileOutputStream` 只能把数据作为二进制数据写到文件里

每次调用输入输出流的 `read` ，`write`方法都会很快触发磁盘读写

> [!tip] 虽然操作系统提供了缓冲区功能但还是需要应用层也提供缓冲流功能
> 缓冲区（Buffer）是位于内存中的一段临时存储空间，在进行I/O读写时，它用来缓存输入输出的数据，并减少磁盘或网络等I/O设备的访问次数，从而提高I/O操作的效率。操作系统也提供了缓冲区的功能，例如在Java中可以通过ByteBuffer 来使用缓冲区。
> 而缓冲流（Buffered Streams）则处于应用程序和输入输出设备之间，负责把输入输出流包装成带有缓冲区的流，提高I/O操作的效率。缓冲流缓存读取的字节或字符，当达到一定的阈值时才真正进行I/O操作，这样就可以将多个小的读写请求合并成一个大的请求，减少 I/O 操作的开销和客户端交互次数。
> 此外，缓冲流还提供了一些额外的功能，例如mark、reset、skip等方法，方便对I/O流的随意定位和跳过某些数据，这些是单纯的缓冲区不能提供的。
> 因此，尽管操作系统提供了原生的缓冲区的功能，但在应用程序中，我们仍然需要借助于缓冲流和它提供的高级功能来进一步优化I/O操作效率。


，虽然操作系统会用缓存实现批量读写，但效率很低。为了实现批量读写：

- 输入流预先读出更多数据到内存，但 `read` 方法每次只从内存里拿 1 字节数据
- 输出流在内存里攒够一批数据后批量写入，但 `write` 方法仍每次只接收 1 字节的数据

这就好像给输入输出流增强了功能

为了让输入输出流能直接读写字符串，就有提供了独立的字符 IO 流继承体系

于是 IO 流就能建立以下体系

![[../../020 - 附件文件夹/Pasted image 20230328233058.png|725]]

> 代码[见](D:\workspace\IDEA-workspace\Study\JavaSE\src\二IO流)


# 文件操作


## Files 类处理文件系统

> `Path` 是通过文件路径管理文件系统，那么 `Files` 就是通过文件管理文件系统，`Files` 的静态方法经常需要 `Path` 对象作为参数

`Files` 包含了获对指定 `Path` 路径对应的文件的操作。例如：

- 获取文件属性。文件是否存在，文件名，文件的拥有者，是否可读可写可执行，文件类型是什么，最后一次修改时间，文件是否是被隐藏的，文件大小文件是否是符号连接
- 读写文件，删除文件。直接读写文件，读写形式多样化。读进 `byte` 数组，将所有行读进 `List` 或 `Stream` 中
- 获取文件的 IO 流对象和 NIO 对象。如果文件是大文件，IO 流和 NIO 流比上一条操作的读写速度更快
- 获取指定目录下的文件列表，或遍历目录下的所有文件（深度优先搜索实现，还能指定最大深度）
- 查找

`Files` 的静态方法除了经常需要 `Path` 对象作参数外，还经常需要其他类的对象当参数。但是它们通常是枚举类


**遍历指定目录**

## Zip文件系统

> 默认的文件系统为磁盘中的文件组成的文件系统
>
> `zip` 压缩文件也是一种文件系统。因为如果你不解压文件却想修改里面的文件，只能解压压缩包或使用第三方软件才能做到这件事。所以 `zip` 压缩文件中文件组成了一个封闭的 ”小型的文件系统“
>
> 在默认的普通文件系统中，`zip` 压缩文件被视为单个文件


为了操作 `zip` 文件代表的文件系统，需要为`zip`文件创建一个文件系统对象，并在对文件系统进行操作

```java
FileSystem fs = FileSystems.newFileSystem(Paths.get(zipPath), null);

// 将 zip 文件系统中的文件复制到外部
Files.copy(fs.getPath(sourcePath), targetPath);
```


- `FileSystems` 是提供创建文件系统对象的工厂类
- `FileSystem` 能提供获取文件分隔符，获取文件系统下的文件等 `API`。此外，它是一个需要关闭的对象
- `zip` 文件系统中的文件不能被 `Path` 创建 `File` 对象


## 内存映射文件

> 大多数操作系统都可以利用虚拟内存实现来将一个文件或者文件的一部分 "映射" 到内存中。然后，这个文件就可以当作是内存数组一样地访问，这比传统的文件操作要快得多。

内存映射文件操作是用`NIO`对文件的操作

- `Buffer` 缓存
- `Channel` 通道
- `RandomAccessFile` 和 `NIO` 的配合

部分 `NIO` 的示例代码[见](D:\workspace\IDEA-workspace\Study\BIO-NIO-Netty\src\test\java\com\cx\test\nio)（`NIO` 核心类的用法）和[这里](D:\workspace\IDEA-workspace\Study\BIO-NIO-Netty\src\main\java\com\cx\nio)（服务端和客户端）

书中内容还包含了之前没学过的部分，书中知识稍后补充


## 正则表达式

暂时跳过，因为记不住正则表达式


# 输入输出流

- 输入输出流经常有嵌套操作，例如

```java
DataInputStream din = new DataInputStream(
	new BufferedInputStream(
		new FileInputStream("employee.dat")));
```

这样在调用`din`时，它能调用使用数据流（ `DataInputStream` ）的方法，同时又具有缓冲功能（ `BufferedInputStream` ），操作的是文件（ `FileInputStream` ）



- 有很多输入输出流都只是提供了模板方法，例如 `BufferedInputStream` 提供了缓冲区，但是它并没有读功能，读功能的实现是其持有的某个 `InputStream` 对象。例如 `FileInputStream`
- 并非所有的流都只能在本地文件上才能建立，比如：`ByteArrayOutputStream` 将数据保存在一个 `byte` 数组中


# 读入写出器


# 输入与输出


输入输出通常使用文本格式或二进制格式。

- **文本格式**是用一种字符编码格式对数据进行编码，在读取时使用相同字符编码格式节码（如果编码和解码使用的字符编码格式不同就会出现乱码）
- **二进制格式**是将数据写为由字节构成的序列（通常用 16 进制表示）


## 文本的输入与输出

文本的输入与输出通常使用 `Writer` 和 `Reader` 的子类（需要指定编码格式，默认是 `UTF-16` ）

编码格式可以从 `java.nio.charset.StandardCharsets` 里选

> 文本格式对于测试和调试而言会显得很方便，因为它是人类可阅读的，但是它并不像以二进制格式传递数据那样高效


## 二进制的输入与输出

二进制的输入与输出通常使用 `InputStream` 和 `OutputStream` 的子类


## 随机访问文件

参考[博客](https://www.cnblogs.com/mengbin0546/p/12603121.html)

> `RandomAccessFile` 是 `java.io` 体系中功能最丰富的文件内容访问类。即可以读取文件内容，也可以向文件中写入内容。但是和其他输入/输入流不同的是，程序可以直接跳到文件的任意位置来读写数据。 
>
> 因为 `RandomAccessFile` 可以自由访问文件的任意位置，所以如果我们希望只访问文件的部分内容，那就可以使用 `RandomAccessFile` 类。 
>
> 与 `OutputStearm`, `Writer` 等输出流不同的是，`RandomAccessFile` 类允许自由定位文件记录指针，所以 `RandomAccessFile` 可以不从文件开始的地方进行输出，所以 `RandomAccessFile` 可以向已存在的文件后追加内容。则应该使用 `RandomAccessFile`。


# 补充

- 通过 System 获取系统的文件分隔符 '/'  or '\\'
- 通过 System 获取系统的文件结束符  '\n' or '\r\n'

# 输入输出流


字节流：InputStream，OutputStream。

字符流：Reader，Writer


输入流：把文件放入输入流中，输入流就能把数据输入到其他地方


```java
int len = in.read(dest_bytes);
```

输出流：把文件放到输出流中，其他数据可以写到输出流中

```java
out.write(source.getBytes());
```

当把 OutputStream 需要把数据写入网卡或磁盘时，会先把数据写入缓冲区，待缓冲区满后再把数据写入网卡或磁盘。所以 OutputStream 不是每写入一字节的数据就会立刻把数据写入网卡或磁盘

如果希望当前缓冲区中的数据立刻被写入 dest，就调用 `flush()` 方法

即使不主动调用它，当缓冲区满时或关闭 IO 流时，`flush()` 也会自动调用

# 字节流常用实现类

- 文件流 - FileInputStream，FileOutputStream

创建文件流需要指定一个 File 对象作为输入 source 或输出 dest

```java
FileInputStream in = new FileInputStream(source_file);

FileOutputStream out = new FileOutputStream(dest_file);
```

- 字节数组流 - BytesArrayInputStream，BytesArrayOutputStream

创建一个字节数组流时需要指定一个 byte array

```java
BytesArrayInputStream in = new BytesArrayInputStream(source_bytes);

BytesArrayInputStream out = new BytesArrayInputStream(dest_bytes);
```


# IO 流的装饰器模式

由上述图示可知，创建 IO 流对象时需要指定数据源，作为 source 或 dest

如果需要增强 IO 流的功能，比如添加加解密功能，解压缩功能，签名功能，就需要更多的 IO 流实现类去完成。JDK 采用装饰器模式实现增强 IO 流

JDK首先将 `InputStream` 分为两大类：

=== multi-column-start: ID_4dnm
```column-settings
Number of Columns: 2
Largest Column: standard
```

一类是直接提供数据的基础`InputStream`，例如：

-   FileInputStream
-   ByteArrayInputStream
-   ServletInputStream
-   ...

=== end-column ===

一类是提供额外附加功能的`InputStream`，例如：

-   BufferedInputStream
-   DigestInputStream
-   CipherInputStream
-   ...

=== multi-column-end

比如希望给 FileInputStream 添加缓冲功能

```java
InputStream file = new FileInputStream("test.gz");

InputStream buffered = new BufferedInputStream(file);
```

又希望 IO 流能提供加解密功能，使得用 IO 流操作压缩文件就像操作普通文件一样

```java
InputStream gzip = new GZIPInputStream(buffered);
```

对 IO 流进行多次装饰包装后，其嵌套装饰关系如下图

```
┌─────────────────────────┐
│GZIPInputStream          │
│┌───────────────────────┐│
││BufferedFileInputStream││
││┌─────────────────────┐││
│││   FileInputStream   │││
││└─────────────────────┘││
│└───────────────────────┘│
└─────────────────────────┘
```

上述这种通过一个 “基础” 组件再叠加各种 “附加” 功能组件的模式，称为装饰器模式

IO 流的 “附加” 功能组件都需要实现 FilterInputStream / FilterOutputStream（装饰器），因此 IO 流有了以下继承体系

```
                 ┌─────────────┐
                 │ InputStream │
                 └─────────────┘
                       ▲ ▲
┌────────────────────┐ │ │ ┌─────────────────┐
│  FileInputStream   │─┤ └─│FilterInputStream│
└────────────────────┘ │   └─────────────────┘
┌────────────────────┐ │     ▲ ┌───────────────────┐
│ByteArrayInputStream│─┤     ├─│BufferedInputStream│
└────────────────────┘ │     │ └───────────────────┘
┌────────────────────┐ │     │ ┌───────────────────┐
│ ServletInputStream │─┘     ├─│  DataInputStream  │
└────────────────────┘       │ └───────────────────┘
                             │ ┌───────────────────┐
                             └─│CheckedInputStream │
                               └───────────────────┘
```

```
                  ┌─────────────┐
                  │OutputStream │
                  └─────────────┘
                        ▲ ▲
┌─────────────────────┐ │ │ ┌──────────────────┐
│  FileOutputStream   │─┤ └─│FilterOutputStream│
└─────────────────────┘ │   └──────────────────┘
┌─────────────────────┐ │     ▲ ┌────────────────────┐
│ByteArrayOutputStream│─┤     ├─│BufferedOutputStream│
└─────────────────────┘ │     │ └────────────────────┘
┌─────────────────────┐ │     │ ┌────────────────────┐
│ ServletOutputStream │─┘     ├─│  DataOutputStream  │
└─────────────────────┘       │ └────────────────────┘
                              │ ┌────────────────────┐
                              └─│CheckedOutputStream │
                                └────────────────────┘
```

# 字符流常用实现类

字符流以 `char` 为单位读写数据，其他部分和字符流基本相同

常用实现类如下

- 文件流 - FileReader，FileWriter
- 字符数组流 - CharArrayReader，CharArrayWriter
- 字符串流 - StringReader，StringWriter


字符流和字节流一样，也有装饰器模式


# 字节流和字符流的关系

普通的字符流是用字节流实现的，不过添加了编解码字符功能，提供了面向读写字符的 API


可用 `InputStreamReader`，`OutputStreamWriter` 实现字节流转字符流，如

```java
try (Reader reader = new InputStreamReader(new FileInputStream("src/readme.txt"), "UTF-8")) {
    // TODO:
}
```


# PrintStream 和 PrintWriter

`PrintStream` 是一种能接收各种数据类型的输出，打印数据时比较方便。

是基于 `FileOutputStream` 构建的，并提供了 `print()` 和 `println()` 方法



`PrintWriter` 是基于 `Writer` 的输出
