#正在复习 

# 父类和子类

`super` 和 `this` 不同。`super` 不是一个对象的引用，不能将 `super` 赋给另一个对象变量，**它只是一个关键字**（用于编译器调用父类的方法）


父类和子类之间存在

- 子类能继承父类的非私有域
- 子类能重写父类的方法（重写方法的访问修饰符范围必须大于等于）
- 子类构造器默认调用父类的无参构造器（如果子类构造器没有显式调用父类的构造器）
- 多态（is-a）：父类声明的对象变量实际类型可以是子类对象或父类对象
- 方法调用方式（动态绑定&静态绑定）：运行时确定对象选择调用的是对象继承层次中的哪个方法

**继承**

- 类派生出来的所有类的集合被称为**继承层次**
- 在继承层次中， 从某个特定的类到其祖先的路径被称为该类的**继承链**


# 访问控制和继承

- 父类中声明为 public 的方法在子类中也必须为 public
- 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。
- 父类中声明为 private 的方法，不能够被子类继承。


# 重写和重载

**方法的重载**： 在同一个类中，出现多个同名的方法，参数列表不同，与返回值类型，修饰符无关

**方法的重写**：子类中出现和父类中一模一样的方法（包括返回值类型，方法名，参数列表，访问修饰符除外），子类中重写的方法的访问权限不能低于父类中方法的访问权限

> 菜鸟教程：重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。**即外壳不变，核心重写！**


# 多态导致的错误


- 强制类型转换导致的错误。类型不匹配的情况下进行类型转换会抛 `ClassCastException`

- 多态的向上转型和向下转型导致的错误
  - 向上转型。将子类对象作为父类对象使用，符合逻辑，永远不出错
  - 向下转型。将父类对象作为子类对象使用，可能会抛错


简单的向下转型导致的错误：将父类对象作为子类对象使用，并且使用父类对象调用的只有子类才有的方法

下面是一个稍微复杂的错误示例（但本质上错误原因也是上述原因）

**错误示例**

场景：`Manager` 是 `Employee` 的子类

```java
Manager[] managers = new Manager[10];
Employee[] staffs = managers;

staffs[0] = new Employee("Harry Hacker", . . .);
managers[0].setBonus(1000);
```

第 1，2 行代码没问题

第 4 行代码，合法，但是存在隐患。最好永远不要这样用

当前 `staffs` 的引用的实际类型是 `Manager` 的数组。但是第 4 行将 `Employee` 类型的变量赋给了数组元素

所以 `managers[0]` 的实际类型是 `Employee`。这显然不合理

所以第 5 行数组元素调用了 `Manager` 对象的方法，但实际类型并不允许它调用，所以抛异常


**类型转换前的类型判断方式**

`a instanceof A`	a 对象的实际类型是不是 A 类或子类（A 可以是类或接口）

`A.class.isInstance(obj)`	obj 是不是 A 类或子类（A 可以是类或接口），是 `instanceof` 的动态实现

`A.class.isAssignableFrom(B.class)`	A 是不是和 B 相同或是 B 的父类


# 多态中对象调用方法的过程


## 方法调用方式

- 静态绑定
- 动态绑定


## 方法调用过程

下述方法调用过程不是线性进行的，和 Spring IOC 器初始化一样 按序开始，交织执行

1. 编译器查看隐式参数（方法调用者）对象的**声明类型**和方法名，并获取对象声明类型中同名方法和父类中访问属性是 `public` 且同名的方法。

   至此，编译器获取所有可能被调用的候选方法（是静态绑定方式中所有的候选方法，动态绑定中可能还包含其他候选方法）

2. 获取方法的方法签名。编译器根据方法签名中的参数列表获取对应的方法，这个过程被称为**重载解析**

   至此，编译器获取到了需要调用的方法名和参数类型

3. 如果调用的方法是 `private`、`static` 或 `final` 方法 或者是构造器方法，方法调用采用静态解析否则使用动态解析，编译器将准确知道应该调用哪个方法，这个调用方式称为**静态绑定**

4. 动态绑定。根据对象变量的实际类型选择合适的那个类的方法进行调用


补充：方法调用是静态绑定还是动态绑定，这在编译后就决定好了的，这体现在字节码指令中（见脑图）


> 重载解析的特殊情况
> 除了能刚好找到形参类型和实参类型完全相同的方法这种简单解析外。还存在需要进行类型转换才能找到方法的情况
> 形参是 int 类型。实参是 double 类型。由于 int 能转换为 double 类型，所以重载解析能在类型转换后定位到一个唯一的方法


每次调用方法都要进行搜索，时间开销大。JVM 就为每个类预先创建了一个方法表 #有待了解 


## 方法表（method table）

> [!todo] 迁移到 JVM 里


方法表以 kv 保存信息。k：方法签名，v：实际调用的方法

一个类的方法表中包含的方法有

- 自己的方法
- 所有从父类继承来的方法（被当前类重写的方法除外）

父类除了显式继承的父类，还包含`Object`这个隐式的父类


## 拓展

动态绑定的开销略大于静态绑定

> 在早期的 Java 中，有些程序员为了避免动态绑定带来的系统开销而使用 final 关键字。如果一个方法没有被覆盖并且很短， 编译器就能够对它进行优化处理，这个过程为称为内联( inlining )
> 
> 幸运的是，虚拟机中的即时编译器比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系，并能够检测出类中是否真正地存在覆盖给定的方法。如果方法很简短、被频繁调用且没有真正地被覆盖，那么即时编译器就会将这个方法进行内联处理。如果虚拟机加载了另外一个子类，而在这个子类中包含了对内联方法的覆盖，那么将会发生什么情况呢？优化器将取消对覆盖方法的内联。这个过程很慢，但却很少发生。


# 接口和抽象类

> 不能通过 `new` +接口名 / 抽象类名实例化一个对象

| 分类   | 有无构造器 | 成员变量默认修饰符  | 成员方法默认修饰符 | 能否有静态代码块和静态方法                               |
| ------ | ---------- | ------------------- | ------------------ | -------------------------------------------------------- |
| 接口   | 无         | public static final |public abstract|不能。JDK8 后能有静态方法（必须有方法体）不能有静态代码块 |
| 抽象类 | 有         | 无                  | 无                 | 能                                                       |


ps：接口默认是 `abstract` 的；实现接口的抽象类可以不实现接口方法

继承抽象类或抽象方法的实现类，必须实现所有的抽象方法


# 成对出现的接口和使用工具类

- `Collection` & `Collections`
- `Path` & `Paths`
- `Object` & `Objects`


# 解决默认方法冲突


A 类的父类和接口有 A 类实现的几个接口中有多个接口有一个同名方法，A类继承的是哪个类或接口的方法

- 父类优先/类优先。父类有方法实现，就忽略其他接口的同名方法的实现

- 接口冲突。子类需要重写方法，在实现体中调用指定的接口的方法来解决冲突

```java
InterfaceName.super.methodName()
```
  

# 标记接口

> 标记接口/标签接口通常都是空接口，其功能就是用来标记。让 JVM 在运行时能根据类实现的标记接口对其进行一些优化处理

#有待了解 

- `Cloneable` 克隆接口（07章节有详解）
- `RandomAccess` 随机访问接口
- `Serializable` 序列化接口


# Object

## equals 方法

> `Object` 类中的 `equals` 方法用于检测一个对象是否等于另外一个对象。对于 String 和基本类型的包装类来说，`equals` 判断的是其字面量是否相同

`Object` 的 `equals` 方法的判断标准是，两个对象变量指向的对象是否是同一个对象

```java
// Object 的 equals 的实现
public boolean equals(Object obj) {
    return (this == obj);
}
```


`Java` 规范要求 `equals` 方法需要遵循以下规则

- 自反性：对于任何非空引用 **x**，**x**.**equals(x)** 应该返回 **true**
- 对称性: 对于任何引用 **x** 和 **y**, 当且仅当 **y**.**equals**(**x**) 返回 **true** , **x**.**equals**(**y**) 也应该返回 **true**。
- 传递性： 对于任何引用 **x**、 **y** 和 **z**, 如果 **x**.**equals**(**y**) 返 **N** **true**， **y**.**equals**(**z**) 返回 **true**，**x**.**equals**(**z**) 也应该返回 **true**。 
- 一致性： 如果 **x** 和 **y** 引用的对象没有发生变化，反复调用 **x**.**eqiuals**(**y**) 应该返回同样的结果。
- 对于任意非空引用 **x**, **x**.**equals**(**null**) 应该返回 **false**


## hashCode 方法

> `Object` 类中的 `hashCode` 方法实现是返回对象的摘要

`Object` 的 `hashCode` 规定（下述为方法注释机翻）

`hashCode` 的一般约定为：

- 只要在 Java 应用程序执行期间在同一对象上多次调用它，hashCode 方法就必须始终返回相同的整数，前提是不修改该对象的 equals 比较中使用的信息。 从一个应用程序的执行到另一个应用程序的执行，此整数不必保持一致。
- 如果根据 equals(Object) 方法两个对象相等，则在两个对象中的每个对象上调用 hashCode 方法必须产生相同的整数结果。
- 如果根据 equals(Object) 方法两个对象不相等，则不需要在两个对象中的每一个成员变量上调用 hashCode 方法都必须产生不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同的整数结果可能会提高哈希表的性能。


## toString

不做赘述


## Objects

是 `Object` 的工具类（数组和 `Arrays` 的关系）

提供很多简单实用的方法实现

```java
public static boolean equals(Object a, Object b) {
    return (a == b) || (a != null && a.equals(b));
}

public static int hash(Object... values) {
    return Arrays.hashCode(values);
}

public static int hashCode(Object o) {
    return o != null ? o.hashCode() : 0;
}
```



