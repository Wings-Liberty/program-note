#还没有复习 

目标：

1. 网络代码来自哪里？
2. 在传输过程中代码是否被破坏？

# 数字签名

## 消息摘要

> 消息摘要（message digest）是数据块的数字指纹。例如，所谓的`SHA1`（安全散列算法）可将任何数据块，无论其数据有多长，都压缩为160 位（20字节）的序列。


用于计算消息摘要的著名算法有 `SHA1` 和 `MD5`

`Java` 编程语言已经实现了 `MD5`，`SHA-1`，`SHA-256`，`SHA-384` 和 `SHA-512`

```java
// 获取使用指定算法的实例
MessageDigest messageDigest = MessageDigest.getInstance("MD5");
// 读取字节流数据
byte[] data = Files.readAllBytes(Paths.get("src/test", "Test.java"));
// 更新数组
messageDigest.update(data);
// 计算指纹
byte[] digest = messageDigest.digest();
System.out.println(Arrays.toString(digest));
```


## 消息签名

原始消息对应一个消息摘要/数字指纹。

如果计算消息得到的数字指纹和预期的数字指纹不同，说明消息被篡改了。

如果有人同时截取到消息和数字指纹，修改数字指纹，导致接收者得到的原始数字指纹就是错误的，那么消息的安全校验就无法保证

消息签名/数字签名用来解决这个问题


**公共密钥加密技术**

- 公共密钥
- 私有密钥

![[../../020 - 附件文件夹/Pasted image 20230328234628.png|350]]

目标：Alice 想要给 Bob 发送一个消息，Bob想知道该消息是否来自 Alice，而不是冒名顶替者

过程 ：

1. Alice 写好了消息， 并且用她的私有密钥对该消息摘要签名。
2. Bob 得到了她的公共密钥的拷贝，然后 `DSA` 私有密钥 Bob 用公共密钥对该签名进行校验。如果通过了校验，则 Bob 可以确认以下两个事实∶

1）原始消息没有被篡改过。

2）该消息是由 Alice签名的，她是私有密钥的持有者，该私有密钥就是与 Bob 用于校验的公共密钥相匹配的密钥。


## 校验签名

> `JDK` 配有一个 `keytool` 程序，该程序是一个命令行工具，用于生成和管理一组证书

`keytool` 创建一个 `.certs` 表示一个密钥库，密钥库里保存有密钥对（公共密钥和私有密钥）。密钥对能有一个别名，别名被用来当作在密钥库中查询密钥对的索引

