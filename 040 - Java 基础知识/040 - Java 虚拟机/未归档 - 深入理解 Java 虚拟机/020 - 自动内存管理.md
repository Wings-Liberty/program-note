#还没有复习 

>  [Java虚拟机脑图](https://www.processon.com/mindmap/5ef47bedf346fb1ae57c498b)包含书的目录结构
>
> md笔记包含虚拟机的深入理解和实用技巧



# JVM运行时的内存划分

> 讲解 Java 虚拟机管理的内存的结构划分

**根据《Java虚拟机规范》的规定，所有Java虚拟机将它管理的内存划分为以下不同的数据区域**

但是具体的实现可以有所不同

![[../../../020 - 附件文件夹/Pasted image 20230402125102.png|500]]

## 程序计数器

每个线程都有一个，是较小的一块内存空间

作用：字节码解释器工作时，通过改变程序计数器的值来选取线程将要执行的下一条字节码指令。它控制程序的指示器，分支，循环，跳转，异常处理，线程恢复等

一个CPU（或一个内核）切换线程时就是通过程序计数器恢复到正确的执行位置



## 虚拟机栈

作用：每个线程都有一个。每执行一个方法就向栈压入一个栈帧，方法返回时就弹出一个栈帧

栈帧的组成：栈帧包含了局部变量表。局部变量表保存基本数据类型，对象引用和reurnAddress类型（指向一条字节码指令的地址）

这些数据类型在局部变量表中所占空间以局部变量槽（Slot）为单位记录，float和double占2个Slot，其他类型占1个Slot。一个Slot占32位

局部变量表所占空间在编译期间完成分配，进入方法时，**局部变量表所需要的空间是完全确定的，不会在方法运行期间被改变**	

```
如果栈的深度超过允许深度，抛StackOverflowError
如果栈申请不到内存，抛OutOfMemoryError
```



为什么栈帧的局部变量表的大小在类编译后就是固定的？可以见：类文件结构中属性表集合的“Code”属性（P233）



## 本地方法栈

作用：每个线程都有一个。为虚拟机执行native方法服务（调用其他程序的服务）；虚拟机栈是为执行Java方法服务的

Java虚拟机规范并没有规定native方法程序使用的语言

ps：有的虚拟机将本地方法栈和虚拟机栈合二为一，如：HotSpot



## 堆

作用：堆的内存几乎保存所有对象。堆也是垃圾回收管理的区域，也称“GC堆”

堆的划分：堆的划分根据虚拟机的不同而不同。但主流的HotSpot用的垃圾回收器使用分代收集理论（将堆分为新生区，老年区，永久区等）以下分区以HotSpot为准

```
如果堆无法申请内存，抛抛OutOfMemoryError
```



## 方法区

作用：所有线程共享的内存。保存 类型信息，常量，静态变量（这些信息到底是啥一会再说）

方法区是JVM的规范，JDK8中方法区的实现叫元空间

ps：《Java虚拟机规范》把方法区描述为堆的一个逻辑部分，但是为了和堆区别开，起个别名叫“非堆”。GC也会回收方法区的内存，主要针对常量池和类型的卸载

堆和方法区的大小可以选择固定大小或可拓展



方法区包含了

- `常量池（Constant Pool）`也叫`class常量池(Class Constant Pool)`
- `字符串常量池(String Pool)`
- `运行时常量池（Runtime Constant Pool）`



**class常量池**

class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是常量池（Constant Pool）

用于存放编译器生成的各种字面量（ Literal ）和 符号引用（Symbolic References），是编译后.class里固定死的静态常量



**字符串常量池**（传说中的字符串常量池）

字符串常量池在类的加载流程中准备阶段完成后在堆中生成字符串实例，并将实例的引用添加到String Table

StringTable：String Pool在方法区，在HotSpot中使用StringTable（哈希表）保存字符串常量（也称驻留字符）的引用（不是对象）

[String Pool深度解析](https://www.cnblogs.com/fangfuhai/p/5500065.html)（已经掌握）


**运行时常量池**

执行类的加载时，类将`class常量池`复制到运行时常量池，类的解析阶段将运行时常量池中的符号引用转换为直接引用



经过解析（resolve，类加载的流程之一）之后，把符号引用替换为直接引用，解析的过程会去查询 `字符串常量池` ，也就是我们上面所说的StringTable，以保证 `运行时常量池`所引用的字符串与 `字符串常量池` 中所引用的是一致的。


上述参考[这篇博客](https://blog.csdn.net/xiaojin21cen/article/details/105300521)


上述关于三个常量池的使用流程会在类加载章节专门讲解，同时还包括字面量，符号引用，直接引用等名词的解释


**直接内存**

作用：NIO的Channel和Buffer能使用native函数库直接分配到堆外内存。通过DirectByteBuffer对象作为这块内存的引用来操作内存。堆外内存大小不受堆大小（-Xmx）的限制

速度比较堆外内存读写速度由于堆内内存

```
直接内存也会抛OutOfMemoryError
```


# HotSpot虚拟机对对象的控制


- 对象的创建
- 对象的内存布局
- 对象的访问定位

见[Java虚拟机脑图](https://www.processon.com/mindmap/5ef47bedf346fb1ae57c498b)


## 对象的创建

使用new创建一个普通对象（不包括数组对象和Class对象）时

- 根据new指令的参数，在常量池中定位到一个类的符号引用
- 如果没有定位到符号引用，说明类没有被加载。先进行类的加载，类加载完成后，继续创建实例对象
- 为对象分配内存。对象需要的内存大小在类加载完成后便完全确定了
- 为对象的字段设置零值（保证字段没有赋初始值也能直接使用）
- 设置对象的对象头。对象头和对象的内存布局有关
- 执行对象的`<init>()`方法——构造方法


**JVM给对象分配空间的方式**

指针碰撞：一边是用过的内存，一边是闲置内存。中间有一个指针。需要内存时，指针向闲置的内存移动，需要多少内存指针就移动多少

这需要保证闲置的内存是连续的，否则无法实现指针移动过的区域是能使用的空闲内存

空闲列表：一个列表记录哪些内存时可用的，需要内存时，从列表中找一块足够大的内存分配给对象

分配方式和垃圾回收算法有关。如果GC能将闲置内存整理成连续的区域就能使用指针碰撞方式分配内存


## 对象的内存布局

- 对象头
  - Mark Word（32位/64位）：保存哈希值，GC年龄，锁信息
  - 类型指针。指向对象的类型元数据
  - 如果对象是数组，还会有数组长度的信息
- 实例数据。父类和子类的所有字段内容
- 占位符填充内存。对象的大小都是8字节的整数倍，如果不够，用占位符填充

![[../../../020 - 附件文件夹/Pasted image 20230402125427.png]]

MarkWord


## 对象的访问定位


对象由`对象示例数据`和`对象类型数据`组成

栈中`reference`访问对象有两种方式

- 句柄访问
- 指针访问（HotSpot主要用这种方式）



# OutOfMemoryError异常

《Java虚拟机规范》中规定，除程序计数器外，虚拟机内存的其他几个运行时区域都有抛出OutOfMemoryError的可能

内存溢出会出现在 堆，虚拟机栈，本地方法栈，方法区，本机

