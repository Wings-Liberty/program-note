#还没有复习 

# 类文件结构


## 平台无关性的基石

> 这里讲述Java 是怎么靠JVM和字节码（class文件）实现的平台无关性，做到一次编写，到处运行的

如果所有计算机的指令集只有x86一种，操作系统只有windows，那么就不会有Java

操作系统和指令集就是“平台”

JVM不光提供了平台无关性，还提供了语言无关性。将其他编程语言的程序编译为Class字节码文件，JVM照样能运行

![[../../../020 - 附件文件夹/Pasted image 20230402125916.png|500]]

## Class文件的结构

class文件是8位字节为基本单位的二进制流，各个数据项目按照顺序紧凑排列，中间没有任何分隔符

一个class文件都对应**唯一的一个**类或接口的定义信息


### class文件示例

源代码（不要去掉下面代码的空格和回车）

**下面对类文件的结构分析都以这个源代码为例展开**

```java
public class Test {

    private int m;

    public int inc() {
        return m + 1;
    }

}
```

字节码文件如下图：左边是偏移量，中间是16进制数据，右边是16进制数据的UTF-8的解码结果

```
  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 	
00000000: CA FE BA BE 00 00 00 34 00 13 0A 00 04 00 0F 09    J~:>...4........
00000010: 00 03 00 10 07 00 11 07 00 12 01 00 01 6D 01 00    .............m..
00000020: 01 49 01 00 06 3C 69 6E 69 74 3E 01 00 03 28 29    .I...<init>...()
00000030: 56 01 00 04 43 6F 64 65 01 00 0F 4C 69 6E 65 4E    V...Code...LineN
00000040: 75 6D 62 65 72 54 61 62 6C 65 01 00 03 69 6E 63    umberTable...inc
00000050: 01 00 03 28 29 49 01 00 0A 53 6F 75 72 63 65 46    ...()I...SourceF
00000060: 69 6C 65 01 00 09 54 65 73 74 2E 6A 61 76 61 0C    ile...Test.java.
00000070: 00 07 00 08 0C 00 05 00 06 01 00 09 74 65 73 74    ............test
00000080: 2F 54 65 73 74 01 00 10 6A 61 76 61 2F 6C 61 6E    /Test...java/lan
00000090: 67 2F 4F 62 6A 65 63 74 00 21 00 03 00 04 00 00    g/Object.!......
000000a0: 00 01 00 02 00 05 00 06 00 00 00 02 00 01 00 07    ................
000000b0: 00 08 00 01 00 09 00 00 00 1D 00 01 00 01 00 00    ................
000000c0: 00 05 2A B7 00 01 B1 00 00 00 01 00 0A 00 00 00    ..*7..1.........
000000d0: 06 00 01 00 00 00 03 00 01 00 0B 00 0C 00 01 00    ................
000000e0: 09 00 00 00 1F 00 02 00 01 00 00 00 07 2A B4 00    .............*4.
000000f0: 02 04 60 AC 00 00 00 01 00 0A 00 00 00 06 00 01    ..`,............
00000100: 00 00 00 08 00 01 00 0D 00 00 00 02 00 0E 
```


### class文件中的数据结构

文件中保存两种数据结构：无符号数，表。可以统称为“项”

无符号数：就是无符号数，u1,u2,u4,u8类型的无符号数分别占用1，2，4，8个字节

表：由多个无符号数和表组成，类型命名习惯上为`xxx_info`


下图就是`Class`的文件格式（`class`文件按照以下顺序无分隔符和填充式存储字节数据）

| 类型           | 名称                | 数量                  | 名称解释                                                     |
| -------------- | ------------------- | --------------------- | ------------------------------------------------------------ |
| u4             | magic               | 1                     | 魔数 固定值 0xCAFEBABE（译：咖啡宝贝）用于判断文件是否是class文件 |
| u2             | minor_version       | 1                     | JDK次版本号                                                  |
| u2             | major_version       | 1                     |JDK主版本号|
| u2             | constant_pool_count | 1                     |常量池计数器。值为 常量池中的项的数量+1。常量池的有效索引值是<br>\(1, constant_pool_count)|
| cp_info        | constant_pool       | constant_pool_count-1 | 常量池。零散地保存了类的元数据。下面的访问标志，类索引，字段表，方法表使用索引将常量池中的元数据按规则提取出来组成**有意义的类的定义**<br>索引0位置含义是，不引用任何一个常量池项 |
| u2             | access_flags        | 1                     | 访问标志。记录这个Class是类还是接口，是不是public、抽象类、final等 |
| u2             | this_class          | 1                     | 类索引。用于指定这个类的全限定名                             |
| u2             | super_class         | 1                     | 父类索引。用于指定这个类的父类的全限定名                     |
| u2             | interfaces_count    | 1                     | 接口计数器。表示当前类或接口的直接实现的接口数量             |
| u2             | interfaces          | interfaces_count      | 接口索引。用于指定这个类实现的所有接口的全限定名             |
| u2             | fields_count        | 1                     | 字段计数器。表示当前类的所有字段数量（不包括父类和接口的字段） |
| field_info     | fields              | fields_count          | 字段表。描述当前接口或类中声明的字段。包括静态变量和成员变量，不包括局部变量。不包括当前类的父类和父接口的字段 |
| u2             | methods_count       | 1                     | 方法计数器。表示当前类的方法个数                             |
| method_info    | methods             | methods_count         |方法表。包括实例方法，类方法，实例初始化方法和类或接口初始化方法。不包括父类和父接口的方法|
| u2             | attributes_count    | 1                     | 属性计数器                                                   |
| attribute_info | attributes          | attributes_count      | 属性表                                                       |


### 常量池

- 表中只有常量池的计数器下标均从1开始，而不是从0开始
- constant_pool就是方法区中的`class常量池`

常量池通常是占class文件最大的数据项目之一，主要保存字面量和符号引用

常量池用Utf8字符串保存了类，父类，接口的全限定名，方法签名，方法名，字段名等很多元数据，供下面的类索引，字段表集合，方法表集合使用


**字面量**：文本字符串，被声明为final的常量值等

**符号引用**：包名，类和接口的全限定名，字段名和描述符，方法名和描述符，方法句柄和方法类型，动态调用点和动态常量等

**方法句柄**：在think in Java中，他们把引用叫做“句柄”。Java中的“句柄”是用来操作对象的

暂时没找到方法句柄的相关概念（[jdk7提供了方法句柄](https://blog.csdn.net/ShuSheng0007/article/details/107066856)，类似反射，但是比反射更快。这里说的方法句柄和jvm的方法句柄可能不是同一个东西）


常量池中保存的数据类型的结构总表见  **深入理解Java虚拟机P219的表6-3和P222的表6-6**


想了解某个class的常量池中有什么东西，可以执行`javap -v Xxx.class`。`Constant pool`下的数据就是`class常量池`的数据

例如下图。常量池中每条数据都有一个索引。在常量池中用`#1  #2  #3`表示，在其他地方直接用数`1  2  3`等数字表示即可

```
Constant pool:
   #1 = Methodref          #4.#15         // java/lang/Object."<init>":()V
   #2 = Fieldref           #3.#16         // test/Test.m:I
   #3 = Class              #17            // test/Test
   #4 = Class              #18            // java/lang/Object
   #5 = Utf8               m
   #6 = Utf8               I
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               inc
  #12 = Utf8               ()I
  #13 = Utf8               SourceFile
  #14 = Utf8               Test.java
  #15 = NameAndType        #7:#8          // "<init>":()V
  #16 = NameAndType        #5:#6          // m:I
  #17 = Utf8               test/Test
  #18 = Utf8               java/lang/Object
```


### 访问标志

访问标志的表见：**P224表6-7**

多个访问标志进行或运算得到最终的访问标志


### 类索引，父类索引和接口索引集合

通过分析下述常量池，`this_class`，`super_class `，`interfaces`能得到当前类及其父类和实现的接口

```
Constant pool:
   #1 = Methodref          #4.#15         // java/lang/Object."<init>":()V
   #2 = Fieldref           #3.#16         // test/Test.m:I
   #3 = Class              #17            // test/Test
   #4 = Class              #18            // java/lang/Object
   #5 = Utf8               m
   #6 = Utf8               I
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               inc
  #12 = Utf8               ()I
  #13 = Utf8               SourceFile
  #14 = Utf8               Test.java
  #15 = NameAndType        #7:#8          // "<init>":()V
  #16 = NameAndType        #5:#6          // m:I
  #17 = Utf8               test/Test
  #18 = Utf8               java/lang/Object
```

从`#3`开始，使用索引逐渐指向类或接口的全限定名。最终指向的全限定名（test/Test）就是**符号索引**的一种

![[../../../020 - 附件文件夹/Pasted image 20230402125937.png]]

忽略上图的 length 的真实值


### 字段表集合

字段表结构：**P226表6-8**

保存了字段的

- 访问标志（包含访问修饰符，final，static，volatile，transient等关键字）
- 字段名的索引（指向常量池的一项）
- 描述符的索引（如果是变量，保存变量类型的索引；如果是方法，保存参数列表，包括参数的数量，类型和顺序，方法返回类型的索引）

字段表集合中不会列出父类或父接口中继承来的字段，但有可能出现Java代码中不存在的的字段

如果字段有附带值，attribute_info 就起作用了，attribute_info 表之后再说


```
Constant pool:
   #1 = Methodref          #4.#15         // java/lang/Object."<init>":()V
   #2 = Fieldref           #3.#16         // test/Test.m:I
   #3 = Class              #17            // test/Test
   #4 = Class              #18            // java/lang/Object
   #5 = Utf8               m
   #6 = Utf8               I
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               inc
  #12 = Utf8               ()I
  #13 = Utf8               SourceFile
  #14 = Utf8               Test.java
  #15 = NameAndType        #7:#8          // "<init>":()V
  #16 = NameAndType        #5:#6          // m:I
  #17 = Utf8               test/Test
  #18 = Utf8               java/lang/Object
```

以私有变量 m 为例

![[../../../020 - 附件文件夹/Pasted image 20230402125950.png|700]]

### 方法表集合

方法表结构：**P226表6-11**

- 方法表集合的结构和字段表集合的结构类似
- 方法表集合中访问标志和字段表集合的有不同的地方。例如，方法不能被volatile，transient修饰，但能被sychronized修饰
- 方法的方法体实现被保存在放方法属性表集合中一个名为“Code”的属性里
- 方法表集合中不包含父类中继承来的方法（子类重写的方法除外）
- 方法表集合中必须有**类构造器`<clinit>`**和**实例构造器`<init>`**，如果没有，编译器帮你自动生成（见：前端编译与优化）


### 属性表集合

class文件，字段表，方法表都能携带自己的属性表集合`attribute_info`

相对于其它表，属性表的限制相对较小，不再要求各个属性表有严格的顺序，在Java SE12中，JVM预定义了29项属性

对于每个属性，它的名称需要从常量池中引入一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则**完全自定义**，只需要一个u4的长度属性去说明属性值所占用的位数即可，一个属性表基本结构如下图所示（实际结构可以根据基本结构拓展）：

| 类型 | 名称                 | 数量             |
| ---- | -------------------- | ---------------- |
| u2   | attribute_name_index | 1                |
| u4   | attribute_length     | 1                |
| u1   | info                 | attribute_length |


虚拟机规范预定义的属性表见：**P231表6-13**


- 在众多预定义的属性中，Code属性包含Java代码编译成的字节码指令

- 可以将Class文件分为代码（Code，方法体中的Java代码）和元数据（Metadata，包括类，字段，方法定义以及其他信息）

- Code属性中，保存了方法体的字节码数据。对于抽象方法，Code属性中可以没有抽象方法的字节码数据
- 字节码，顾名思义每个指令就是一个u1类型的单字节


暂时省略这些属性的结构和作用

其中Code和ConstantValue对于当前的我比较重要，和注解相关可能也比较重要。有时间可以看看



## 字节码指令简介

> Java虚拟机的指令由一个字节长度，代表某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需的参数（称为操作数）构成
>
> 虚拟机的指令集面向操作数栈，而不是面向寄存器（这两种架构的区别在第8章讨论）


如果不考虑异常处理，那Java虚拟机的解释器可以使用下面这段伪代码作为最基本的解释模型来理解，这个执行模型虽然简单，但是依然可以有效地正确工作

```java
do{
    自动计算PC寄存器的值+1;
    根据PC寄存器指示的位置，从字节码流中取出操作码;
    if (字节码存在操作数) 从字节码流中取出操作数;
    执行操作码所定义的操作;
}while(字节码流长度>0);
```


### 字节码与数据类型

`iload`，`lload`，`fload`... 表示从局部变量表中加载指定类型的数据到操作数栈，首字母代表指定类型

c代表char，b代表byte，i代表int，s代表short，l代表long，f代表float，d代表double，a代表reference

没有任何指令支持boolean类型

指令集中支持类型的指令表见：**P252表6-40**


### 指令分类

`加载和存储`、`运算`、`类型转换`、`对象创建与访问`、`操作数栈管理`、`控制转移`、`方法调用和返回`、`异常处理`、`同步`指令

Java字节码分类简介见：**P253**

[Java字节码查询列表](https://blog.csdn.net/zqz_zqz/article/details/79484757)

| 指令分类       | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| 加载和存储     | 实现栈帧中局部变量表和操作数栈中数据的传递                   |
| 运算           | 对操作数栈中的两个值进行某种特定运算，并把结果重新存入操作栈顶 |
| 类型转换       | 两种不同数值类型互相转换（宽化类型转换——隐式转换，窄化类型转换——显示转换） |
| 对象创建与访问 | 创建类实例和数组，访问获取类实例或数组实例中的字段或数组元素 |
| 操作数栈管理   | 对操作数栈进行，入栈、出栈、互换两个数，复制数并重新压入栈顶等操作 |
| 控制转移       | JVM有条件或无条件地指定位置指令的下一条指令继续执行程序。可认为控制指令有条件或无条件地修改了PC寄存器的值<br>控制转移指令具体能用于控制if，switch，try-catch |
| 方法调用和返回 | 调用实例方法，调用静态方法，调用接口方法并寻找和执行接口方法的具体实现，return方法返回值 |
| 异常处理       | athrow，显式抛异常指令                                       |
| 同步           | 这里的同步指令特指对synchronized同步代码块。<br>方法级的同步是隐式的，无需用字节码指令实现，它的实现在方法调用和返回操作中。对于同步方法，在方法表集合中有专门同步的访问标志能标记 |


# 虚拟机类加载机制

Class 文件并非特指某个存在于具体磁盘中的文件，而应当是一串二进制字节流，无论其以何种形式存在，包括但不限于磁盘文件、网络、数据库、内存或动态产生等


类的加载中，这些阶段通常都是互相交叉地混合进行的，。和 Spring 创建 beanDefinition 和 bean 的流程类似


## 类加载时机

![[../../../020 - 附件文件夹/Pasted image 20230402130007.png]]

# 虚拟机字节码执行引擎



