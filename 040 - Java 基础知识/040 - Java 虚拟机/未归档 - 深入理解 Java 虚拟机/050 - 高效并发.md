#还没有复习 

# Java内存模型与线程



## 硬件效率与一致性

物理计算机为了加快运行速度，做了以下两个优化

1. 为解决处理器速度远高于内存速度的问题，引入了高速缓存。（内存是所有处理器共用的，高速缓存是每个处理器都私有一个）
2. 为提高运算单元的效率，乱序执行。

上述优化能提高运行速度，但是也带来了数据不一致的问题。为了解决数据不一致，引入了一致性协议

处理器、高速缓存、主内存间的交互关系

![[../../../020 - 附件文件夹/Pasted image 20230402130104.png|500]]

## Java内存模型

注意区分开JVM内存结构（和运行时内存的划分有关）和JVM内存模型（和并发编程有关）。**这两者基本没有任何关系**



Java为了实现平台无关性，需要自行实现一套内存模型

如果能保证不同平台上使用的内存模型都是JVM内存模型，就不会出现C语言一样直接使用物理硬件和操作系统的内存模型而导致的一套程序在不同平台上运行会出现差异甚至报错的问题



Java内存模型关注  在虚拟机中**把变量值存储到内存和从内存中取出变量值**这样的底层细节。这里说的变量只指哪些**被共享的**实例字段，静态字段和构成数组对象的元。不包括局部变量和方法参数，因为它们是线程私有的



### 主内存和工作内存

Java的内存模型。可以与上张图进行对比

![[../../../020 - 附件文件夹/Pasted image 20230402130113.png|500]]

上图的主内存是JVM内存的一部分

- Java内存模型规定，所有变量都存储在主内存中
- 线程的工作内存中保存了该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行
- 不同的线程之间无法直接访问对方工作内存中的变量，线程间传值均需要通过主内存完成

ps：**即使volatile变量也得在工作内存中保存变量的主内存副本**，但是volatile会保证操作变量时看起来如同在主内存中直接操作变量一样


### 内存间交互操作

  Java提供了8中原子性、不可再分的操作  完成主内存和工作内存之间的变量传递

| 操作           | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| lock（锁定）   | 作用于主内存的变量，把一个变量标识为一条线程独占的状态       |
| unlock（解锁） | 作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定 |
| read（读取）   | 作用于主内存的变量，把一个变量的值从主内存传到工作内存       |
| load（载入）   | 作用于主内存的变量，把read操作获取的变量值放入工作内存的变量副本中 |
| use（使用）    | 作用于工作内存的变量，把工作内存中一个变量的值交给执行引擎。当执行引擎需要某个变量的值时会调用此操作 |
| assign（赋值） | 作用于工作内存的变量，把一个从执行引擎接收的值赋给工作内存中的变量。当字节码执行给变量赋值时会调用此操作 |
| store（存储）  | 作用于工作内存的变量，把一个工作内存的变量传给主内存         |
| write（写入）  | 作用域主内存的变量，获取store传来的变量值并放到主内存的变量中 |

`volatile`就是使用以上指令实现的变量的可见性


### volatile型变量的特殊规则

volatile型的变量的两个语义

- 保证变量的可见性
- 保证变量的赋值操作不会被重排序

当一个线程在工作内存中修改了volatile型的变量后立即执行store和write，其他线程执行read和load就能获取到最新值。普通变量做不到这一点

从案例（P446代码清单12-2和代码清单12-3）上来看，volatile型变量在并发下很适合做标志符（基本不依赖旧值），而不太适合计数器（依赖旧值）

指令重排见：**P446**

volatile通过在代码中插入多个内存屏障指令实现防止指令重排序

内存屏障：指重排序时不能把后面的指令重排序到内存屏障之前的位置

关于内存屏障是如何实现阻止指令重排序的，这和汇编和编译原理有关


### 对float和double型变量的特殊规则

略

### 原子性，可见性和有序性

**原子性**

Java提供的6个操作（`read`,`load`,`use`...）是原子性的，`synchronized`块也具有原子性

**可见性**

volatile型变量提供的可见性：保证变量别修改后，其他线程能立即可见。但是如果对变量并发执行非原子性操作会有线程不安全问题

synchronized提供的可见性：在释放锁前，将变量同步到主内存中（见：P443）

final提供的可见性：被final修饰的字段在构造器中一旦被初始化完成且没有this逸出，那么其他线程就能看到final字段的值

**有序性**

Java天然的有序性：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的

Java提供volatile和synchronized保证有序性

volatile通过禁止重排序保证有序性

synchronized通过锁实现串行执行，一个线程内的操作看似将会是有序的


### 先行发生原则（Happens-Before）

作用：判断数据是否存在竞争，线程是否安全的非常有用的手段。用于检查代码是否有顺序性

定义（不是标准的规定）：如果操作A先行发生于操作B，就是在说发生操作B之前，操作A产生的影响能被操作B观察到

自己的理解：多线程下，保证A操作执行产生的影响后能立即影响到B操作。

- 程序次序规则
- 管程锁定规则
- volatile变量规则
- 线程启动规则
- 线程终止规则
- 线程中断规则
- 对象终结规则
- 传递性

详情见：P453


注：操作A先行发生于操作B，不代表时间上操作A先发生。结论：时间先后顺序和先行发生原则之间基本没有因果关系

## Java与线程，Java与协程

略

新技术：Java的纤程（Fiber）  [纤程介绍](https://www.cnblogs.com/beilong/p/12253328.html)

# 线程安全与锁优化

## 线程安全的实现方法

- 互斥同步：保证共享数据同一时间只能别一条或一些线程使用。实现方式有临界量，互斥量，信号量
- 非阻塞同步：例如CAS


## 锁优化

![[../../../020 - 附件文件夹/Pasted image 20230402130144.png|650]]

